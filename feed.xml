<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yun Blog</title>
  <icon>https://www.gravatar.com/avatar/d313a2c442931458ed624a3999d75011</icon>
  <subtitle>기술 블로</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://cheese10yun.github.io/"/>
  <updated>2018-11-23T18:43:08.398Z</updated>
  <id>https://cheese10yun.github.io/</id>
  
  <author>
    <name>Yun</name>
    <email>cheese10yun@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring OAuth2 Provider 정리</title>
    <link href="https://cheese10yun.github.io/spring-oauth2-provider/"/>
    <id>https://cheese10yun.github.io/spring-oauth2-provider/</id>
    <published>2018-11-23T18:37:00.000Z</published>
    <updated>2018-11-23T18:43:08.398Z</updated>
    
    <content type="html"><![CDATA[<p><strong>해당 코드는 <a href="https://github.com/cheese10yun/springboot-oauth2" rel="external nofollow noopener noreferrer" target="_blank">Github</a>에서 확인할 수 있습니다.</strong></p><h2><span id="oauth2-승인-방식의-종류">OAuth2 승인 방식의 종류</span></h2><ul><li>Authorization Code Grant Type  : 권한 부여 코드 승인 타입<br>클라이언트가 다른 사용자 대신 특정 리소스에 접근을 요청할 떄 사용됩니다. 리스소 접근을 위한 사용자 명과 비밀번호, 권한 서버에 요청해서 받은 권한 코드를 함ㄲ 활용하여 리소스에 대한 엑세스 토큰을 받는 방식입니다.</li><li>Implicit Grant Type : 암시적 승인<br>권한 부여 코드 승인 타입과 다르게 권한 코드 교환 단계 없이 엑세스 토큰을 즉시 반환받아 이를 인증에 이용하는 방식입니다.</li><li>Resource Owner Password Credentials Grant Type : 리소스 소유자 암호 자격 증명 타입<br>클라이언트가 암호를 사용하여 엑세스 토큰에 대한 사용자의 자격 증명을 교환하는 방식식입니다.</li><li>Client Credentials Grant Type : 클라이언트 자격 증명 타입<br>클라이언트가 컨텍스트 외부에서 액세스 토큰을 얻어 특정 리소스에 접근을 요청할 때 사용하는 방식입니다.</li></ul><h2><span id="authorization-code-grant-type-방식">Authorization Code Grant Type 방식</span></h2><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/oauth2-doe-grant-type_gnojt19me.png" alt="oauth2-doe-grant-type"></p><ul><li>(1) 클라이언트가 파리미터러 클라이언트 ID, 리다이렉트 URI, 응답 타입을 code로 지정하여 권한 서버에 전달합니다. 정상적으로 인증이 되면 권한 코드 부여 코드를 클라이언트에게 보냅니다.<ul><li>응답 타입은 code, token 이 사용 가능합니다.</li><li><strong>응답 타입이 token 일 경우 암시적 승인 타입에 해당합니다.</strong></li></ul></li><li>(2) 성공적으로 권한 부여 코드를 받은 클라이언트는 권한 부여 코드를 사용하여 엑세스 토큰을 권한 서버에 추가로 요청합니다. 이때 필요한 파라미터는 클라이언트 ID, 클라이언트 비밀번호, 리다이렉트 URI, 인증 타입 입니다.</li><li>(3) 마지막으로 받은 엑세스 토큰을 사용하여 리소스 서버에 사용자의 데이터를 보냅니다.</li></ul><h3><span id="code">Code</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableAuthorizationServer</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        clients</div><div class="line">                .inMemory() <span class="comment">// (1)</span></div><div class="line">                .withClient(<span class="string">"client"</span>) <span class="comment">//(2)</span></div><div class="line">                .secret(<span class="string">"&#123;bcrypt&#125; $2a$10$iP9ejueOGXO29.Yio7rqeuW9.yOC4YaV8fJp3eIWbP45eZSHFEwMG"</span>)  <span class="comment">//(3) password</span></div><div class="line">                .redirectUris(<span class="string">"http://localhost:9000/callback"</span>) <span class="comment">// (4)</span></div><div class="line">                .authorizedGrantTypes(<span class="string">"authorization_code"</span>) <span class="comment">// (5)</span></div><div class="line">                .scopes(<span class="string">"read_profile"</span>); <span class="comment">// (6)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>(1): 간단한 설정을 위해 메모리에 저장시키겠습니다.</li><li>(2): 클라이언트 이름을 작성합니다.</li><li>(3): 시크릿을 작성해야합니다. 스프링 시큐리티 5.0 부터는 암호화 방식이 조 변경되서 반드시 암호화해서 저장하는 것을 권장합니다. 해당 암호는 password입니다. (현재 프로젝트는 스프링부트 2.1 이기 때문에 스프링 시큐리티 5.0 의존성을 주입받습니다.)</li><li>(4): 리다이렉트 URI을 설정합니다.</li><li>(5): <code>Authorization Code Grant</code> 타입을 설정합니다.</li><li>(6): scope를 지정합니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableResourceServer</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        http.authorizeRequests().anyRequest().authenticated().and()</div><div class="line">                .requestMatchers().antMatchers(<span class="string">"/api/**"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@EnableWebSecurity</span></div><div class="line"><span class="meta">@AllArgsConstructor</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//@formatter:off</span></div><div class="line">http</div><div class="line">                .csrf().disable()</div><div class="line">                .authorizeRequests().anyRequest().authenticated().and()</div><div class="line">                .formLogin().and()</div><div class="line">                .httpBasic();</div><div class="line">        <span class="comment">//@formatter:on</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>리소스 서버 설정은 configure 설정만 간단하게 설정합니다.</li><li>시큐리티 설정은 기본설정에서 csrf 설정만 disable 설정했습니다.</li></ul><h3><span id="인증">인증</span></h3><p><a href="http://localhost:8080/oauth/authorize?client_id=client&amp;redirect_uri=http://localhost:9000/callback&amp;response_type=code&amp;scope=read_profile" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/oauth/authorize?client_id=client&amp;redirect_uri=http://localhost:9000/callback&amp;response_type=code&amp;scope=read_profile</a> 해당 페이지로 이동하면 아래와 같이 로그인 페이지(스프링 시큐리티 기본폼 이전보다 많이 이뻐졌다…)로 리다이렉트 됩니다.</p><p><img src="https://github.com/cheese10yun/springboot-oauth2/raw/master/assets/oauth2-login.png" alt="oauth2-login"><br>로그인 정보를 입력합니다. 소셜 가입에서 해당 소셜의 아이디로 로그인하는 것과 동일한 행위입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">username: user</div><div class="line">password: pass</div></pre></td></tr></table></figure><p>application.yml 에서 설정한 security user 정보를 입력해줍니다.</p><p><img src="https://github.com/cheese10yun/springboot-oauth2/raw/master/assets/oauth-prove.png" alt="oauth-code"><br>유저 정보 인증이 완료되면 scope에 대한 권한 승인이 페이지가 나옵니다. 소셜 가입에서 프로필 정보, 프로필 사진 등을 요구하는 것과 마찬가지입니다.</p><p><img src="https://github.com/cheese10yun/springboot-oauth2/raw/master/assets/oauth-code.png" alt="oauth-code"><br>권한 승인이 완료하면 권한 코드가 전송됩니다. <a href="#authorization-code-grant-type-%EB%B0%A9%EC%8B%9D">Authorization Code Grant Type 방식</a> 에서 말한 <code>권한 부여 코드</code>를 응답받은 것입니다.</p><p>리다이렉트된 페이지에서 위에서 발급 받은 <code>권한 부여 코드</code>로 권한 서버에 <code>Access Token</code>을 요청 받을 수 있습니다. 이 부분이 실제로 구현하지 않았고 넘겨 받은 <code>권한 부여 코드</code>를 기반으로 권한 서버에 수동으로 호출 해보겠습니다.</p><p>아래의 curl을 실행 해보면 응답값을 확인해 볼 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -X POST \</div><div class="line">  http://localhost:8080/oauth/token \</div><div class="line">  -H &apos;Authorization: Basic Y2xpZW50OnBhc3N3b3Jk&apos; \</div><div class="line">  -H &apos;Content-Type: application/x-www-form-urlencoded&apos; \</div><div class="line">  -d &apos;code=xoS4mt&amp;grant_type=authorization_code&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;scope=read_profile&apos;</div></pre></td></tr></table></figure><p>만약 IntelliJ를 사용하신다면 <code>api.http</code>를 이용해서 더 쉽게 호출 해볼 수 있습니다.<br><img src="https://github.com/cheese10yun/springboot-oauth2/raw/master/assets/ouath2-http.png" alt="ouath2-http"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"access_token"</span>: <span class="string">"623d5bc4-7172-44ae-85c1-73a297e6ab04"</span>,</div><div class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</div><div class="line">    <span class="attr">"expires_in"</span>: <span class="number">43199</span>,</div><div class="line">    <span class="attr">"scope"</span>: <span class="string">"read_profile"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="api-호출">API 호출</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -X GET \</div><div class="line">  http://localhost:8080/api/session \</div><div class="line">  -H &apos;Authorization: Bearer 623d5bc4-7172-44ae-85c1-73a297e6ab04&apos;</div></pre></td></tr></table></figure><p>curl을 이용해서 요청을 보내면 아래와 같이 응답값을 확인할 수 있습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"authorities"</span>: [],</div><div class="line">    <span class="attr">"details"</span>: &#123;</div><div class="line">        <span class="attr">"remoteAddress"</span>: <span class="string">"0:0:0:0:0:0:0:1"</span>,</div><div class="line">        <span class="attr">"sessionId"</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">"tokenValue"</span>: <span class="string">"623d5bc4-7172-44ae-85c1-73a297e6ab04"</span></div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>물론 token 정보를 넘기지않거나 유효하지 않으면 401 응답을 받습니다.</p><h2><span id="implicit-grant-type-방식">Implicit Grant Type 방식</span></h2><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/Implicit%20Grant.png" alt="Implicit Grant"></p><ul><li>(1) 클라이언트가 파리미터러 클라이언트 ID, 리다이렉트 URI, 응답 타입을 code로 지정하여 권한 서버에 전달합니다. 정상적으로 인증이 되면 권한 코드 부여 코드를 클라이언트에게 보냅니다.<ul><li>응답 타입은 code, token 이 사용 가능합니다.</li><li><strong>응답 타입이 token 일 경우 암시적 승인 타입에 해당합니다.</strong></li></ul></li><li>(2) 응답 해준 Access Token 이 유효한지 검증 요청을 합니다.</li><li>(3) 요청 받은 Access Token 정보에 대한 검증에 대한 응답값을 돌려줍니다.</li><li>(4) 유효한 Access Token 기반으로 Resource Server와 통신합니다.</li></ul><h3><span id="code">Code</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    clients</div><div class="line">            .inMemory()</div><div class="line">            .withClient(<span class="string">"client"</span>)</div><div class="line">            .secret(<span class="string">"&#123;bcrypt&#125;$2a$10$iP9ejueOGXO29.Yio7rqeuW9.yOC4YaV8fJp3eIWbP45eZSHFEwMG"</span>)  <span class="comment">// password</span></div><div class="line">            .redirectUris(<span class="string">"http://localhost:9000/callback"</span>)</div><div class="line">            .authorizedGrantTypes(<span class="string">"authorization_code"</span>, <span class="string">"implicit"</span>) <span class="comment">// (1) implicit 추가</span></div><div class="line">            .accessTokenValiditySeconds(<span class="number">120</span>)</div><div class="line">            .refreshTokenValiditySeconds(<span class="number">240</span>)</div><div class="line">            .scopes(<span class="string">"read_profile"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>코드는 변경은 거의 없습니다. <code>authorizedGrantTypes()</code> 메서드의 매개변수가 String 배열이기 때문에 <code>&quot;implicit&quot;</code>를 추가해주면 Implicit Grant 방식 설정이 완료됩니다.</p><p>주요한 차이점은 암시적이라는 그랜트 타입의 이름처럼 액세스 토큰이 암시적으로 획득되기 때문에 /auth/token 으로 요청을 보낼 필요가 없습니다.</p><h3><span id="인증">인증</span></h3><p><a href="http://localhost:8080/oauth/authorize?client_id=client&amp;redirect_uri=http://localhost:9000/callback&amp;response_type=token&amp;scope=read_profile&amp;state=test" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/oauth/authorize?client_id=client&amp;redirect_uri=http://localhost:9000/callback&amp;response_type=token&amp;scope=read_profile&amp;state=test</a> 으로 웹브라우저로 요청합니다.</p><ul><li>여기서 중요한점은 <code>response_type=token</code> 으로 요청합니다. <code>Authorization Code Grant Type</code> 에서는 <code>code</code>를 요청했지만 여기서는 <code>token</code> 정보를 응답받기 <strong>위해서 <code>token</code> 정보를 요청합니다.</strong></li><li><code>state=test</code>는 서버의 인가 엔드포인트로 <strong>리다이렉트 될 때 전달할 수 있는 값입니다.</strong> 아래에서 자세히 살펴보겠습니다.</li></ul><p><img src="https://github.com/cheese10yun/springboot-oauth2/raw/master/assets/oauth2-login.png" alt="oauth2-login"></p><p>위 플로우 처럼 로그인을 시도합니다. (username: user, password: pass)</p><p><img src="https://github.com/cheese10yun/springboot-oauth2/raw/master/assets/oauth-prove.png" alt="oauth-code"></p><p>유저 정보 인증이 완료되면 scope에 대한 권한 승인이 페이지가 나옵니다. 소셜 가입에서 프로필 정보, 프로필 사진 등을 요구하는 것과 마찬가지입니다. (위에서 사용한 그림을 그대로 가져왔습니다.)</p><p><img src="https://github.com/cheese10yun/springboot-oauth2/raw/master/assets/Implicit%20Grant-image.png" alt="Implicit Grant-image"><br><a href="http://localhost:9000/callback#access_token=13474f0a-eb0f-4423-9bf3-9a2e9dd3e124&amp;token_type=bearer&amp;state=test&amp;expires_in=120" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:9000/callback#access_token=13474f0a-eb0f-4423-9bf3-9a2e9dd3e124&amp;token_type=bearer&amp;state=test&amp;expires_in=120</a></p><p>리다이렉트된 URL 값입니다.</p><ul><li>access_token=13474f0a-eb0f-4423-9bf3-9a2e9dd3e124 - Implicit Grant 방식에서는 Token 정보를 바로 응답 합니다.</li><li>state=test - 서버 인가 엔드포인트로 리다이렉트 될때 전달 받을 수 있습니다. 넘겨야할 값이 있다면 state를 힐 수 있습니다.</li><li>expires_in=120 - 토근 만료시간초입니다. <code>accessTokenValiditySeconds(120)</code> 메서드로 넘긴 토큰 만료 시간을 전달받습니다.</li><li><strong>Implicit Grant는 리프레시 토큰을 발급하지 않습니다.</strong></li><li>Implicit Grant은 서드파티 애플리케이션에 의한 리다이렉트 URI 등록이 필요합니다. 등록되지 않은 클라이언트에 액세스 토큰이 전달되는 것을 막기 위한 장치입니다.</li></ul><h3><span id="api-호출">API 호출</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -X GET \</div><div class="line">  http://localhost:8080/api/session \</div><div class="line">  -H &apos;Authorization: Bearer 623d5bc4-7172-44ae-85c1-73a297e6ab04&apos;</div></pre></td></tr></table></figure><p>curl을 이용해서 요청을 보내면 아래와 같이 응답값을 확인할 수 있습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"authorities"</span>: [],</div><div class="line">    <span class="attr">"details"</span>: &#123;</div><div class="line">        <span class="attr">"remoteAddress"</span>: <span class="string">"0:0:0:0:0:0:0:1"</span>,</div><div class="line">        <span class="attr">"sessionId"</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">"tokenValue"</span>: <span class="string">"623d5bc4-7172-44ae-85c1-73a297e6ab04"</span></div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="resource-owner-password-credentials-grant-방식">Resource Owner Password Credentials Grant 방식</span></h2><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/Resource%20Owner%20Password%20Credentials%20Grant.png" alt="Resource Owner Password Credentials Grant"></p><ul><li>(1) 인증을 진행합니다. 대부분 ID, Password를 통해서 자격 증명이 진행됩니다.</li><li>(2) 넘겨 받은 정보기반으로 권한 서버에 Access Token 정보를 요청합니다.</li><li>(3) Access Token 정보를 응답 받습니다. 이때 Refresh Token 정보도 넘겨 줄 수도 있습니다.</li><li>(4) Access Token 기반으로 Resource Server와 통신합니다.</li></ul><h3><span id="code">Code</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationManager authenticationManager;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        clients</div><div class="line">                .inMemory()</div><div class="line">                .withClient(<span class="string">"client"</span>)</div><div class="line">                .secret(<span class="string">"&#123;bcrypt&#125;$2a$10$iP9ejueOGXO29.Yio7rqeuW9.yOC4YaV8fJp3eIWbP45eZSHFEwMG"</span>)  <span class="comment">// password</span></div><div class="line">                .redirectUris(<span class="string">"http://localhost:9000/callback"</span>)</div><div class="line">                .authorizedGrantTypes(<span class="string">"authorization_code"</span>, <span class="string">"implicit"</span>, <span class="string">"password"</span>) <span class="comment">// (1) password 타입 추가</span></div><div class="line">                .accessTokenValiditySeconds(<span class="number">120</span>) <span class="comment">//  access token 만료시간</span></div><div class="line">                .refreshTokenValiditySeconds(<span class="number">240</span>) <span class="comment">// refresh token 만료시간</span></div><div class="line">                .scopes(<span class="string">"read_profile"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//(2)</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</div><div class="line">        <span class="comment">//@formatter:off</span></div><div class="line">        endpoints</div><div class="line">                .authenticationManager(authenticationManager) <span class="comment">// Bean 등록은 SecurityConfig 에서 등록합니다.</span></div><div class="line">        ;</div><div class="line">        <span class="comment">//@formatter:on</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>(1) password 타입을 추가합니다.</li><li>(2) authenticationManager 빈등록을 해주고 의존성 주입을 받아 <code>authenticationManager(authenticationManager)</code> 메서드를 통해 객체를 넘겨줍니다.</li></ul><h3><span id="인증">인증</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -X POST \</div><div class="line">  http://localhost:8080/oauth/token \</div><div class="line">  -H &apos;Authorization: Basic Y2xpZW50OnBhc3N3b3Jk&apos; \</div><div class="line">  -H &apos;Content-Type: application/x-www-form-urlencoded&apos; \</div><div class="line">  -d &apos;username=user&amp;password=pass&amp;grant_type=password&amp;scope=read_profile&apos;</div></pre></td></tr></table></figure><p>인증 요청은 위 플로우 설명 처럼 password 기반으로 token 정보를 요청합니다. 유저의 비밀번호 인증이 완료되면 아래와 같이 응답을 받습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"access_token"</span>: <span class="string">"bb438582-0d12-4a67-94f5-0bdbcd8b29ef"</span>,</div><div class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</div><div class="line">    <span class="attr">"expires_in"</span>: <span class="number">103</span>,</div><div class="line">    <span class="attr">"scope"</span>: <span class="string">"read_profile"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="api-호출">API 호출</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -X GET \</div><div class="line">  http://localhost:8080/api/session \</div><div class="line">  -H &apos;Authorization: Bearer 623d5bc4-7172-44ae-85c1-73a297e6ab04&apos;</div></pre></td></tr></table></figure><p>curl을 이용해서 요청을 보내면 아래와 같이 응답값을 확인할 수 있습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"authorities"</span>: [],</div><div class="line">    <span class="attr">"details"</span>: &#123;</div><div class="line">        <span class="attr">"remoteAddress"</span>: <span class="string">"0:0:0:0:0:0:0:1"</span>,</div><div class="line">        <span class="attr">"sessionId"</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">"tokenValue"</span>: <span class="string">"623d5bc4-7172-44ae-85c1-73a297e6ab04"</span></div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="client-credentials-grant-type-방식">Client Credentials Grant Type 방식</span></h2><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/Client%20Credentials%20Grant%20Type.png" alt="Client Credentials Grant Type"></p><ul><li>(1) Access Token 정보를 요청합니다.</li><li>(3) Access Token 정보를 응답합니다. 이때 Refresh Token 정보는 응답하지 않는 것을 권장합니다. 별다른 인증 절차가 없기 떄문에 Refresh Token 까지 넘기지 않는 것이라고 생각합니다.</li><li>(4) Access Token 기반으로 Resource Server와 통신합니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    clients</div><div class="line">            .inMemory()</div><div class="line">            .withClient(<span class="string">"client"</span>)</div><div class="line">            .secret(<span class="string">"&#123;bcrypt&#125;$2a$10$iP9ejueOGXO29.Yio7rqeuW9.yOC4YaV8fJp3eIWbP45eZSHFEwMG"</span>)  <span class="comment">// password</span></div><div class="line">            .redirectUris(<span class="string">"http://localhost:9000/callback"</span>)</div><div class="line">            .authorizedGrantTypes(<span class="string">"authorization_code"</span>, <span class="string">"implicit"</span>, <span class="string">"password"</span>, <span class="string">"client_credentials"</span>) <span class="comment">// client_credentials 추가</span></div><div class="line">            .accessTokenValiditySeconds(<span class="number">120</span>)</div><div class="line">            .refreshTokenValiditySeconds(<span class="number">240</span>)</div><div class="line">            .scopes(<span class="string">"read_profile"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>코드의 변경사항은 <code>client_credentials</code> 변경 뿐입니다.</li><li>리소스 주인이 어떤 권한인증을 하지 않기 때문에 Refresh Token을 넘겨주지 않는것이 바람직합니다.</li><li>Client Credentials Grant Type은 리소스 소유자에게 권한 위임 받아 리소스에 접근하는 것이 아니라 자기 자신이 애플리케이션을 사용할 목적으로 사용하는 것이 일반적입니다.</li></ul><h3><span id="인증">인증</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -X POST \</div><div class="line">  http://localhost:8080/oauth/token \</div><div class="line">  -H &apos;Authorization: Basic Y2xpZW50OnBhc3N3b3Jk&apos; \</div><div class="line">  -H &apos;Content-Type: application/x-www-form-urlencoded&apos; \</div><div class="line">  -d &apos;grant_type=client_credentials&amp;scope=read_profile&amp;undefined=&apos;</div></pre></td></tr></table></figure><p>curl을 이용해서 요청을 보내면 아래와 같이 응답값을 확인할 수 있습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"access_token"</span>: <span class="string">"fd4123f6-1f4f-4eeb-8342-e4eefefaee40"</span>,</div><div class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</div><div class="line">    <span class="attr">"expires_in"</span>: <span class="number">119</span>,</div><div class="line">    <span class="attr">"scope"</span>: <span class="string">"read_profile"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="api-호출">API 호출</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -X GET \</div><div class="line">  http://localhost:8080/api/session \</div><div class="line">  -H &apos;Authorization: Bearer 623d5bc4-7172-44ae-85c1-73a297e6ab04&apos;</div></pre></td></tr></table></figure><p>curl을 이용해서 요청을 보내면 아래와 같이 응답값을 확인할 수 있습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"authorities"</span>: [],</div><div class="line">    <span class="attr">"details"</span>: &#123;</div><div class="line">        <span class="attr">"remoteAddress"</span>: <span class="string">"0:0:0:0:0:0:0:1"</span>,</div><div class="line">        <span class="attr">"sessionId"</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">"tokenValue"</span>: <span class="string">"623d5bc4-7172-44ae-85c1-73a297e6ab04"</span></div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="refresh-token">Refresh Token</span></h2><p>리프레시 토큰 그랜트 타입은  액세스 토큰이 만료될 떄마다 리소스 소유자가 매번 인가 서버를 통해 수행해야 하는 인증, 인가 절차를 수행하지 않아도 되기 때문에 조금더 좋은 사용자 경험을 제공할 수 있습니다.</p><h3><span id="code">Code</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationManager authenticationManager;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        clients</div><div class="line">                .inMemory()</div><div class="line">                .withClient(<span class="string">"client"</span>)</div><div class="line">                .secret(<span class="string">"&#123;bcrypt&#125;$2a$10$iP9ejueOGXO29.Yio7rqeuW9.yOC4YaV8fJp3eIWbP45eZSHFEwMG"</span>)  <span class="comment">// password</span></div><div class="line">                .redirectUris(<span class="string">"http://localhost:9000/callback"</span>)</div><div class="line">                .authorizedGrantTypes(<span class="string">"authorization_code"</span>, <span class="string">"implicit"</span>, <span class="string">"password"</span>, <span class="string">"client_credentials"</span>, <span class="string">"refresh_token"</span>) <span class="comment">// refresh_token 추가</span></div><div class="line">                .accessTokenValiditySeconds(<span class="number">120</span>)</div><div class="line">                .refreshTokenValiditySeconds(<span class="number">240</span>)</div><div class="line">                .scopes(<span class="string">"read_profile"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>authorizedGrantTypes()</code> 메서드에 refresh을 추가합니다.</li></ul><h3><span id="인증">인증</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -X POST \</div><div class="line">  http://localhost:8080/oauth/token \</div><div class="line">  -H &apos;Content-Type: application/x-www-form-urlencoded&apos; \</div><div class="line">  -d &apos;username=user&amp;password=pass&amp;grant_type=password&amp;scope=read_profile&apos;</div></pre></td></tr></table></figure><p>아래의 JSON이 응답값입니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"access_token"</span>: <span class="string">"bbcb6b66-c822-4816-a5ef-afe57becdb12"</span>,</div><div class="line">  <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</div><div class="line">  <span class="attr">"refresh_token"</span>: <span class="string">"eb465a46-0b9f-4180-bce6-bf2918c378c2"</span>,</div><div class="line">  <span class="attr">"expires_in"</span>: <span class="number">119</span>,</div><div class="line">  <span class="attr">"scope"</span>: <span class="string">"read_profile"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>refresh_token token이 추가 된것을 확인 할 수 있습니다.</strong></p><p><strong>access token의 만료시간이 지났을 경우 해당 토큰으로 접근하면 아래와 같은 응답값을 받게 됩니다.</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"error"</span>: <span class="string">"invalid_token"</span>,</div><div class="line">  <span class="attr">"error_description"</span>: <span class="string">"Access token expired: a5ea1096-a6e3-4d4b-a511-8a896b8e85b0"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>이때 위에서 발금받은 refresh token 기반으로 access token 정보를 다시 요청 할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -X POST \</div><div class="line">  http://localhost:8080/oauth/token \</div><div class="line">  -H &apos;Authorization: Basic Y2xpZW50OnBhc3N3b3Jk&apos; \</div><div class="line">  -H &apos;Content-Type: application/x-www-form-urlencoded&apos; \</div><div class="line">  -d &apos;grant_type=refresh_token&amp;scope=read_profile&amp;refresh_token=b7d6a15c-f063-4457-b417-0555cb54b57a&apos;</div></pre></td></tr></table></figure><p>refresh token 정보로 access token 정보를 받을 수 있습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"access_token"</span>: <span class="string">"8edce9ad-e256-4601-9388-510d37e951bc"</span>,</div><div class="line">  <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</div><div class="line">  <span class="attr">"refresh_token"</span>: <span class="string">"b7d6a15c-f063-4457-b417-0555cb54b57a"</span>,</div><div class="line">  <span class="attr">"expires_in"</span>: <span class="number">119</span>,</div><div class="line">  <span class="attr">"scope"</span>: <span class="string">"read_profile"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>위에서 설명했듯이 Refresh Token을 받을 수 있는 타입은 <code>Authorization Code Grant</code>, <code>Resource Owner Password Credentials Grant</code>입니다.</strong> 그 이외에는 Refresh Token을 넘겨주지 않습니다.</p><h2><span id="참고">참고</span></h2><ul><li><a href="http://www.bubblecode.net/en/2016/01/22/understanding-oauth2/" rel="external nofollow noopener noreferrer" target="_blank">OAuth2 이해하기</a></li><li><a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B4458049183" rel="external nofollow noopener noreferrer" target="_blank">처음으로 배우는 스프링 부트2</a></li><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791161752211&amp;orderClick=LAG&amp;Kc=" rel="external nofollow noopener noreferrer" target="_blank">OAuth 2.0 쿡북</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/springboot-oauth2&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="OAuth2" scheme="https://cheese10yun.github.io/tags/OAuth2/"/>
    
      <category term="Provider" scheme="https://cheese10yun.github.io/tags/Provider/"/>
    
  </entry>
  
  <entry>
    <title>Spring Batch 간단 정리</title>
    <link href="https://cheese10yun.github.io/spring-batch-basic/"/>
    <id>https://cheese10yun.github.io/spring-batch-basic/</id>
    <published>2018-11-19T16:12:00.000Z</published>
    <updated>2018-11-19T15:22:57.601Z</updated>
    
    <content type="html"><![CDATA[<p>스프링 배치는 벡엔드의 배치처리 기능을 구현하는 데 사용하는 프레임워크입니다. 스프링 부트 배치는 스프링 배치 설정 요소들을 간편화시켜 스프링 배치를 빠르게 설정하는 데 도움을 줍니다. <strong>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/batch-demo" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인해주세요.</strong></p><h2><span id="스프링-부트-배치의-장점">스프링 부트 배치의 장점</span></h2><ul><li>대용량 데어터 처리에 최적화되어 고성능을 발휘합니다.</li><li>효과적인 로깅, 통계 처리, 트랜잭션 관리 등 재사용 가능한 필수 기능을 지원합니다.</li><li>수동으로 처리하지 않도록 자동화되어 있습니다.</li><li>예외사항과 비정상 동작에 대한 방어 기능이 있습니다.</li><li>스프링 부트 배치는 반복적인 작업 프로세스를 이해하면 비니지스로직에 집중할 수 있습니다.</li></ul><h2><span id="스프링-부트-배치-주의사항">스프링 부트 배치 주의사항</span></h2><p>스프링 부트 배치는 스프링 배치를 간편하게 사용 할 수 있게 래핑한 프로젝트입니다. 따라서 스프링 부트 배치와 스프링 배치에 모두에서 다음과 같은 주의사항을 염두해야 합니다.</p><ul><li>가능하면 단순화해서 복잡한 구조와 로직을 피해야합니다.</li><li>데이터를 직접 사용하는 편이 빈번하게 일어나므로 데이터 무결성을 우지하는데 유효성 검사 등의 방어책이 있어야합니다.</li><li>배치 처리 시스템 I/O 사용을 최소화해야합니다. 잦은 I/O로 데이터베이스 컨넥션과 네트워크 비용이 커지면 성능에 영향을 줄 수 있기 때문입니다. 따라서 가능하면 한번에 데이터를 조회하여 메모리에 저장해두고 처리를 한 다음. 그결과를 한번에 데이터베이스에 저장하는것이 좋습니다.</li><li>일반적으로 같은 서비스에 사용되는 웹 API, 배치, 기타 프로젝트들을 서로 영향을 줍니다. 따라서 배치 처리가 진행되는 동안 다른 프로젝트 요소에 영향을 주는 경우가 없는지 주의를 기울여야합니다.</li><li>스프링 부트는 배치 스케줄러를 제공하지 않습니다. 따라서 배치 처리 기능만 제공하여 스케줄링 기능은 스프링에서 제공하는 쿼치 프레임워크 등을 이용해야합니다. <strong>리눅스 crontab 명령은 가장 간단히 사용 할 수 있지만 이는 추천하지 않습니다.</strong> crontab의 경우 각 서버마다 따로 스케줄리을 관리해야 하며 무엇보다 클러스터링 기능이 제공되지 않습니다. 반면에 쿼티 같은 스케줄링은 프레임워크를 사용한다면 클러스터링뿐만 아니라 다양한 스케줄링 기능, 실행 이력 관리 등 여러 이점을 얻을 수 있습니다.</li></ul><h2><span id="스프링-부트-배치-이해하기">스프링 부트 배치 이해하기</span></h2><p>배치의 일반적인 시나리오는 다음과 같은 3단계로 이루어집니다.</p><ol><li>읽기(read) : 데이터 저장소(일반적으로 데이터베이스)에서 특정 데이터 레코드를 읽습니다.</li><li>처리(processing) : 원하는 방식으로 데이터 가공/처리 합니다.</li><li>쓰기(write) : 수정된 데이터를 다시 저장소(데이터베이스)에 저장합니다.</li></ol><p>배치 처리는 읽기 -&gt; 처리 -&gt; 쓰기 흐름을 갖습니다. 다음 그림은 스프링에서 이러한 배치 처리를 어떻게 구현 했는지 배치 처리와 관련된 객체의 관계를 보여줍니다.</p><p align="center">  <img src="https://github.com/cheese10yun/TIL/raw/master/assets/batch-obejct-relrationship.png"></p><ul><li>Job과 Step은 1:M</li><li>Step과 ItemReader, ItemProcessor, ItemWriter 1:1</li><li>Job이라는 하나의 큰 일감(Job)에 여러 단계(Step)을 두고, 각 단계를 배치의 기본 흐름대로 구성합니다.</li></ul><h3><span id="job">Job</span></h3><ul><li>Job은 배치 처리 과정을 하나의 단위로 만들어 포현한 객체입니다. 또한 전체 배치 처리에 있어 항상 최상단 계층에 있습니다.</li><li>위에서 하나의 Job(일감) 안에는 여러 Step(단계)이 있다고 설명했던 바와 같이 <strong>스프링 배치에서 Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너 입니다</strong></li><li>Job 객체를 만드는 빌더는 여러 개 있습니다. 여러 빌더를 통합합 처리하는 공장인 JobBuilderFactory로 원하는 Job을 쉽게 만들수 있습니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobBuilderFactory</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> JobRepostiroy jobrepository;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobBuilderFactory</span><span class="params">(JobRepository jobRepository)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.jobrepository = jobrepository;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> JobBuilder <span class="title">get</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        JobBuilder builder = <span class="keyword">new</span> JobBuilder(name).repository(jobrepository);</div><div class="line">        <span class="keyword">return</span> builder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>JobBuilderFactory는 JobBuilder를 생성할 수 있는 get() 메서드를 포함하고 있습니다. get()메서드는 새로운 JobBuilder를 생성해서 반환하는 것을 확인할 수있습니다.</li><li>JobBuilderFactory에서 생성되는 모든 JobBulder가 레포지토리를 사용합니다.</li><li>JobBuilderFactory는 JobBuilder를 생성하는 역할만 수행합니다. 이렇게 생성된 JobBuilder를 이용해서 Job을 생성해야 하는데, 그렇다면 JobBuilder의 역할은 무엇인지 JobBuilder의 메서드를 통해 기능을 알아보겠습니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SimpleJobBuilder <span class="title">start</span><span class="params">(Step step)</span></span>&#123;</div><div class="line">    <span class="comment">//(1)</span></div><div class="line">    <span class="comment">// Step을 추가해서 가장 기본이되는 SimpleJobBuilder를 생성합니다.</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleJobBuilder(tihs).start(step);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> JobFlowBuilder <span class="title">start</span><span class="params">(Flow flow)</span></span>&#123;</div><div class="line">    <span class="comment">//(2)</span></div><div class="line">    <span class="comment">// Flow를 실행할 JobFlowBuilder를 생성합니다.</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JobFlowBuilder(tihs).start(flow);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> JobFlowBuilder <span class="title">flow</span><span class="params">(Step step)</span></span>&#123;</div><div class="line">    <span class="comment">//(3)</span></div><div class="line">    <span class="comment">// Step을 실행할 FlowJobBuilder를 생성합니다.</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JobFlowBuilder(tihs).start(step);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>JobBuilder는 직접적으로 Job을 생성하는 것이 아니라 별도의 구체적 빌더를 생성하여 변환하여 경우에 따라 Job 생성 방법이 모두 다를 수 있는 점을 유연하게 처리할 수 있습니다.</li></ul><h3><span id="jobinstance">JobInstance</span></h3><ul><li><strong>JobInstance는 배치 처리에서 Job이 실행될 때 하나의 Job 실행 단위입니다.</strong> 만약 하루에 한 번 씩 배치의 Job이 실행된다면 어제와 오늘 실행 각각 Job을 JobInstance라고 부를 수 있습니다.</li><li>각각의 JobInstance는 하나의 JobException을 갖는 것은아닙니다. 오늘 Job이 실행 했는데 실패했다면 다음날 동일한 JobInstance를 가지고 또 실행합니다.</li><li>Job 실행이 실패하면 JobInstance가 끝난것으로 간주하지 않기 때문입니다. 그렇다면 JobInstance는 어제 실패한 JobExcution과 오늘의 성공한 JobExcution 두 개를 가지게 됩니다. <strong>즉 JobExcution 는 여러 개 가질 수 있습니다.</strong></li></ul><h3><span id="jobexcution">JobExcution</span></h3><ul><li>JobExcution은 JobIstance에 대한 한 번의 실행을 나타내는 객체입니다.</li><li>만약 오늘 Job이 실패해 내일 다시 동일한 Job을 실행하면 오늘/내일의 실행 모두 같은 JobInstance를 사용합니다.</li><li>실제로 JobExcution 인터페이스를 보면 Job 실행에 대한 정보를 담고 있는 도메인 객체가 있습니다. JobExcution은 JobInstance, 배치 실행 상태, 시작 시간, 끝난 시간, 실패했을 때 메시지 등의 정보를 담고 있습니다. JobExcution 객체 안에 어떤 실행 정보를 포함 하고 있습니다.</li></ul><h3><span id="jobparameters">JobParameters</span></h3><ul><li>JobParameters는 Job이 실행될 때 필요한 파라미터들은 Map 타입으로 지정하는 객체 입니다.</li><li>JobParameters는 JobInstance를 구분하는 기준이 되기도 합니다.</li><li>JobParameters와 JobInstance는 1:1 관계입니다.</li></ul><h3><span id="step">Step</span></h3><ul><li>Step은 실직적인 배치 처리를 정희하고 제어 하는데 필요한 모든 정보가 있는 도메인 객체입니다. Job을 처리하는 실질적인 단위로 쓰입니다.</li><li>모든 Job에는 1개 이상의 Step이 있어야 합니다.</li></ul><h4><span id="stepexcution">StepExcution</span></h4><ul><li>Job에 JobExcution Job실행 정보가 있다면 Step에는 StepExcution이라는 Step 실행 정보를 담는 객체가 있씁니다.</li></ul><h3><span id="jobrepository">JobRepository</span></h3><ul><li>JobRepository는 배치 처리 정보를 담고 있는 매커니즘입니다. 어떤 Job이 실행되었으면 몇 번 실행되었고 언제 끝났는지 등 배치 처리에 대한 메타데이터를 저장합니다.</li><li>예를들어 Job 하나가 실행되면 JobRepository에서는 배치 실행에 관련된 정보를 담고 있는 도메인 JobExcution을 생성합니다.</li><li>JobRepository는 Step의 실행 정보를 담고 있는 StepExcution도 저장소에 저장하여 전체 메타데이터를 저장/관리하는 역할을 수행합니다.</li></ul><h3><span id="joblauncher">JobLauncher</span></h3><ul><li>JobLauncher는 Job. JobParamerters와 함께 배치를 실행하는 인터페이스입니다.</li></ul><h3><span id="itemreader">ItemReader</span></h3><ul><li>ItemReader는 Step의 대상이 되는 배치 데이터를 읽어오는 인터페이스입니다. File, Xml Db등 여러 타입의 데이터를 읽어올 수 있습니다.</li></ul><h3><span id="itemprocessor">ItemProcessor</span></h3><ul><li>ItemProcessor는 ItemReader로 읽어 온 배치 데이터를 변환하는 역할을 수행합니다. 이 것을 분리하는 이유는 다음과 같습니다.</li><li>비지니스 로직의 분리 : ItemWriter는 저장망 수행하고, ItemProcessor는 로직 처리만 수행해 역할을 명확하게 분리합니다.</li><li>읽어온 배치 데이터와 씌여질 데이터의 타입이 다를 경우에 대응할 수 있기 때문입니다.</li></ul><h3><span id="itemwriter">ItemWriter</span></h3><ul><li>ItemWriter는 배치 데이터를 저장합니다. 일반적으로 DB나 파일에 저장합니다.</li><li>ItemWriter도 ItemReader와 비슷한 방식을 구현합니다. 제네릭으로 원하는 타입을 받고 write() 메서드는 List를 사용해서 저장한 타입의 리스트를 매게변수로 받습니다.</li></ul><h2><span id="휴먼회원-배치-설계">휴먼회원 배치 설계</span></h2><p align="center">  <img src="https://github.com/cheese10yun/TIL/raw/master/assets/bach-process.png"></p><p><strong>가입한 회원 중 1년이 지나도록 상태 변화가 없는 회원을 휴면회원으로 전환하는 배치 처리</strong></p><ul><li>(1) DB에 저장된 데이터 중 1년간 업데이트되지 않은 사용자를 찾는 로직 ItemReader 구현합니다.</li><li>(2) 대상 사용자 데이터의 상탯값을 휴면으로 전환하는 프로세스를 ItemProcessor에 구현합니다.</li><li>(3) 상태값이 변환된 휴먼회원을 실제DB에 저장하는 ItemWriter를 구현합니다.</li></ul><h2><span id="휴먼회원-배치-구현">휴먼회원 배치 구현</span></h2><p>배치처리 순서는 다음과 같습니다.</p><ol><li>휴면 회원 Job 설정</li><li>휴먼회원 Step 설정</li><li>휴면회원 Reader, Processor, Writer 설정</li></ol><h3><span id="job-설정">Job 설정</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InactiveUserJobConfig</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Job <span class="title">inactiveUserJob</span><span class="params">(JobBuilderFactory jobBuilderFactory, Step inactiveJobStep)</span> </span>&#123; <span class="comment">//(1)</span></div><div class="line">        <span class="keyword">return</span> jobBuilderFactory.get(<span class="string">"inactiveUserJob"</span>)</div><div class="line">                .preventRestart() <span class="comment">//(2)</span></div><div class="line">                .start(inactiveJobStep) <span class="comment">//(3)</span></div><div class="line">                .build();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><ul><li>(1) Job 생성을 직관적이고 편리하게 도와주는 빌더 JobBuilderFactory를 주입받습니다.</li><li>(2) inactiveUserJob 이라는 JobBuilder를 생성하며 <code>preventRestart()</code> 설정을 통해 재실행을 막았습니다.</li><li>(3) <code>start(inactiveJobStep)</code>은 파라미터에서 주입받은 휴먼회원 관련 Step인 inactiveJobStep을 제일 먼저 실행하도록 설정하는 부분입니다.</li></ul><p>기본적인 Job설정은 완료 했습니다. Step 설정을 진행하겠습니다.</p><h3><span id="step-설정">Step 설정</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> Step <span class="title">inactiveJobStep</span><span class="params">(StepBuilderFactory stepBuilderFactory)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> stepBuilderFactory.get(<span class="string">"inactiveUserStep"</span>) <span class="comment">//(1)</span></div><div class="line">            .&lt;User, User&gt; chunk(<span class="number">10</span>) <span class="comment">//(2)</span></div><div class="line">            .reader(inactiveUserReader()) <span class="comment">//(3)</span></div><div class="line">            .processor(inactiveUserProcessor())</div><div class="line">            .writer(inactiveUserWriter())</div><div class="line">            .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>(1) <code>stepBuilderFactory.get(&quot;inactiveUserStep&quot;)</code>로 inactiveUserStep 이라는 이름의 StepBuilder를 생성합니다.</li><li>(2) 제네릭을 사용해서 <code>chunk()</code> 의 입력과 추력 타입을 User로 설정 했습니다. chunk의 인자값은 10으로 설정해서 <strong>쓰기 시에 청크 단위로 writer() 메서드를 실행시킬 단위를 지정했습니다. 즉 커밋단위가 10개입니다.</strong></li><li>(3) step의 reader, proccsor, writer를 각각 설정했습니다.</li></ul><h3><span id="reader설정">Reader설정</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@StepScope</span> <span class="comment">//(1)</span></div><div class="line"><span class="function"><span class="keyword">public</span> QueueItemReader&lt;User&gt; <span class="title">inactiveUserReader</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//(2)</span></div><div class="line">    List&lt;User&gt; oldUsers =</div><div class="line">            userRepository.findByUpdatedDateBeforeAndStatusEquals(</div><div class="line">                    LocalDateTime.now().minusYears(<span class="number">1</span>),</div><div class="line">                    UserStatus.ACTIVE);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> QueueItemReader&lt;&gt;(oldUsers); <span class="comment">//(3)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>(1) 기본 빈 생성은 싱글턴이지만 @StepScope를 사용하면 해당 메서드는 Step의 주기에 따라 새로운 빈을 생성합니다. <strong>즉, 각 Step의 실행마다 새로운 빈을 만들기 때문에 지연 생성이 가능합니다. 주의할 사항은 @StepScode는 기본 프록시 모드가 반환되는 클래스 타임을 참조하기 때문에 @StepScode를 사용하면 반드시 구현된 반환 타입을 명시해 변환해야합니다.</strong> 해당 예제는 QueueItemReader<user>라고 명시했습니다.</user></li><li>(2) <code>findByUpdatedDateBeforeAndStatusEquals()</code> 메서드를 통해서 휴먼 회원 리스트를 가져옵니다.</li><li>(3) QueueItemReader 객체를 생성하고 불러온 휴먼회원 타깃 대상을 데이터 객체에 넣어 반환합니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueItemReader</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ItemReader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> Queue&lt;T&gt; queue;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueueItemReader</span><span class="params">(List&lt;T&gt; data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedList&lt;&gt;(data); <span class="comment">//(1)</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception, UnexpectedInputException, ParseException, NonTransientResourceException </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue.poll(); <span class="comment">//(2)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>QueueItemReader는 큐를 사용해서 자장하는 ItemReader 구현체입니다. ItemReader의 기본 반환 타입은 단수형인데 그 에 따라 구현하면 User 객체 1개씩 DB에 select 요청 하므로 매우 비효율적인 방식이 될 수 있습니다.</p><ul><li>(1) QueueItemReader를 사용해서 휴면회원으로 지정될 타깃 데이터를 한번에 불러와 큐에 담아 놓습니다.</li><li>(2) reade() 메서드를 사용할 때 큐의 <code>poll()</code>메서드를 통해서 큐에서 데이터를 하나씩 반환합니다.</li></ul><h3><span id="processor-설정">Processor 설정</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ItemProcessor&lt;User, User&gt; <span class="title">inactiveUserProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> user -&gt; user.setInactive();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>읽어온 타깃 데이터를 휴먼 회원으로 전환시키는 Processor입니다. reader에서 읽은 User를 휴면 상태로 전환화는 Processor 메서드를 추가하는 예입니다.</p><h3><span id="writer-설정">Writer 설정</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ItemWriter&lt;User&gt; <span class="title">inactiveUserWriter</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((List&lt;? extends User&gt; users) -&gt; userRepository.saveAll(users));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ItemWriter는 리스트 타입을 앞서 설정한 청크 단위로 받습니다. 청크 단위를 10으로 설정했기 때문에 users에게 휴면회원 10개가 주어지며 saveAll()메서드를 통해서 한번에 DB에 저장합니다.</p><h2><span id="배치-심화">배치 심화</span></h2><ul><li>다양한 ItemReader 구현 클래스</li><li>다양한 ItemWriter 구현 클래스</li><li>JobParameter 사용하기</li><li>테스트 시에만 H2 DB를 사용 하도록 설정하기</li><li>청크 지향 프로세싱</li><li>배치 인터셉터 Listener 설정하기</li><li>어노테이션 기반 Listener 설정하기</li></ul><h3><span id="다양한-itemreader-구현-클래스">다양한 ItemReader 구현 클래스</span></h3><p>기존에는 QueueItemReader 객체를 사용 해서 모든 데이터를 한번에 와서 배치처치를 진행했습니다. <strong>하지만 수백, 수천 개 이상의 데이터를 한번에 가져와서 메모리에 올려놓게되면 좋지 않습니다.</strong> 이때 배치 프로젝트에서 제공하는 PagingItemRedaer 구현체를 사용 사용할 수있습니다. 구현체는 크게 JdbcPagingItemReader, JpaPagingItemRedaer, HibernatePagingItemRdaer가 있습니다. 해당 예쩨에서는 JpaPagingItemRedaer를 사용하겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(destroyMethod=<span class="string">""</span>) <span class="comment">//(1)</span></div><div class="line"><span class="meta">@StepScope</span></div><div class="line"><span class="function"><span class="keyword">public</span> JpaPagingItemReader&lt;User&gt; <span class="title">inactiveUserJpaReader</span><span class="params">(@Value(<span class="string">"#&#123;jobParameters[nowDate]&#125;"</span>)</span> Date nowDate) </span>&#123;</div><div class="line">    JpaPagingItemReader&lt;User&gt; jpaPagingItemReader = <span class="keyword">new</span> JpaPagingItemReader&lt;&gt;();</div><div class="line">    jpaPagingItemReader.setQueryString(<span class="string">"select u from User as u where u.createdDate &lt; :createdDate and u.status = :status"</span>); <span class="comment">//(2)</span></div><div class="line"></div><div class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    LocalDateTime now = LocalDateTime.ofInstant(nowDate.toInstant(), ZoneId.systemDefault());</div><div class="line">    map.put(<span class="string">"createdDate"</span>, now.minusYears(<span class="number">1</span>));</div><div class="line">    map.put(<span class="string">"status"</span>, UserStatus.ACTIVE);</div><div class="line"></div><div class="line">    jpaPagingItemReader.setParameterValues(map); <span class="comment">//(3)</span></div><div class="line">    jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory); <span class="comment">//(4)</span></div><div class="line">    jpaPagingItemReader.setPageSize(CHUNK_SIZE); <span class="comment">//(5)</span></div><div class="line">    <span class="keyword">return</span> jpaPagingItemReader;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>(1) 스프링에서 destroyMethod를 사용해서 삭제할 빈을 자동으로 추적합니다. destroyMethod=&quot;&quot;를 설정하면 warring 메세지를 제거할 수 있습니다.</li><li>(2) JpaPagingItemReader를 사용하면 쿼리를 직접 짜거 실행 하는 방법밖에는 없습니다.</li><li>(3) 쿼리리에서 사용된 updateDate, status 파라미터를 Mpa에 추가해서 사용할 파라미터를 설정합니다</li><li>(4 )트랜잭션을 관리해줄 entityManagerFactory를 설정합니다.</li><li>(5) 한번에 읽어올 크기를 CHUNK_SIZE 만큼 할당합니다.</li></ul><h3><span id="다양한-itemwriter-구현-클래스">다양한 ItemWriter 구현 클래스</span></h3><p>ItemReader와 마찬가지로 상황에맞는 여러 구현 클래스를 제공합니다. JPA를 사용하고 있음으로 JpaItemWriter를 적용합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> JpaItemWriter&lt;User&gt; <span class="title">inactiveUserWriter</span><span class="params">()</span> </span>&#123;</div><div class="line">    JpaItemWriter&lt;User&gt; jpaItemWriter = <span class="keyword">new</span> JpaItemWriter&lt;&gt;();</div><div class="line">    jpaItemWriter.setEntityManagerFactory(entityManagerFactory);</div><div class="line">    <span class="keyword">return</span> jpaItemWriter;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="jobparameter-사용하기">JobParameter 사용하기</span></h3><p>JobParameter를 사용해서 Step을 실행시킬 때 동적으로 파라미터를 주입시킬 수 있습니다.</p><h3><span id="테스트-시에만-h2-데이터베이스를-사용하도록-설정">테스트 시에만 H2 데이터베이스를 사용하도록 설정</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="meta">@AutoConfigureTestDatabase</span>(connection = EmbeddedDatabaseConnection.H2)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>@AutoConfigureTestDatabase(connection = EmbeddedDatabaseConnection.H2)</code> 어노테이션으로 간단하세 설정 가능합니다</p><h3><span id="청크-지향-프로세싱">청크 지향 프로세싱</span></h3><p align="center">  <img src="https://github.com/cheese10yun/TIL/raw/master/assets/chun-process.png"></p>청크 지향 프로세싱은 트랜잭션 경계 내에서 청크 단위로 데이터를 읽고 생성하는 프로그래밍 기법입니다. 청크란 아이템이 트랜잭션에 커밋되는 수를 말합니다. read한 데이터 수가 지정한 청크 단위와 칠치하면 write를 수행하고 트랜잭션을 커밋합니다. Step 설정에서 chunk()로 커밋 단위를 지정했던 부분입니다. 즉 기존에도 계속 사용해온 방법이 청크 지향 프로세싱입니다.<p>청크 지향프러그래밍의 이점은 1000개 개의 데이터에 대해 배치 로직을 실행한다고 가정했을 때 청크로 나누지 않았을 때는 하나만 실패해도 다른 성공한 999개의 데이터가 롤백됩니다. 그런데 청크 단위를 10으로 해서 배치처리를 하면 도중에 배치 처리에 실패하더라도 다른 청크는 영향을 받지 않습니다. 이러한 이유로 스프링 배치에 정크 단위로 프로그래밍을 지향합니다.</p><h3><span id="배치-인터셉터-listener-설정하기">배치 인터셉터 Listener 설정하기</span></h3><p>배치 흐름에서 전후 처리를 하는 Listener를 설정할 수 있습니다. 구체적으로 Job의 전후 처리 Step의 전후 처리 각 청크 단위의 전후 처리 등 세세한 과정 실행시 특정 로직을 할당해 제어할 수있습니다. 가장 대표적인 예로는 로깅 작업이 있습니다.</p><h3><span id="어노테이션-기반-listener-설정하기">어노테이션 기반 Listener 설정하기</span></h3><p>배치 인터셉터 인터페이스를 활용해서 사용하는 방법도 있고 에노테이션을 사용해서 활용하는 방법도 있습니다. 대표적으로 <code>@BefroeStep, @AsfterStep</code> 등이 있습니다. 해당 어노테이션으로 시작 전후에 로그를 남기는 설정도 가능합니다.</p><h3><span id="jobparameter-사용하기">JobParameter 사용하기</span></h3><p>JapParameter를 사용해 Step을 실행시킬 때 동적으로 파라미터를 주입시클 수 있습니다.</p><h3><span id="step의-흐름을-제어하는-flow">Step의 흐름을 제어하는 Flow</span></h3><p>Step의 가장 기본적은 흐름은 <code>읽기-처리-쓰기</code> 입니다. 여기서 세부적인 조건에 따라서 Step의 실행 여부를 정할 수 있습니다. 이런 흐름을 제어하는 <code>Flow</code> 제공 합니다.</p><p align="center">  <img src="https://github.com/cheese10yun/TIL/raw/master/assets/batch-flow.png"></p><p>흐름에 조건에 해당하는 부분을 <code>JobExecutionDecider</code> 인터페이스를 사용해 구현 할 수 있습니다. <code>JobExecutionDecider</code> 인터페이스는 <code>decide()</code> 메서드 하나만 제공합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobExecutionDecider</span> </span>&#123;</div><div class="line">    <span class="function">FlowExecutionStatus <span class="title">decide</span><span class="params">(JobExecution jobExecution, @Nullable StepExecution stepExecution)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> Class xxxJobExecutionDecider implements  JobExecutionDecider &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> FlowExecutionStatus <span class="title">decide</span><span class="params">(JobExecution jobExecution, @Nullable StepExecution stepExecution)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(특정 조건...)&#123; <span class="comment">// (1)</span></div><div class="line">            <span class="keyword">return</span> FlowExecutionsStatus.COMPLETED; <span class="comment">// (2)</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> FlowExecutionsStatus.FAILED; <span class="comment">// (3)</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>(1) 특정 조건에 대한 로직</li><li>(2) 조건에 만족하고 JobStep을 실행 시킬 경우 <code>COMPLETED</code> 리턴</li><li>(3) 조건에 만족하지 않고 JobStep을 <strong>실행 하지않을 경우</strong>  <code>FAILED</code> 리턴</li></ul><p><code>Flow</code> 조건으로 사용될 경우 InactiveJobExceutionDecider 클래스를 구현 했습니다. 이를 사용할 Flow를 구현 해야합니다. <code>Step</code> 메서드가아닌 <code>Flow</code>를 주압 받고 주입받은 <code>Flow</code>를 빈으로 등록해야합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> Flow <span class="title">xxxJobFlow</span><span class="params">(Step xxxJobStep)</span></span>&#123;</div><div class="line">    FlowBuilder&lt;Flow&gt; flowBuilder = <span class="keyword">new</span> FlowBuilder&lt;&gt;(<span class="string">"xxxJobFlow"</span>); <span class="comment">// (1)</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> flowBuilder</div><div class="line">        .start(<span class="keyword">new</span> xxxJobExcetuinDeicder()) <span class="comment">// (2)</span></div><div class="line">        .on(FlowExecutionStatus.FAILED.getName()).end() <span class="comment">// (3)</span></div><div class="line">        .on(FlowExecutionStatus.COMPLETED.getName()).to(xxxJobStep).end(); <span class="comment">// (4)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>(1) <code>FlowBuilder</code>를 시용해서 Flow 객체를 생성합니다.</li><li>(2) 위에서 작성한 <code>xxxJobExecutionDecider</code> 클래스를 <code>start()</code> 으로 설정해 맨 처음 시작하도록 합니다.</li><li>(3) <code>xxxJobExecutionDecider</code> 클래스의 decide() 메서드를 통해 리턴 값이 <code>FAILED</code> 일 경우 <code>end()</code> 메서드를 사용해서 끝나도록 설정합니다.</li><li>(4) <code>xxxJobExecutionDecider</code> 클래스의 decide() 메서드를 통해 리턴 값이 <code>COMPLETED</code> 일 경우 기존에 설정한 <code>xxxJobStep</code>을 실행하도록 설정합니다.</li></ul><h2><span id="재시도">재시도</span></h2><p>네트워크 접속이 끊어지거나 장비가 다운되는 등 실패 시나리오는 다양합니다. 시스템은 언젠가 복구 될테니 다시 한번 시도는 해볼 가치는 있습니다.</p><h3><span id="스템-구성하기">스템 구성하기</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> Step <span class="title">step1</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> steps.get(<span class="string">"user xxxxx"</span>)</div><div class="line">    .&lt;User, User&gt;chunk(<span class="number">10</span>)</div><div class="line">        .faulTolerant()</div><div class="line">            .retryLimit(<span class="number">3</span>).retry(XXXXXException.class)</div><div class="line">    .render(something())</div><div class="line">    .writer(something())</div><div class="line">    .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>자바 구성으로 재시도를 활성화 할 경우, 첫 번째 스텝은 오류를 허용하도록 만들어야 재시도 제한 횟수 및 재시도 대상 예외를 지정할 수 있습니다. 먼저 <code>faulTolerant()</code>로 오류 허용 스탭을 얻은후, <code>retryLimit()</code> 메서드로 재시도 제한 횟수를, <code>retry()</code> 메서드로 재시도 대상 예외를 발생합니다.</p><h3><span id="재시도-템플릿">재시도 템플릿</span></h3><ul><li>스프링 배치가 제공하는 재시도 및 복구 서비스를 코드에 활용하는 다른 방법도 있습니다. 재시도 로직을 구현된 커스텀 ItemWriter<t>를 작성하거나 아예 전체 서비스 인터페이스에 재시도 기능을 입힐 수 있습니다.</t></li><li>스프링 배치 RetryTemplate은 바로 이런 용도로 만들어진 클래스입니다. 비니지스 로직과 재시도 로직을 분리해서 마치 재시도 없이 한 번만 시도하는 것처럼 코드를 작성할 수 있개 해줍니다.</li><li>재시도 -&gt; 실패 -&gt; 복구 반복적인 과정을 간명한 하나의 API 메서드로 호출로 감싼 <code>RetryTemplate</code>는 여러 가지 유스 케이스를 지원합니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryableUserRegistrationServiceItemWriter</span> <span class="keyword">implements</span> <span class="title">ItemWriter</span>&lt;<span class="title">UserRegistration</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RetryableUserRegistrationServiceItemWriter.class);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRegistrationService userRegistrationService;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RetryTemplate retryTemplate;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetryableUserRegistrationServiceItemWriter</span><span class="params">(UserRegistrationService userRegistrationService, RetryTemplate retryTemplate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.userRegistrationService = userRegistrationService;</div><div class="line">        <span class="keyword">this</span>.retryTemplate = retryTemplate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * takes aggregated input from the reader and 'writes' them using a custom implementation.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(List&lt;?extends UserRegistration&gt; items)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> UserRegistration userRegistration : items) &#123;</div><div class="line">            UserRegistration registeredUserRegistration = retryTemplate.execute(</div><div class="line">                    (RetryCallback&lt;UserRegistration, Exception&gt;) context -&gt; userRegistrationService.registerUser(userRegistration));</div><div class="line"></div><div class="line">            logger.debug(<span class="string">"Registered: &#123;&#125;"</span>, registeredUserRegistration);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  ....</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> RetryTemplate <span class="title">retryTemplate</span><span class="params">()</span> </span>&#123;</div><div class="line">        RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplate();</div><div class="line">        retryTemplate.setBackOffPolicy(backOffPolicy());</div><div class="line">        <span class="keyword">return</span> retryTemplate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ExponentialBackOffPolicy <span class="title">backOffPolicy</span><span class="params">()</span> </span>&#123;</div><div class="line">        ExponentialBackOffPolicy backOffPolicy = <span class="keyword">new</span> ExponentialBackOffPolicy();</div><div class="line">        backOffPolicy.setInitialInterval(<span class="number">1000</span>);</div><div class="line">        backOffPolicy.setMaxInterval(<span class="number">10000</span>);</div><div class="line">        backOffPolicy.setMultiplier(<span class="number">2</span>);</div><div class="line">        <span class="keyword">return</span> backOffPolicy;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><ul><li>재시도 시간 간격을 정하는 BackOffplicy는 RetryTemplate의 유용한 기능입니다. 실제로 실패 직후 재시도하는 시간 간격을 점점 늘려 여러 클라이언트가 같은 호출 할때 스텝이 잠기지 않도록 예방하는 수단으로 활용할 수있습니다.</li></ul><h3><span id="aop-기반-재시도">AOP 기반 재시도</span></h3><p>스프링 배치가 제공하는 AOP 어드바이저를 이용해서 RetryTempate 처럼 사용할 수 있습니다. 프록시 전체에 재시 로직 어드바이스를 추가하면 RetryTempate이 빠진 본래 코드로 그대로 사용가능합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retryable</span>(backoff = <span class="meta">@Backoff</span>(delay = <span class="number">1000</span>, maxDely = <span class="number">10000</span>, multiplier = <span class="number">2</span>))</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">batchSomething</span><span class="params">()</span></span>&#123;....&#125;</div></pre></td></tr></table></figure><p><strong>구성 클래스에 반드시 @EnableRety 를추가 해야합니다.</strong></p><h2><span id="spring-batch-table">Spring Batch Table</span></h2><p align="center">  <img src="https://github.com/cheese10yun/TIL/raw/master/assets/meta-data-erd.png"></p><h3><span id="batch_job_instance">BATCH_JOB_INSTANCE</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`BATCH_JOB_INSTANCE`</span> (</div><div class="line">  <span class="string">`JOB_INSTANCE_ID`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`VERSION`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`JOB_NAME`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`JOB_KEY`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`JOB_INSTANCE_ID`</span>),</div><div class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`JOB_INST_UN`</span> (<span class="string">`JOB_NAME`</span>,<span class="string">`JOB_KEY`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</div></pre></td></tr></table></figure><ul><li>JOB_INSTANCE_ID<ul><li>BATCH_JOB_INSTANCE 테이블의 PK</li></ul></li><li>JOB_NAME<ul><li>수행한 Batch Job Name</li></ul></li></ul><p><strong>BATCH_JOB_INSTANCE 테이블은 Job Parameter에 따라 생성됩니다.</strong></p><p>Job Parameter는 Spring Batch가 실행될때 외부에서 받을 수 있는 파라미터 입니다.</p><p><strong>같은 Batch Job 이라도 Job Parameter가 다르면 다른 BATCH_JOB_INSTANCE 에 기록됩니다.</strong></p><h3><span id="batch_job_execution">BATCH_JOB_EXECUTION</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`BATCH_STEP_EXECUTION`</span> (</div><div class="line">  <span class="string">`STEP_EXECUTION_ID`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`VERSION`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`STEP_NAME`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`JOB_EXECUTION_ID`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`START_TIME`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`END_TIME`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`STATUS`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`COMMIT_COUNT`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`READ_COUNT`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`FILTER_COUNT`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`WRITE_COUNT`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`READ_SKIP_COUNT`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`WRITE_SKIP_COUNT`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`PROCESS_SKIP_COUNT`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`ROLLBACK_COUNT`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`EXIT_CODE`</span> <span class="built_in">varchar</span>(<span class="number">2500</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`EXIT_MESSAGE`</span> <span class="built_in">varchar</span>(<span class="number">2500</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`LAST_UPDATED`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`STEP_EXECUTION_ID`</span>),</div><div class="line">  <span class="keyword">KEY</span> <span class="string">`JOB_EXEC_STEP_FK`</span> (<span class="string">`JOB_EXECUTION_ID`</span>),</div><div class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`JOB_EXEC_STEP_FK`</span> FOREIGN <span class="keyword">KEY</span> (<span class="string">`JOB_EXECUTION_ID`</span>) <span class="keyword">REFERENCES</span> <span class="string">`BATCH_JOB_EXECUTION`</span> (<span class="string">`JOB_EXECUTION_ID`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</div></pre></td></tr></table></figure><ul><li><code>JOB_EXECUTION_ID</code> 칼럼은 <code>BATCH_JOB_INSTANCE</code> 테이블의 PK를 참조 하고 있습니다.</li><li><code>BATCH_STEP_EXECUTION</code> 와 <code>BATCH_JOB_INSTANCE</code>는 부모 자식관계입니다.</li><li>BATCH_STEP_EXECUTION는 자신의 부모 BATCH_JOB_INSTANCE 성공/실패 내역을 모두 갖고 있습니다.</li><li></li></ul><p align="center">  <img src="https://github.com/cheese10yun/TIL/raw/master/assets/job-job-instance-job-execution.png"></p><ul><li><code>Job</code>: 특정 잡, 2달이상 로그인안한 유저 휴먼 회원 처리 등</li><li><code>Job Instance</code>: Job Parameter를 실행한 Job(Job Parameter 단위로 생성)</li><li><code>Job Execution</code>: Job Parameter로 실행한 Job의 실행, 1번 째 시도 혹은 그 다음 등</li></ul><h2><span id="참고">참고</span></h2><ul><li><a href="https://kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;barcode=9791162241264&amp;orderClick=JAj" rel="external nofollow noopener noreferrer" target="_blank">처음으로 배우는 스프링 부트 2</a>를 정리한 글입니다.</li><li><a href="https://github.com/jojoldu/spring-batch-in-action/blob/master/3_%EB%A9%94%ED%83%80%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%BF%EB%B3%B4%EA%B8%B0.md" rel="external nofollow noopener noreferrer" target="_blank">기억보단 기록을 - spring-batch-in-action</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;스프링 배치는 벡엔드의 배치처리 기능을 구현하는 데 사용하는 프레임워크입니다. 스프링 부트 배치는 스프링 배치 설정 요소들을 간편화시켜 스프링 배치를 빠르게 설정하는 데 도움을 줍니다. &lt;strong&gt;해당 코드는 &lt;a href=&quot;https://g
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="Batch" scheme="https://cheese10yun.github.io/tags/Batch/"/>
    
  </entry>
  
  <entry>
    <title>Spring 예제로 보는 SOLID SRP</title>
    <link href="https://cheese10yun.github.io/spring-solid-srp/"/>
    <id>https://cheese10yun.github.io/spring-solid-srp/</id>
    <published>2018-11-19T12:26:00.000Z</published>
    <updated>2018-11-19T12:29:09.724Z</updated>
    
    <content type="html"><![CDATA[<p><strong>해당 코드는 <a href="https://github.com/cheese10yun/spring-SOLID" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인해주세요.</strong></p><h1><span id="단일-책임의-원칙-single-responsibility-principle">단일 책임의 원칙: Single Responsibility Principle</span></h1><p>단일 책임의 원칙: Single Responsibility Principle 핵심 키워드는 다음과 같습니다. 해당 키워드를 기반으로 세부적으로 설명하겠습니다.</p><ul><li>클래스는 단 한 개의 책임을 가져야 한다.</li><li>클래스의 변경하는 이유는 단 한 개여야 한다.</li><li>누가 해당 메소드의 변경을 유발하는 사용자(Actor) 인가?</li></ul><p>사실 단임 책임의 원칙이라는 것은 정말 이해하기 어렵습니다. 우선 명확한 책임을 도출하기까지 시간이 걸리기 때문에 처음부터 단일 책임을 지켜서 설계하는 것은 매우 힘들다고 생각합니다. 또 요구사항이 변경 시에 책임 또한 변경되게 됩니다. 그러니 지속해서 한 클래스가 한 책임만을 갖게 하기는 매우 어렵다고 생각합니다.</p><p><strong>다른 SOLID 원칙 정리 한글 보다 제 개인적인 생각이 많이 들어간 설명이라서 최대한 비판적인 시각으로 봐주시면 감사하겠습니다.</strong></p><h2><span id="요구사항">요구사항</span></h2><ul><li>카드 결제 시스템이 있다.</li><li>현재 국내 결제를 지원하는 카드는 신한, 우리 카드가 있다.</li><li>국내 결제 카드사들은 지속해서 추가된다.</li><li>앞으로 해외 결제 기능이 추가된다.<ul><li><strong>신한 카드는 해외 결제가 가능하다.</strong></li><li><strong>우리 카드는 해외 결제가 불가능하다.</strong></li><li>지속해서 카드사가 추가된다.</li></ul></li></ul><h2><span id="기존-국내-카드-결제의-srp">기존 국내 카드 결제의 SRP</span></h2><p align="center">    <img src="https://i.imgur.com/TdGYl8n.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CardPaymentService</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">(CardPaymentDto.PaymentRequest req)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShinhanCardPaymentService</span> <span class="keyword">implements</span> <span class="title">CardPaymentService</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(CardPaymentDto.PaymentRequest req)</span> </span>&#123;</div><div class="line">        <span class="comment">// .. 신한 카드 국내 결제 로직..</span></div><div class="line">        shinhanCardApi.pay(paymentRequest);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WooriCardPaymentService</span> <span class="keyword">implements</span> <span class="title">CardPaymentService</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(CardPaymentDto.PaymentRequest req)</span> </span>&#123;</div><div class="line">        <span class="comment">// .. 우리 카드 국내 결제 로직..</span></div><div class="line">        wooriCardApi.pay(paymentRequest);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>위의 UML, 인터페이스가 이해가 어렵다면 이전 포스팅 <a href="https://github.com/cheese10yun/spring-SOLID/blob/master/docs/OCP.md" rel="external nofollow noopener noreferrer" target="_blank">OCP</a>, <a href="https://github.com/cheese10yun/spring-SOLID/blob/master/docs/DIP.md" rel="external nofollow noopener noreferrer" target="_blank">DIP</a>를 먼저 보시는 것을 권장합니다.</strong></p><ul><li>클래스의 책임 : <strong>해당 카드사의 결제 API를 호출하기 위한 적절한 값을 생성해서 호출하는 것</strong></li><li>변경의 근원 : 카드 결제를 하는 Actor</li><li>Actor : 카드결제를 행하는 <strong>행위자</strong></li></ul><p>지금 부터는 제 지극적인 주관적인 생각입니다.</p><p>클래스의 변경은 단 한 개여야 한다. <strong>라는 말은 그 클래스의 책임을 수행시키는 Actor의 변경 시에만 클래스의 변경이 가해져야 한다고 저는 해석 했습니다.</strong></p><p>만약 Actor가 결제 완료 시간 등 결제 정보를 받기를 원하게 된다면 <code>pay</code> 메서드의 리턴 타입이 변경이 발생합니다. 즉 카드 결제의 변경은 Actor의 변경에서부터 발생하게 됩니다.</p><p><strong>여기서 Actor를 단순히 사용자로 바라보면 안 되고 Actor는 그 행위(국내 결제)를 하는 행위자로 봐야 한다고 생각합니다. 그리고 단일 책임이라는 것은 단일 Actor를 뜻한다고 생각합니다.</strong> 이 부분은 아래에서 추가로 설명하겠습니다.</p><h2><span id="추가될-해외-카드-결제의-srp미준수">추가될 해외 카드 결제의 SRP(미준수)</span></h2><p><img src="https://i.imgur.com/DyLl9Fh.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CardPaymentService</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">(CardPaymentDto.PaymentRequest req)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">payOverseas</span><span class="params">(CardPaymentDto.PaymentRequest req)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShinhanCardPaymentService</span> <span class="keyword">implements</span> <span class="title">CardPaymentService</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOverseas</span><span class="params">(CardPaymentDto.PaymentRequest req)</span> </span>&#123;</div><div class="line">        <span class="comment">// .. 신한 카드 해외 결제 로직..</span></div><div class="line">        shinhanCardApi.pay(paymentRequest);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WooriCardPaymentService</span> <span class="keyword">implements</span> <span class="title">CardPaymentService</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOverseas</span><span class="params">(CardPaymentDto.PaymentRequest req)</span> </span>&#123;</div><div class="line">        <span class="comment">// 우리 카드 결제는 해외 결제 기능이 없음...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>신한 카드는 해외 결제를 할 수 있지만 우리 카드는 해외 결제 기능을 제공하고 있지 않습니다.</strong> 각 구현 클래스들은 CardPaymentService 인터페이스를 구현하고 있으므로 payOverseas 기능이 추가되면 우리 카드 결제는 반드시 해당 메서드를 구현 해야 합니다.</p><p><strong>해외 결제만 되고 국내 결제가 안 되는 카드 파트너가 추가되면 어떻게 될까요?</strong> 그렇게 되면 위와 반대로 payOverseas 구현 메소드는 구현하고 pay는 구현하지 못하게 됩니다.</p><p>다시 SRP로 넘어가서</p><h3><span id="책임이란-변화에-대한-것">책임이란 변화에 대한 것</span></h3><p>국내 결제에서 해외 결제라는 책임이 하나 더 생긴 것입니다. 그렇게 두 개의 책임이 생겼고 그 결과 두 개의 Actor가 생긴 것이라고 생각합니다. (위에서 언급한 단일 책임 = 단일 Actor) 이로써 클래스의 책임을 나누는 작업이 필요해집니다.</p><p><strong>하지만 여기서 정말 중요한 것은 만약 우리카드가 해외 결제를 제공하고, 추가 파트너들도 해외 결제를 제공한다면 ?</strong></p><p>그렇다면 국내, 해외 결제를 할 수 있는 Actor는 한 개가 됩니다. Actor가 하나라는 것은 책임이 하나라는 뜻도 됩니다. 이런 경우 단일 책임의 원칙을 지켰다고 저는 개인적으로 생각합니다.</p><p>하지만 우리는 파트너사들이 어떤 기능을 제공할지, 또 어떤 파트너사들이 추가될지, 어떻게 변경될지 이런 부분들을 예측하기가 어려우므로 SRP를 지속적으로 준수하는 것은 정말 어렵다고 생각합니다.</p><h2><span id="추가될-해외-카드-결제의-srp준수">추가될 해외 카드 결제의 SRP(준수)</span></h2><p><img src="https://i.imgur.com/1vc5En5.png" alt=""></p><p>카드 파트너사의 해외 결제 여부로 더이상 PaymentService에서 국내 결제와, 해외 결제를 처리를 못하게 되었습니다. 그렇다면 책임을 분리시키고 그것을 인터페이스로 바라보게 하여 앞으로 해외 결제 카드추가시 확장에 열려있게 할 수 있습니다.</p><h2><span id="결론">결론</span></h2><p>SOLID에서 가장 이해하기 어려운 개념이 SRP라고 생각합니다. 관련자료도 읽어봐도 명확한 이해가 어려워서 저 나름의 결론을 정리한 글입니다. 때문에 다른 원칙에 비해서 제 주관적인 해석들이 많아 잘못된 부분도 있을 수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/spring-SOLID&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Github&lt;/
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="SOLID" scheme="https://cheese10yun.github.io/tags/SOLID/"/>
    
      <category term="SRP" scheme="https://cheese10yun.github.io/tags/SRP/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security CSRF 설정</title>
    <link href="https://cheese10yun.github.io/spring-csrf/"/>
    <id>https://cheese10yun.github.io/spring-csrf/</id>
    <published>2018-10-27T06:00:00.000Z</published>
    <updated>2018-10-27T06:03:39.887Z</updated>
    
    <content type="html"><![CDATA[<p><strong>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/sample-csrf" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>에 공개되어 있습니다.</strong></p><h2><span id="csrf-란">CSRF 란 ?</span></h2><p>CSRF(Cross site request forgery)란 웹 사이트의 취약점을 이용하여 이용자가 의도하지 하지 않은 요청을 통한 공격을 의미합니다. http 통신의 Stateless 특성을 이용하여 쿠키 정보만 이용해서 사용자가 의도하지 않은 다양한 공격들을 시도할 수 있습니다. 해당 웹 사이트에 로그인한 상태로 <a href="https://xxxx.com/logout" rel="external nofollow noopener noreferrer" target="_blank">https://xxxx.com/logout</a> URL을 호출하게 유도하면 실제 사용자는 의도하지 않은 로그아웃을 요청하게 됩니다. 실제로 로그아웃뿐만 아니라 다른 웹 호출도 가능하게 되기 때문에 보안상 위험합니다.</p><p>가장 간단한 해결책으로는 CSRF Token 정보를 Header 정보에 포함하여 서버 요청을 시도하는 것입니다. 스프링 시큐리티는 이러한 설정은 편리하게 설정할 수 있습니다.</p><p>물론 CSRF Token 정보를 함께 로그아웃 요청을 해야 안전하지만, 로그아웃 컨트롤러를 GET보다는 POST로 변경 하는 것도 보안상 바람직하다고 생각합니다.</p><h2><span id="security-설정">Security 설정</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EnableWebSecurity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//@formatter:off</span></div><div class="line">        http</div><div class="line">                .authorizeRequests()</div><div class="line">                    .antMatchers(<span class="string">"/"</span>).permitAll()</div><div class="line">                    .anyRequest().denyAll()</div><div class="line">                .and()</div><div class="line">                .csrf()</div><div class="line">                    .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())</div><div class="line">                .and()</div><div class="line">        ;</div><div class="line">        <span class="comment">//@formatter:on</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="sample-controller">Sample Controller</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleGet</span><span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">samplePost</span><span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>간단한 컨트롤러입니다. GET, POST 설정으로 CSRF 테스틀 진행하겠습니다.</p><h2><span id="cors-테스트">CORS 테스트</span></h2><h3><span id="get-httplocalhost8080-호출">[GET]  호출</span></h3><p>간단한 Rest Controller 입니다. 만약 <code>.csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())</code> 코드를 주석 하고 <a href="http://localhost:8080" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080</a> 해당 API를 호출하면 아래와 같이 쿠키 정보를 주지 않습니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/assets/non-cookie.png" alt="non-cookie"></p><p>위의 주석을 다시 해제하고 <a href="http://localhost:8080" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080</a>를 호출하면 아래와 같이 쿠키 정보를 받을 수 있습니다. 기본적으로 GET 방식은 CSRF Token 정보를 넘기지 않아도 상관없습니다.<br><img src="https://github.com/cheese10yun/blog-sample/raw/master/assets/cookie.png" alt="cookie"></p><h3><span id="post-httplocalhost8080-호출">[POST]  호출</span></h3><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/assets/cookie-post.png" alt="cookie-post"></p><p>쿠키로 받은 값을 Header에 실어서 POST 호출을 시도하면 <code>Http Status Code 200</code>을 넘겨 받은 것을 확인 할 수 있습니다.</p><p>이때 주의할 점은 Header Key 값은 <code>X-XSRF-TOKEN</code> 입니다. 발급받은 쿠키의 Key 값은 <code>XSRF-TOKEN</code>으로 차이가 있습니다. 자세한 내용은 <code>CookieCsrfTokenRepository.class</code> 에서 살펴보겠습니다.</p><p>만약 중간에 토큰 값을 변조하거나 토큰값을 넘기지 않으면 <code>Http Status Code403 Forbidden</code>을 넘겨받습니다.</p><h3><span id="cookiecsrftokenrepository">CookieCsrfTokenRepository</span></h3><p><code>csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())</code> CSRF Token Repository에 넘겨준 객체가 CookieCsrfTokenRepository 객체입니다. <code>withHttpOnlyFalse()</code> Static Factory 메서드로 해당 객체를 생성하고 있습니다.</p><p align="center">  <img src="https://github.com/cheese10yun/blog-sample/raw/master/assets/CookieCsrfTokenRepository-factory.png"></p><p>실제 코드는 위와 같습니다. 메서드 이름에서도 표현되듯이 HttpOnly 설정이 false로 되어 있습니다. 이처럼 Static Factory 메서드는 캡슐화 가독성 측면에서 좋은 점이 있다고 생각합니다.</p><p align="center">  <img src="https://github.com/cheese10yun/blog-sample/raw/master/assets/CSRF-Meber-filed.png"></p><p><code>DEFAULT_CSRF_COOKIE_NAME</code> 변수에 <code>XSRF-TOKEN</code> 값을 할당 하고 있습니다. 그래서 쿠키의 KEY 값이 <code>XSRF-TOKEN</code> 으로 나가게됩니다. <code>DEFAULT_CSRF_HEADER_NAME</code>도 마찬가지입니다. 그래서 Header Key 값을 <code>X-XSRF-TOKEN</code>으로 넘겨줬어야 합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/sample-csrf&quot; rel=&quot;external nofollow noopener noreferrer&quot; t
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="Security" scheme="https://cheese10yun.github.io/tags/Security/"/>
    
      <category term="CSRF" scheme="https://cheese10yun.github.io/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>Spring REST Docs</title>
    <link href="https://cheese10yun.github.io/spring-rest-docs/"/>
    <id>https://cheese10yun.github.io/spring-rest-docs/</id>
    <published>2018-10-26T15:00:00.000Z</published>
    <updated>2018-10-26T16:45:12.496Z</updated>
    
    <content type="html"><![CDATA[<p><strong>코드는 <a href="https://github.com/cheese10yun/springboot-restdocs#test-code-%EC%84%A4%EC%A0%95" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>에 공개 되어 있습니다.</strong></p><h2><span id="rest-docs-소개">REST Docs 소개</span></h2><p>Spring REST Docs는 테스트 코드 기반으로 RESTful 문서생성을 돕는 도구로 기본적으로 Asciidoctor를 사용하여 HTML를 생성합니다. Spring MVC 테스트 프레임워크로 생성된 snippet을 사용해서 snippet이 올바르지 않으면 생성된 테스트가 실패하여 정확성을 보장해줍니다.</p><h2><span id="rest-docs-vs-swagger">Rest Docs vs Swagger</span></h2><p>우선 Rest Docs과 Swagger는 성격이 많이 다르다고 생각합니다. Swagger는 RESTful 문서에 대한 명세 보다는 Postman Tool 처럼 특정 API를 쉽게 호출해볼수 있는 것에 초점이 맞춰져있다고 생각합니다. 다시 말해 Swagger는 API 명세에 대한 기능은 어느정도 제공해주지만 그것은 효율적이지 못하다고 생각합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"View a list of available products"</span>, response = Iterable.class)</div><div class="line"><span class="meta">@ApiResponses</span>(value = &#123;</div><div class="line">        <span class="meta">@ApiResponse</span>(code = <span class="number">200</span>, message = <span class="string">"Successfully retrieved list"</span>),</div><div class="line">        <span class="meta">@ApiResponse</span>(code = <span class="number">401</span>, message = <span class="string">"You are not authorized to view the resource"</span>),</div><div class="line">        <span class="meta">@ApiResponse</span>(code = <span class="number">403</span>, message = <span class="string">"Accessing the resource you were trying to reach is forbidden"</span>),</div><div class="line">        <span class="meta">@ApiResponse</span>(code = <span class="number">404</span>, message = <span class="string">"The resource you were trying to reach is not found"</span>)</div><div class="line">&#125;</div><div class="line">)</div><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/list"</span>, method= RequestMethod.GET, produces = <span class="string">"application/json"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Iterable <span class="title">list</span><span class="params">(Model model)</span></span>&#123;</div><div class="line">    Iterable productList = productService.listAllProducts();</div><div class="line">    <span class="keyword">return</span> productList;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><a href="https://springframework.guru/spring-boot-restful-api-documentation-with-swagger-2/" rel="external nofollow noopener noreferrer" target="_blank">코드 출처</a></li></ul><p>Swagger는 RESTful에대한 문서명세를 위와같은 어노테이션 방법으로 제공해줍니다. 이런 방법은 다음과 같은 단점이 있다고 생각합니다.</p><ul><li>실제 코드에 영향을 미치지 않지만 지속해서 추가됨으로써 실제 코드보다 문서 명세에 대한 코드가 더 길어져 전체적인 가독성이 떨어집니다.</li><li><strong>해당 코드는 주석일뿐 로직에 영향을 미치지 않기 때문에 비즈니스 로직이 변경되더라도 문서를 갱신하지 않아 결국 문서와 코드가 일치하지 않게 됩니다.</strong></li><li><strong>정상적인 Reponse에 대한 명세 일뿐 status 2xx 이외의 값에 대한 정의가 힘듭니다. 이것을 정의하더라도 주석 형태로 정의하게 되어 결국 시간이 지나면 문서와 코드가 일치하지 않게 됩니다.</strong></li></ul><p>제 개인적인 결론은 RESTful API에 대한 명세관점에서는 둘은 비교 대상이 되기 힘들다고 생각합니다. <strong>Rest Docs는 테스트 코드 기반으로 문서가 작성되기 때문에 문서와 실제 코드의 일치성이 높고 테스트코드로 문서가 표현되기 때문에 실제 코드에 어떠한 코드 추가도 필요가 없다는 장점이 크다고 생각합니다.</strong> Swaager이외에도 실제 자바 주석문으로 RESTful API를 명세하는 서비스도 있지만 결국 문서와 코드의 일치성 등 다양항문제로 현재로써는 Rest Docs가 가장 효율적인 RESTful API 명세 도구라고 생각합니다.</p><h2><span id="pomxml-설정">pom.xml 설정</span></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    ...</div><div class="line">    <span class="comment">&lt;!-- (1) --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.restdocs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-restdocs-mockmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- (2) --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.asciidoctor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>asciidoctor-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>generate-docs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>prepare-package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>process-asciidoc<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">backend</span>&gt;</span>html<span class="tag">&lt;/<span class="name">backend</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">doctype</span>&gt;</span>book<span class="tag">&lt;/<span class="name">doctype</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- (3) --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.restdocs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-restdocs-asciidoctor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- (4) --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>prepare-package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span></div><div class="line">                        $&#123;project.build.outputDirectory&#125;/static/docs</div><div class="line">                    <span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">directory</span>&gt;</span></div><div class="line">                                $&#123;project.build.directory&#125;/generated-docs</div><div class="line">                            <span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>(1) <code>restdocs</code> 의존성을 추가합니다. <code>scope</code>는 test로 지정합니다.</li><li>(2) <code>asciidoctor</code> 플러그인을 추가합니다.</li><li>(3) <code>spring-restdocs-asciidoctor</code> 의존성을 추가합니다. 해당 의존성이 추가되면 <code>snippets</code> 이 자동으로 구성됩니다.</li><li>(4) <code>Asciidoctor</code> 플러그인 설정 입니다.<ul><li><code>outputDirectory</code> 문서가 출력되는 디렉토리 경로 입니다. 실제 <code>/target/classes/static/docs/</code> 경로에 문서가 생셩됩니다.</li></ul></li></ul><h2><span id="test-code">Test Code</span></h2><h3><span id="test-code-설정">Test Code 설정</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberControllerTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Rule</span> <span class="keyword">public</span> JUnitRestDocumentation restDocumentation = <span class="keyword">new</span> JUnitRestDocumentation(); <span class="comment">// (1)</span></div><div class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> WebApplicationContext context;</div><div class="line">    <span class="keyword">private</span> MockMvc mockMvc; <span class="comment">// (2)</span></div><div class="line">    <span class="keyword">private</span> RestDocumentationResultHandler document;</div><div class="line"></div><div class="line">    <span class="comment">// (3)</span></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.document = document(</div><div class="line">                <span class="string">"&#123;class-name&#125;/&#123;method-name&#125;"</span>, </div><div class="line">                preprocessResponse(prettyPrint())</div><div class="line">        );</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(<span class="keyword">this</span>.context)</div><div class="line">                .apply(documentationConfiguration(<span class="keyword">this</span>.restDocumentation))</div><div class="line">                .alwaysDo(document)</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>(1) Spring Rest Docs는 <code>JUnit</code> <code>TestNG</code> 등 다양한 테스트 프레임워크를 지원합니다. 본 예제는 <code>JUnit</code> 기반으로 테스트를 진행 하기 때문에 <code>JUnitRestDocumentation</code> 객체를 생성했습니다.</li><li>(2) <code>MockMvc</code>, <code>WebTestClient</code>, <code>Rest Assured</code> 등 다양한 방식으로 Controller에 대한 테스트를 진행 할 수 있습니다. 본 예제는 <code>MockMvc</code> 기반으로 Controller 테스트를 진행하겠습니다.</li><li>(3) <code>RestDocumentationResultHandler</code> 객체와 <code>MockMvc</code> 객체를 생성합니다.<ul><li><code>{class-name}/{method-name}</code> 설정은 해당 테스트 클래스의 이름 메서드 이름 기반으로 디렉토리 경로를 설정해서  <code>snippets</code>을 생성합니다. <code>target/generated-snippets/member-controller-test/get_member</code>에 저장됩니다.</li><li><code>preprocessResponse(prettyPrint()</code> 설정을 통해서 해당 문서가 이쁘게 출력됩니다. 예를들어 JSON Response 값이 JSON 포멧팅에 맞게 출력됩니다.</li><li><code>alwaysDo()</code> 메서드로 위에서 생성된 <code>RestDocumentationResultHandler</code> 객체를 의존성 주입해줍니다. 모든 <code>mockMvc</code> 테스트에 대한 <code>snippets</code>이 생성됩니다.</li></ul></li></ul><h3><span id="member-조회-test-code">Member 조회 Test Code</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberControllerTest</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_member</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        mockMvc.perform(get(<span class="string">"/members/&#123;id&#125;"</span>, <span class="number">1L</span>)</div><div class="line">                .accept(MediaType.APPLICATION_JSON))</div><div class="line">                .andDo(print())</div><div class="line">                .andExpect(status().isOk())</div><div class="line">                .andDo(document.document(</div><div class="line">                        <span class="comment">// (1)</span></div><div class="line">                        pathParameters(</div><div class="line">                                parameterWithName(<span class="string">"id"</span>).description(<span class="string">"Member's id"</span>)</div><div class="line">                        ),</div><div class="line">                        <span class="comment">// (2)</span></div><div class="line">                        responseFields(</div><div class="line">                                fieldWithPath(<span class="string">"email.value"</span>).description(<span class="string">"The Member's email address"</span>),</div><div class="line">                                fieldWithPath(<span class="string">"address.city"</span>).description(<span class="string">"The Member's address city"</span>),</div><div class="line">                                fieldWithPath(<span class="string">"address.street"</span>).description(<span class="string">"The Member's address street"</span>),</div><div class="line">                                fieldWithPath(<span class="string">"address.zipCode"</span>).description(<span class="string">"The Member's address zipCode"</span>)</div><div class="line">                        )</div><div class="line">                ))</div><div class="line">                .andExpect(jsonPath(<span class="string">"$.email.value"</span>, is(notNullValue())))</div><div class="line">                .andExpect(jsonPath(<span class="string">"$.address.city"</span>, is(notNullValue())))</div><div class="line">                .andExpect(jsonPath(<span class="string">"$.address.street"</span>, is(notNullValue())))</div><div class="line">                .andExpect(jsonPath(<span class="string">"$.address.zipCode"</span>, is(notNullValue())))</div><div class="line">        ;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>(1) Path Parameter에 대한 정의 입니다. <code>parameterWithName(&quot;id&quot;).description(&quot;Member's id&quot;)</code> 설정을 통해서 간단하게 문서화가 가능합니다.</li><li>(2) <code>responseFields()</code> 메서드로 reponse 값들에 대한 문서 정의가 가능합니다.</li></ul><p>실제 Document 모습입니다.</p><p algin="cneter">    <img src="https://github.com/cheese10yun/springboot-restdocs/raw/master/assets/member-document.png"></p><p>기본적으로 <code>snippets</code>은 6개가 생성됩니다.</p><p algin="cneter">    <img src="https://github.com/cheese10yun/springboot-restdocs/raw/master/assets/target.png"></p><p>기본 <code>snippets</code> 6개 이외에도  <code>path-parameters.adoc</code>, <code>response-fields.adoc</code> 이 추가로 생성된 것을 확인 할 수 있습니다. 이것은 (1), (2) 에서 추가로 문서 작성 코드를 통해서 작성된 것입니다. 해당  <code>snippets</code>은 만들지 않더라도 기본적인 문서는 갖출 수 있습니다. <strong>하지만 해당 코드를 작성하면 문서와 코드의 일치 성이 높아집니다.</strong></p><p>만약 <code>fieldWithPath(&quot;email.value&quot;).description(&quot;The Member's email address&quot;)</code> 코드를 주석하고 테스트 코드를 실행하게 되면</p><p><img src="https://github.com/cheese10yun/springboot-restdocs/raw/master/assets/member-error.png" alt="member-error"></p><p>위의 그림과 같이 해당 페이로드가 문서화 되지 않았다는 메시지오 함께 테스트 코드가 실패하게 됩니다. 물론 <code>response-body.adoc</code>으로 매번 response 값이 갱신 되기 때문에 문서와의 일치 성은 보장 받을 수 있습니다. 해당 필드 값에 대한 타입과 정의까지 철저 하게 관리하고 싶으시다면 작성하는것도 좋다고 생각합니다.</p><h2><span id="document-구조-adoc-파일-작성">Document 구조 adoc 파일 작성</span></h2><p>테스트코드 기반으로 생성된 <code>snippets</code>을 실제 문서로 만들기 위한 <code>.adoc</code> 파일을 만들어야합니다. 문서의 뼈대 같은 구조를 잡아주는 작업 입니다.</p><p><code>src/main/asciidoc/</code>  경로에 <code>api-guide.adoc</code> 파일을 생성하고 테스트 코드를 통해서 생성된 <code>snippets</code> 파일들을 아래와 같이 추가합니다. <strong><code>api-guide.adoc</code> 파일의 일부분 이라서 전체 파일을 보시는 것이 좋습니다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">= Member</div><div class="line"></div><div class="line">== Member 조회</div><div class="line"></div><div class="line">include::&#123;snippets&#125;/member-controller-test/get_member/path-parameters.adoc[]</div><div class="line">include::&#123;snippets&#125;/member-controller-test/get_member/http-response.adoc[]</div><div class="line">include::&#123;snippets&#125;/member-controller-test/get_member/response-fields.adoc[]</div><div class="line">include::&#123;snippets&#125;/member-controller-test/get_member/curl-request.adoc[]</div><div class="line">include::&#123;snippets&#125;/member-controller-test/get_member/http-request.adoc[]</div><div class="line">include::&#123;snippets&#125;/member-controller-test/get_member/httpie-request.adoc[]</div><div class="line">include::&#123;snippets&#125;/member-controller-test/get_member/request-body.adoc[]</div><div class="line">include::&#123;snippets&#125;/member-controller-test/get_member/response-body.adoc[]</div></pre></td></tr></table></figure><h2><span id="최종-document">최종 Document</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mvn install</div><div class="line">mvn spring-boot:run</div></pre></td></tr></table></figure><p>테스트 코드를 실행하고 스프링 부트를 실행 이후 <a href="http://localhost:8080/docs/api-guide.html" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/docs/api-guide.html</a>를 접속하면 Rest Docs 기반의 문서를 확인 할 수 있습니다.</p><p><img src="https://github.com/cheese10yun/springboot-restdocs/raw/master/assets/document-main.png" alt="document-main"></p><h2><span id="마무리">마무리</span></h2><p>Member 조회 이외의 테스트 코드들도 있으니 프로젝트의 전체 코드를 보시는 것이 좋을 거 같습니다. 위에서 언급했듯이 문서와 코드의 지속적인 일치성, 비즈니스 로직을 가리는 과도한 문서화의 코드들이 침입하지 않는 점 등 제가 생각하기에는 Rest Docs는 정말 좋은 문서 도구라고 생각합니다. 반드시 테스트 코드를 작성해야 한다는 것도 테스트 코드에 익숙하지 않은 상태에서는 조금은 어렵겠지만 반강제적으로라도 테스트 코드를 작성하게 도와주는 점도 있어 이 또한 큰 장점이라고 생각합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;코드는 &lt;a href=&quot;https://github.com/cheese10yun/springboot-restdocs#test-code-%EC%84%A4%EC%A0%95&quot; rel=&quot;external nofollow noopener nor
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="REST Docs" scheme="https://cheese10yun.github.io/tags/REST-Docs/"/>
    
      <category term="Document" scheme="https://cheese10yun.github.io/tags/Document/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2 인증 방식 정리</title>
    <link href="https://cheese10yun.github.io/oauth2/"/>
    <id>https://cheese10yun.github.io/oauth2/</id>
    <published>2018-10-21T15:00:00.000Z</published>
    <updated>2018-10-21T15:43:30.047Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="oauth2-승인-방식의-종류">OAuth2 승인 방식의 종류</span></h2><ul><li>Authorization Code Grant Type  : 권한 부여 코드 승인 타입<br>클라이언트가 다른 사용자 대신 특정 리소스에 접근을 요청할 떄 사용됩니다. 리스소 접근을 위한 사용자 명과 비밀번호, 권한 서버에 요청해서 받은 권한 코드를 함ㄲ 활용하여 리소스에 대한 엑세스 토큰을 받는 방식입니다.</li><li>Implicit Grant Type : 암시적 승인<br>권한 부여 코드 승인 타입과 다르게 권한 코드 교환 단계 없이 엑세스 토큰을 즉시 반환받아 이를 인증에 이용하는 방식입니다.</li><li>Resource Owner Password Credentials Grant Type : 리소스 소유자 암호 자격 증명 타입<br>클라이언트가 암호를 사용하여 엑세스 토큰에 대한 사용자의 자격 증명을 교환하는 방식식입니다.</li><li>Client Credentials Grant Type : 클라이언트 자격 증명 타입<br>클라이언트가 컨텍스트 외부에서 액세스 토큰을 얻어 특정 리소스에 접근을 요청할 때 사용하는 방식입니다.</li></ul><h2><span id="authorization-code-grant-type-방식">Authorization Code Grant Type 방식</span></h2><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/oauth2-doe-grant-type_gnojt19me.png" alt="oauth2-doe-grant-type"></p><ul><li>(1) 클라이언트가 파리미터러 클라이언트 ID, 리다이렉트 URI, 응답 타입을 code로 지정하여 권한 서버에 전달합니다. 정상적으로 인증이 되면 권한 코드 부여 코드를 클라이언트에게 보냅니다.<ul><li>응답 타입은 code, token 이 사용 가능합니다.</li><li><strong>응답 타입이 token 일 경우 암시적 승인 타입에 해당합니다.</strong></li></ul></li><li>(2) 성공적으로 권한 부여 코드를 받은 클라이언트는 권한 부여 코드를 사용하여 엑세스 토큰을 권한 서버에 추가로 요청합니다. 이때 필요한 파라미터는 클라이언트 ID, 클라이언트 비밀번호, 리다이렉트 URI, 인증 타입 입니다.</li><li>(3) 마지막으로 받은 엑세스 토큰을 사용하여 리소스 서버에 사용자의 데이터를 보냅니다.</li></ul><h2><span id="implicit-grant-방식">Implicit Grant 방식</span></h2><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/Implicit%20Grant.png" alt="Implicit Grant"></p><ul><li>(1) 클라이언트가 파리미터러 클라이언트 ID, 리다이렉트 URI, 응답 타입을 code로 지정하여 권한 서버에 전달합니다. 정상적으로 인증이 되면 권한 코드 부여 코드를 클라이언트에게 보냅니다.<ul><li>응답 타입은 code, token 이 사용 가능합니다.</li><li><strong>응답 타입이 token 일 경우 암시적 승인 타입에 해당합니다.</strong></li></ul></li><li>(2) 응답 해준 Access Token 이 유효한지 검증 요청을 합니다.</li><li>(3) 요청 받은 Access Token 정보에 대한 검증에 대한 응답값을 돌려줍니다.</li><li>(4) 유효한 Access Token 기반으로 Resource Server와 통신합니다.</li></ul><h2><span id="resource-owner-password-credentials-grant-방식">Resource Owner Password Credentials Grant 방식</span></h2><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/Resource%20Owner%20Password%20Credentials%20Grant.png" alt="Resource Owner Password Credentials Grant"></p><ul><li>(1) 인증을 진행합니다. 대부분 ID, Password를 통해서 자격 증명이 진행됩니다.</li><li>(2) 넘겨 받은 정보기반으로 권한 서버에 Access Token 정보를 요청합니다.</li><li>(3) Access Token 정보를 응답 받습니다. 이때 Refresh Token 정보도 넘겨 줄 수도 있습니다.</li><li>(4) Access Token 기반으로 Resource Server와 통신합니다.</li></ul><h2><span id="client-credentials-grant-type-방식">Client Credentials Grant Type 방식</span></h2><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/Client%20Credentials%20Grant%20Type.png" alt="Client Credentials Grant Type"></p><ul><li>(1) Access Token 정보를 요청합니다.</li><li>(3) Access Token 정보를 응답합니다. 이때 Refresh Token 정보는 응답하지 않는 것을 권장합니다. 별다른 인증 절차가 없기 떄문에 Refresh Token 까지 넘기지 않는 것이라고 생각합니다.</li><li>(4) Access Token 기반으로 Resource Server와 통신합니다.</li></ul><h2><span id="참고">참고</span></h2><ul><li><a href="http://www.bubblecode.net/en/2016/01/22/understanding-oauth2/" rel="external nofollow noopener noreferrer" target="_blank">OAuth2 이해하기</a></li><li><a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B4458049183" rel="external nofollow noopener noreferrer" target="_blank">처음으로 배우는 스프링 부트2</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;oauth2-승인-방식의-종류&quot;&gt;OAuth2 승인 방식의 종류&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Authorization Code Grant Type  : 권한 부여 코드 승인 타입&lt;br&gt;
클라이언트가 다른 사용자 대신 특
      
    
    </summary>
    
    
      <category term="OAuth2" scheme="https://cheese10yun.github.io/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>Spring Social Part 2 데이터베이스에 회원 정보 저장</title>
    <link href="https://cheese10yun.github.io/spring-social-02/"/>
    <id>https://cheese10yun.github.io/spring-social-02/</id>
    <published>2018-09-22T15:00:00.000Z</published>
    <updated>2018-09-23T11:39:01.461Z</updated>
    
    <content type="html"><![CDATA[<p>전체 코드는 <a href="https://github.com/cheese10yun/spring-security-oauth2-social" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인해주세요.</p><p><a href="https://github.com/cheese10yun/spring-security-oauth2-social/blob/master/doc/step-01.md" rel="external nofollow noopener noreferrer" target="_blank">step-01: Google, Facebook 간단한 소셜 인증</a>에서 소셜 기반으로 인증 처리를 진행했습니다. 이번 차례에서는 해당 정보를 데이터베이스에 영속화 시키는 간단한 예제로 Data JPA, H2를 이용하겠습니다.</p><h2><span id="테이블">테이블</span></h2><p><img src="https://github.com/cheese10yun/spring-security-oauth2-social/blob/master/assets/social-table.png?raw=true" alt="social-table"></p><ul><li>user_connection : 소셜에서 넘겨준 프로필에 대한 테이블</li><li>user : 해당 프로젝트의 user 테이블</li></ul><p>전체적은 플로우는 다음과 같습니다.</p><ol><li>소셜에서 회원 인증</li><li>인증된 회원정보 데이터베이스 조회<ul><li>조회되는 경우 -&gt; 기존 유저로 판단, 조화된 정보기반으로 인증처리</li><li>조회되지 않은 경우 -&gt; 신규 유저로 판단, user_connection, user 테이블 저장 저장된 정보기반으로 인증처리</li></ul></li></ol><h2><span id="security">Security</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// @formatter:off</span></div><div class="line">        ...</div><div class="line">http.antMatcher(<span class="string">"/**"</span>).authorizeRequests().antMatchers(<span class="string">"/"</span>, <span class="string">"/login**"</span>).permitAll().anyRequest()</div><div class="line">                ...</div><div class="line">.addFilterBefore(ssoFilter(), BasicAuthenticationFilter.class);</div><div class="line"></div><div class="line"><span class="comment">// @formatter:on</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Filter <span class="title">ssoFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        CompositeFilter filter = <span class="keyword">new</span> CompositeFilter();</div><div class="line">        List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        filters.add(ssoFilter(google(), <span class="keyword">new</span> GoogleOAuth2ClientAuthenticationProcessingFilter(socialService)));</div><div class="line">        filters.add(ssoFilter(facebook(), <span class="keyword">new</span> FacebookOAuth2ClientAuthenticationProcessingFilter(socialService)));</div><div class="line">        filter.setFilters(filters);</div><div class="line">        <span class="keyword">return</span> filter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Filter <span class="title">ssoFilter</span><span class="params">(ClientResources client, OAuth2ClientAuthenticationProcessingFilter filter)</span> </span>&#123;</div><div class="line">        OAuth2RestTemplate restTemplate = <span class="keyword">new</span> OAuth2RestTemplate(client.getClient(), oauth2ClientContext);</div><div class="line">        filter.setRestTemplate(restTemplate);</div><div class="line">        UserInfoTokenServices tokenServices = <span class="keyword">new</span> UserInfoTokenServices(client.getResource().getUserInfoUri(), client.getClient().getClientId());</div><div class="line">        filter.setTokenServices(tokenServices);</div><div class="line">        tokenServices.setRestTemplate(restTemplate);</div><div class="line">        <span class="keyword">return</span> filter;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="https://github.com/cheese10yun/spring-security-oauth2-social/blob/master/doc/step-01.md" rel="external nofollow noopener noreferrer" target="_blank">step-01: Google, Facebook 간단한 소셜 인증</a>의 SecurityConfig 에서 조금 변경한 내용입니다.</p><p>달라진 점은 크게 없고 GoogleOAuth2ClientAuthenticationProcessingFilter, FacebookOAuth2ClientAuthenticationProcessingFilter의 클래스를 기반으로 필터에 등록시켰습니다. 이때 소셜 가입 및 로그인 처리를 담당하는 SocialService를 생성자를 통해서 주입해주었습니다.</p><h2><span id="oauth2clientauthenticationprocessingfilter">OAuth2ClientAuthenticationProcessingFilter</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacebookOAuth2ClientAuthenticationProcessingFilter</span> <span class="keyword">extends</span> <span class="title">OAuth2ClientAuthenticationProcessingFilter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</div><div class="line">    <span class="keyword">private</span> SocialService socialService;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FacebookOAuth2ClientAuthenticationProcessingFilter</span><span class="params">(SocialService socialService)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">"/login/facebook"</span>);</div><div class="line">        <span class="keyword">this</span>.socialService = socialService;</div><div class="line">        mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">        <span class="keyword">final</span> OAuth2AccessToken accessToken = restTemplate.getAccessToken(); <span class="comment">// 토큰 정보 가져옴</span></div><div class="line">        <span class="keyword">final</span> OAuth2Authentication auth = (OAuth2Authentication) authResult;</div><div class="line">        <span class="keyword">final</span> Object details = auth.getUserAuthentication().getDetails(); <span class="comment">// 소셜에서 넘겨 받은 정보를 details에 저장</span></div><div class="line">        <span class="keyword">final</span> FacebookUserDetails userDetails = mapper.convertValue(details, FacebookUserDetails.class); <span class="comment">// Object mapper를 이용해서 객체 변환</span></div><div class="line">        userDetails.setAccessToken(accessToken); <span class="comment">// access token 정보도 저장</span></div><div class="line"></div><div class="line">        <span class="keyword">final</span> UserConnection userConnection = UserConnection.valueOf(userDetails); <span class="comment">// UserConnection를 userDetails 기반으로 생성</span></div><div class="line">        <span class="keyword">final</span> UsernamePasswordAuthenticationToken authenticationToken = socialService.doAuthentication(userConnection); <span class="comment">// SocialService를 이용해서 인증 절차 진행</span></div><div class="line"></div><div class="line">        <span class="keyword">super</span>.successfulAuthentication(request, response, chain, authenticationToken);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>OAuth2ClientAuthenticationProcessingFilter 클래스를 상속 받아서 구현한 클래스입니다. successfulAuthentication 메서드는 소셜 인증을 성공되면 호출되는 메서드입니다. 가장 중</p><p><code>restTemplate.getAccessToken()</code> 메서드를 통해서 해당 유저의 access token 정보를 가져옵니다.</p><p>인자로 넘겨받은 authResult 객체에 소셜에서 넘겨받은 정보를 details 객체에 넘겨받습니다. 이때 넘겨받은 정보를 ObejctMapper를 이용해서 FacebookUserDetails로 변환 합니다.</p><p><a href="https://github.com/cheese10yun/spring-security-oauth2-social/blob/master/doc/step-01.md#%EB%82%B4%EB%B6%80-%EC%BD%94%EB%93%9C" rel="external nofollow noopener noreferrer" target="_blank">step-01: Google, Facebook 간단한 소셜 인증</a>에서 보셨듯 소셜에 넘겨주는 profile 객체는 LinkedHashMap의 형태입니다. 실제 런타임 전까지는 정확한 자료형을 확인하기가 어렵습니다. 그래서 FacebookUserDetails DTO 클래스 이용하는 것이 가독성 및 유지 보수하기 좋다고 생각합니다.</p><p>FacebookUserDetails 객체를 기반으로 UserConnection 객체를 만듭니다. UserConnection 객체는 아래에서 설명하겠습니다.</p><h3><span id="doauthentication-메서드">doAuthentication 메서드</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> UsernamePasswordAuthenticationToken <span class="title">doAuthentication</span><span class="params">(UserConnection userConnection)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (userService.isExistUser(userConnection)) &#123;</div><div class="line">        <span class="comment">// 기존 회원일 경우에는 데이터베이스에서 조회해서 인증 처리</span></div><div class="line">        <span class="keyword">final</span> User user = userService.findBySocial(userConnection);</div><div class="line">        <span class="keyword">return</span> setAuthenticationToken(user);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 새 회원일 경우 회원가입 이후 인증 처리</span></div><div class="line">        <span class="keyword">final</span> User user = userService.signUp(userConnection);</div><div class="line">        <span class="keyword">return</span> setAuthenticationToken(user);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Data JPA에 대한 설명은 하지 않겠습니다. 데이터베이스에서 회원 존재 유무를 확인 후 기존 회원일 경우는 바로 인증 회원 정보를 리턴합니다. 그렇지 않고 신규 회원일 경우에는 회원 가입을 진행 시킵니다. 이때 user_conncection, user 테이블에 두 곳 모두 저장시킵니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Hibernate: </div><div class="line">    insert </div><div class="line">    into</div><div class="line">        user_connection</div><div class="line">        (access_token, display_name, email, expire_time, image_url, profile_url, provider, provider_id, id) </div><div class="line">    values</div><div class="line">        (?, ?, ?, ?, ?, ?, ?, ?, ?)</div><div class="line"></div><div class="line">Hibernate: </div><div class="line">    insert </div><div class="line">    into</div><div class="line">        user</div><div class="line">        (email, nickname, provider_id, id) </div><div class="line">    values</div><div class="line">        (?, ?, ?, ?)</div></pre></td></tr></table></figure><p>신규 가입일 경우 쿼리입니다. user_connection, user 테이블에 각각 insert가 되는 것을 확인할 수 있습니다.</p><h2><span id="userconnection">UserConnection</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Table</span>(name = <span class="string">"user"</span>)</div><div class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)<span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@OneToOne</span>(cascade = CascadeType.PERSIST)</div><div class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"provider_id"</span>, referencedColumnName = <span class="string">"provider_id"</span>, nullable = <span class="keyword">false</span>, updatable = <span class="keyword">false</span>, unique = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">private</span> UserConnection social;</div><div class="line"></div><div class="line">    <span class="meta">@Builder</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(String email, String nickname, UserConnection social)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.email = email;</div><div class="line">        <span class="keyword">this</span>.nickname = nickname;</div><div class="line">        <span class="keyword">this</span>.social = social;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">signUp</span><span class="params">(UserConnection userConnection)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> User.builder()</div><div class="line">                .email(userConnection.getEmail())</div><div class="line">                .nickname(userConnection.getDisplayName())</div><div class="line">                .social(userConnection)</div><div class="line">                .build();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="meta">@Table</span>(name = <span class="string">"user_connection"</span>)</div><div class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConnection</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO) <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"email"</span>) <span class="keyword">private</span> String email;</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"provider"</span>) <span class="meta">@Enumerated</span>(EnumType.STRING) <span class="keyword">private</span> ProviderType provider;</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"provider_id"</span>, unique = <span class="keyword">true</span>, nullable = <span class="keyword">false</span>) <span class="keyword">private</span> String providerId;</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"display_name"</span>) <span class="keyword">private</span> String displayName;</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"profile_url"</span>) <span class="keyword">private</span> String profileUrl;</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"image_url"</span>) <span class="keyword">private</span> String imageUrl;</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"access_token"</span>) <span class="keyword">private</span> String accessToken;</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"expire_time"</span>) <span class="keyword">private</span> <span class="keyword">long</span> expireTime;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserConnection <span class="title">valueOf</span><span class="params">(GoogleUserDetails userDetails)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> UserConnection.builder()</div><div class="line">                .expireTime(userDetails.getExpiration())</div><div class="line">                .accessToken(userDetails.getAccess_token())</div><div class="line">                .providerId(userDetails.getSub())</div><div class="line">                .email(userDetails.getEmail())</div><div class="line">                .displayName(userDetails.getName())</div><div class="line">                .imageUrl(userDetails.getPicture())</div><div class="line">                .provider(ProviderType.GOOGLE)</div><div class="line">                .profileUrl(userDetails.getProfile())</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>코드는 길지만 말하고자 하는 것은 단순합니다. 지금 프로젝트에서는 소셜 가입 외에는 회원 인증 절차(회원가입)가 없다는 가정입니다.</p><p>그렇다는 것은 UserConnection 객체가 만들어지는 이유는 단 한 가지입니다. Google, Facebook를 통한 회원 인증일 경우입니다. UserConnection 위의 코드를 보시면 알겠지만 UserConnection 객체를 만들 수 있는 것은 방법은 <code>valueOf</code> 객체뿐입니다. (JPA 프록시객체 때문에 protected 생성자는 만들어야 합니다.)</p><p>이 처럼 객체의 생성도 명확한 근거 외에는 생성을 제한하는 좋은 구조라고 생각합니다. 또 User 객체도 마찬가지입니다. 소셜 회원 가입 이외에는 회원가입이 없으므로 User 객체는 UserConnection를 기반으로 만드는 방법 말고 제공하지 않는 것도 마찬가지입니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;전체 코드는 &lt;a href=&quot;https://github.com/cheese10yun/spring-security-oauth2-social&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="OAuth2" scheme="https://cheese10yun.github.io/tags/OAuth2/"/>
    
      <category term="Social" scheme="https://cheese10yun.github.io/tags/Social/"/>
    
  </entry>
  
  <entry>
    <title>Spring Social Part 1 Google, Facebook 간단한 소셜 인증</title>
    <link href="https://cheese10yun.github.io/spring-social/"/>
    <id>https://cheese10yun.github.io/spring-social/</id>
    <published>2018-09-14T15:00:00.000Z</published>
    <updated>2018-09-15T15:10:19.582Z</updated>
    
    <content type="html"><![CDATA[<p>전체 코드는 <a href="https://github.com/cheese10yun/spring-security-oauth2-social" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인해주세요.</p><h1><span id="소셜-인증">소셜 인증</span></h1><p>Spring Scurity OAuth2를 활용해서 Facebook, Google 계정 기반으로 정말 간단하게 인증 처리를 할 수 있습니다. 들어가기에 앞서 <a href="https://github.com/minwan1/spring-security-oauth2-example/blob/master/docs/step-1%3Aoauth1%2Coauth2%EB%9E%80.md#%EC%9D%B8%EC%A6%9D-%EC%A2%85%EB%A5%98" rel="external nofollow noopener noreferrer" target="_blank">OAuth 2인증 방식 : Authorization Code Grant</a> <strong>반드시 기본적인 이해를 하시는것을 권장드립니다.</strong> <a href="https://www.youtube.com/watch?v=hm2r6LtUbk8&amp;index=1&amp;list=PLuHgQVnccGMA4guyznDlykFJh28_R08Q-" rel="external nofollow noopener noreferrer" target="_blank">생활코딩</a>에도 잘 정의되어있습니다.</p><p>Google, Facebook App 생성 및 Https 설정을 하지 않았다면 <a href="https://github.com/cheese10yun/spring-security-oauth2-social/blob/master/doc/step-00.md" rel="external nofollow noopener noreferrer" target="_blank">step-00: gogole, facebook, https 설정</a>을 참고하여 작업을 완료해주세요</p><h2><span id="프로젝트-기본-설정">프로젝트 기본 설정</span></h2><h3><span id="maven">maven</span></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security.oauth<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security.oauth.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="applicationyml">application.yml</span></h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="attr">facebook:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    clientId:</span> <span class="string">&lt;your-client-id&gt;</span></div><div class="line"><span class="attr">    clientSecret:</span> <span class="string">&lt;your-secret&gt;</span></div><div class="line"><span class="attr">    accessTokenUri:</span> <span class="attr">https://graph.facebook.com/oauth/access_token</span></div><div class="line"><span class="attr">    userAuthorizationUri:</span> <span class="attr">https://www.facebook.com/dialog/oauth</span></div><div class="line"><span class="attr">    tokenName:</span> <span class="string">oauth_token</span></div><div class="line"><span class="attr">    authenticationScheme:</span> <span class="string">query</span></div><div class="line"><span class="attr">    clientAuthenticationScheme:</span> <span class="string">form</span></div><div class="line"><span class="attr">  resource:</span></div><div class="line"><span class="attr">    userInfoUri:</span> <span class="attr">https://graph.facebook.com/me</span></div><div class="line"></div><div class="line"><span class="string">google</span> <span class="string">:</span></div><div class="line">  <span class="string">client</span> <span class="string">:</span></div><div class="line">    <span class="string">clientId</span> <span class="string">:</span> <span class="string">&lt;your-client&gt;</span></div><div class="line"><span class="attr">    clientSecret:</span> <span class="string">&lt;your-secret&gt;</span></div><div class="line"><span class="attr">    accessTokenUri:</span> <span class="attr">https://www.googleapis.com/oauth2/v4/token</span></div><div class="line"><span class="attr">    userAuthorizationUri:</span> <span class="attr">https://accounts.google.com/o/oauth2/v2/auth</span></div><div class="line"><span class="attr">    clientAuthenticationScheme:</span> <span class="string">form</span></div><div class="line"><span class="attr">    scope:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">email</span></div><div class="line"><span class="bullet">    -</span> <span class="string">profile</span></div><div class="line"><span class="attr">  resource:</span></div><div class="line"><span class="attr">    userInfoUri:</span> <span class="attr">https://www.googleapis.com/oauth2/v3/userinfo</span></div></pre></td></tr></table></figure><h2><span id="소셜-인증-구현">소셜 인증 구현</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientResources</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@NestedConfigurationProperty</span></div><div class="line">    <span class="keyword">private</span> AuthorizationCodeResourceDetails client = <span class="keyword">new</span> AuthorizationCodeResourceDetails();</div><div class="line"></div><div class="line">    <span class="meta">@NestedConfigurationProperty</span></div><div class="line">    <span class="keyword">private</span> ResourceServerProperties resource = <span class="keyword">new</span> ResourceServerProperties();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> AuthorizationCodeResourceDetails <span class="title">getClient</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> client;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ResourceServerProperties <span class="title">getResource</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> resource;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ClientResources 클래스를 생성합니다. 해당 클래스는 위에서 설정한 property 설정을 편리하게 사용할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EnableWebSecurity</span></div><div class="line"><span class="meta">@EnableOAuth</span>2Client</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">  ....</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"facebook"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> ClientResources <span class="title">facebook</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientResources();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"google"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> ClientResources <span class="title">google</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientResources();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>EnableWebSecurity, EnableOAuth2Client 어노테이션을 추가합니다.</p><p>위에서 작성한 properties 들을 빈으로 등록해줍니다. ClientResources 클래스 덕분에 저렇게 쉽게 property 설정을 쉽게 설정할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// @formatter:off</span></div><div class="line">http.antMatcher(<span class="string">"/**"</span>).authorizeRequests().antMatchers(<span class="string">"/"</span>, <span class="string">"/login**"</span>).permitAll().anyRequest()</div><div class="line">.authenticated().and().exceptionHandling()</div><div class="line">.authenticationEntryPoint(<span class="keyword">new</span> LoginUrlAuthenticationEntryPoint(<span class="string">"/"</span>)).and()</div><div class="line">.addFilterBefore(ssoFilter(), BasicAuthenticationFilter.class);</div><div class="line"></div><div class="line"><span class="comment">// logout</span></div><div class="line">http.logout()</div><div class="line">                .invalidateHttpSession(<span class="keyword">true</span>)</div><div class="line">                .clearAuthentication(<span class="keyword">true</span>)</div><div class="line">                .logoutRequestMatcher(<span class="keyword">new</span> AntPathRequestMatcher(<span class="string">"/logout"</span>))</div><div class="line">                    .logoutSuccessUrl(<span class="string">"/"</span>)</div><div class="line">                .permitAll();</div><div class="line"><span class="comment">// @formatter:on</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>스프링 시큐리티 코드입니다. 해당 설정은 어렵지 않으니 자세한 설명은 생략하겠습니다. 중요한 포인트는 addFilterBefore메서드로 ssoFilter 필터를 등록했습니다. 해당 필터는 아래에서 다루겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">      <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">oauth2ClientFilterRegistration</span><span class="params">(OAuth2ClientContextFilter filter)</span> </span>&#123;</div><div class="line">          FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</div><div class="line">          registration.setFilter(filter);</div><div class="line">          registration.setOrder(-<span class="number">100</span>);</div><div class="line">          <span class="keyword">return</span> registration;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>인증 요청에 따른 리다이렉션을 위한 빈을 등록합니다. 이때 setOrder 메서드로 Spring Security 필터 보다 우선순위를 낮게 설정합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="function"><span class="keyword">private</span> Filter <span class="title">ssoFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        CompositeFilter filter = <span class="keyword">new</span> CompositeFilter();</div><div class="line">        List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        filters.add(ssoFilter(google(), <span class="string">"/login/google"</span>)); <span class="comment">//  이전에 등록했던 OAuth 리다이렉트 URL </span></div><div class="line">        filters.add(ssoFilter(facebook(), <span class="string">"/login/facebook"</span>));</div><div class="line">        filter.setFilters(filters);</div><div class="line">        <span class="keyword">return</span> filter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Filter <span class="title">ssoFilter</span><span class="params">(ClientResources client, String path)</span> </span>&#123;</div><div class="line">        OAuth2ClientAuthenticationProcessingFilter filter = <span class="keyword">new</span> OAuth2ClientAuthenticationProcessingFilter(path);</div><div class="line">        OAuth2RestTemplate restTemplate = <span class="keyword">new</span> OAuth2RestTemplate(client.getClient(), oauth2ClientContext);</div><div class="line">        filter.setRestTemplate(restTemplate);</div><div class="line">        UserInfoTokenServices tokenServices = <span class="keyword">new</span> UserInfoTokenServices(client.getResource().getUserInfoUri(), client.getClient().getClientId());</div><div class="line">        tokenServices.setRestTemplate(restTemplate);</div><div class="line">        filter.setTokenServices(tokenServices);</div><div class="line">        <span class="keyword">return</span> filter;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>위에서 configure 등록했던 ssoFilter 설정 입니다. 위에서 등록했던 빈 google(), 이전에 등록했던 OAuth 리다이렉트 URL <code>/login/google</code> 기반으로 Filter를 생성합니다.</p><p><strong>OAuth2ClientAuthenticationProcessingFilter 필터는 인증 서버에서 OAuth2 액세스 토큰을 획득하고 인증 객체를 SecurityContext에로드하는 데 사용할 수 있는 OAuth2 클라이언트 필터입니다.</strong></p><p>setRestTemplate 메스들을 통해서 OAuth2 인증 REST 요청을 만들 수 있는 RestTemplate 객체를 지정합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/"</span>, method = RequestMethod.GET)</div><div class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">home</span><span class="params">(Principal principal)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> principal;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>소셜 인증 이후 해당 컨트롤러로 이동하면 OAuth2ClientAuthenticationProcessingFilter 필터가 등록한  SecurityContextHolder 정보를 확인할 수 있습니다.</p><h2><span id="소셜-인증">소셜 인증</span></h2><h3><span id="facebook">Facebook</span></h3><p><img src="https://github.com/cheese10yun/spring-security-oauth2-social/raw/master/assets/facebook.png" alt="facebook"><br><a href="https://localhost:8080/login/facebook" rel="external nofollow noopener noreferrer" target="_blank">https://localhost:8080/login/facebook</a> 페이스북 로그인</p><h3><span id="google">Google</span></h3><p><img src="https://github.com/cheese10yun/spring-security-oauth2-social/raw/master/assets/google.png" alt="google"><br><a href="https://localhost:8080/login/google" rel="external nofollow noopener noreferrer" target="_blank">https://localhost:8080/login/google</a> 구글 로그인</p><h2><span id="내부-코드">내부 코드</span></h2><p>별다른 설정 없이 Spring Scurity OAuth2 활용하면 어렵지 않게 소셜 기반으로 인증 처리를 구현할 수 있습니다. 가장 핵심적인 클래스 OAuth2ClientAuthenticationProcessingFilter 클래스를 살펴보겠습니다.</p><h3><span id="attemptauthentication-메서드">attemptAuthentication 메서드</span></h3><p><img src="https://github.com/cheese10yun/spring-security-oauth2-social/raw/master/assets/attemptAuthentication.png" alt="attemptAuthentication"></p><p>소셜 인증을 시도하는 메서드로 위에서 등록했던 restTemplate 으로 Access Token 을 가져오고 해당 토큰 값으로 사용자 정보를 가져옵니다.</p><p>위 그림은 break point를 찍은 화면으로 acctessToken에는 accessToken, socpe, expriation 가 있고 userAuthenication에는 소셜에서 받아온 회원정보가 있습니다.</p><h3><span id="successfulauthentication-메서드">successfulAuthentication 메서드</span></h3><p><img src="https://github.com/cheese10yun/spring-security-oauth2-social/raw/master/assets/successfulAuthentication.png" alt="successfulAuthentication"></p><p>attemptAuthentication 에서 인증이 성공되었다면 이후에 successfulAuthentication 메서드를 호출하게 됩니다.</p><p>여기서 중요한 포인트는 authResut 값을 <code>super.successfulAuthentication(request, response, chain, authResult);</code> 메서드를 통해서 SecurityContextHolder에 저장되게 됩니다. 즉 소셜에서 받아온 정보 기반으로 인증 처리를 합니다.</p><h3><span id="인증-정보">인증 정보</span></h3><p><img src="https://raw.githubusercontent.com/cheese10yun/spring-security-oauth2-social/master/assets/login-info.png" alt="login-info"></p><p><a href="https://localhost:8080/" rel="external nofollow noopener noreferrer" target="_blank">https://localhost:8080/</a> 에서 해당 유저의 세션 정보를 확인 할 수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;전체 코드는 &lt;a href=&quot;https://github.com/cheese10yun/spring-security-oauth2-social&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="OAuth2" scheme="https://cheese10yun.github.io/tags/OAuth2/"/>
    
      <category term="Social" scheme="https://cheese10yun.github.io/tags/Social/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot HTTPS 적용 하기</title>
    <link href="https://cheese10yun.github.io/spring-https/"/>
    <id>https://cheese10yun.github.io/spring-https/</id>
    <published>2018-09-09T15:00:00.000Z</published>
    <updated>2018-09-15T15:06:07.109Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="spring-boot-https-적용하기">Spring Boot HTTPS 적용하기</span></h2><p>스프링 부트에서는 정말 간단하게 Https를 적용할 수 있습니다.</p><h2><span id="키스토어-생성">키스토어 생성</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 4000</div><div class="line"></div><div class="line">키 저장소 비밀번호 입력:</div><div class="line">새 비밀번호 다시 입력:</div><div class="line">이름과 성을 입력하십시오.</div><div class="line">  [Unknown]:  test</div><div class="line">조직 단위 이름을 입력하십시오.</div><div class="line">  [Unknown]:  test</div><div class="line">조직 이름을 입력하십시오.</div><div class="line">  [Unknown]:  test</div><div class="line">구/군/시 이름을 입력하십시오?</div><div class="line">  [Unknown]:  test</div><div class="line">시/도 이름을 입력하십시오.</div><div class="line">  [Unknown]:  test</div><div class="line">이 조직의 두 자리 국가 코드를 입력하십시오.</div><div class="line">  [Unknown]:  01</div><div class="line">CN=test, OU=test, O=test, L=test, ST=test, C=01이(가) 맞습니까?</div><div class="line">  [아니오]:  y</div></pre></td></tr></table></figure><h2><span id="properties-설정">properties 설정</span></h2><h3><span id="yml">YML</span></h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  ssl:</span></div><div class="line"><span class="attr">    key-store:</span> <span class="string">keystore.p12</span></div><div class="line"><span class="attr">    key-store-password:</span> <span class="string">cheese</span></div><div class="line"><span class="attr">    keyStoreType:</span> <span class="string">PKCS12</span></div><div class="line"><span class="attr">    keyAlias:</span> <span class="string">tomcat</span></div></pre></td></tr></table></figure><h3><span id="properties">Properties</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server.ssl.key-store: keystore.p12</div><div class="line">server.ssl.key-store-password: cheese</div><div class="line">server.ssl.keyStoreType: PKCS12</div><div class="line">server.ssl.keyAlias: tomcat</div></pre></td></tr></table></figure><h2><span id="https-요청">https 요청</span></h2><p><img src="https://github.com/cheese10yun/blog-sample/blob/master/spring-https/assets/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-09-10%20%EC%98%A4%EC%A0%84%202.01.38.png?raw=true" alt="스크린샷 2018-09-10 오전 2.01.38"></p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/spring-https/assets/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202018-09-10%20%EC%98%A4%EC%A0%84%202.01.42.png" alt="스크린샷 2018-09-10 오전 2.01.42"></p><ul><li><a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8" rel="external nofollow noopener noreferrer" target="_blank">스프링 부트</a> 참고</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;spring-boot-https-적용하기&quot;&gt;Spring Boot HTTPS 적용하기&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;스프링 부트에서는 정말 간단하게 Https를 적용할 수 있습니다.&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;키스토어-생성&quot;&gt;
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="Https" scheme="https://cheese10yun.github.io/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Jpa Best Practices step-10 - Properties 설정값 가져오기</title>
    <link href="https://cheese10yun.github.io/spring-jpa-best-10/"/>
    <id>https://cheese10yun.github.io/spring-jpa-best-10/</id>
    <published>2018-08-04T15:00:00.000Z</published>
    <updated>2018-11-17T06:15:52.451Z</updated>
    
    <content type="html"><![CDATA[<p>해당 코드는 <a href="https://github.com/cheese10yun/spring-jpa-best-practices" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인해주세요.</p><p>Properties 설정값을 가져오는 다양한 방법들이 있습니다. 방법이 많다 보니 좋지 않은 패턴으로 사용하는 예도 흔하게 발생합니다. 안티 패턴을 소개하고 이것이 왜 안 좋은지 간단하게 소개하고 제가 생각하는 좋은 패턴도 소개해드리겠습니다.</p><h2><span id="properties">properties</span></h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">user:</span></div><div class="line"><span class="attr">  email:</span> <span class="string">"yun@test.com"</span></div><div class="line"><span class="attr">  nickname:</span> <span class="string">"yun"</span></div><div class="line"><span class="attr">  age:</span> <span class="number">28</span></div><div class="line"><span class="attr">  auth:</span> <span class="literal">false</span></div><div class="line"><span class="attr">  amount:</span> <span class="number">101</span></div></pre></td></tr></table></figure><p>properties 설정은 위와 같습니다. 참고로 .yml 설정 파일입니다.</p><h2><span id="안티패턴-environment">안티패턴 : Environment</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AntiSamplePropertiesRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Environment env;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span>  </span>&#123;</div><div class="line">        <span class="keyword">final</span> String email = env.getProperty(<span class="string">"user.email"</span>);</div><div class="line">        <span class="keyword">final</span> String nickname = env.getProperty(<span class="string">"user.nickname"</span>);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> age = Integer.valueOf(env.getProperty(<span class="string">"user.age"</span>));</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> auth = Boolean.valueOf(env.getProperty(<span class="string">"user.auth"</span>));</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> amount = Integer.valueOf(env.getProperty(<span class="string">"user.amount"</span>));</div><div class="line"></div><div class="line">        log.info(<span class="string">"=========ANTI========="</span>);</div><div class="line">        log.info(email); <span class="comment">// "yun@test.com"</span></div><div class="line">        log.info(nickname); <span class="comment">// yun</span></div><div class="line">        log.info(String.valueOf(age)); <span class="comment">// 27</span></div><div class="line">        log.info(String.valueOf(auth)); <span class="comment">// true</span></div><div class="line">        log.info(String.valueOf(amount)); <span class="comment">// 100</span></div><div class="line">        log.info(<span class="string">"=========ANTI========="</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>일반적으로 가장 쉬운 Environment를 활용한 방법입니다. 많은 것들 생각하지 않고 properties에 정의된 것을 key 값으로 찾아옵니다.</p><p>위의 Environment 이용해서 properties에서 설정을 가져오는 것은 편하지만 단점들이 있습니다.</p><h3><span id="정확한-자료형-확인의-어려움">정확한 자료형 확인의 어려움</span></h3><p>key 값으로 어느 정도 유추할 수 있지만 어디까지나 유추이지 정확한 자료형을 확인하기 위해서는 properties에서 value 값을 기반으로 자료형을 확인해야 합니다. 또 amount 값이 100 이기 때문에 int 타입으로 바인딩시켰지만 amount 값은 소수로 값이 변경될 수도 있습니다. 이 또한 값을 통해서 자료형을 유추했기 때문에 발생한다고 생각합니다.</p><h3><span id="변경시-관리의-어려움">변경시 관리의 어려움</span></h3><p>email의 키값이 email-address로 변경됐을시 getProperty() 메서드를 통해서 바인딩 시킨 부분들은 모두 email-address로 변경해야 합니다. 변경하는 것도 문제지만 만약 1개의 메소드라도 실수로 놓쳤을 경우 에러 발생 시점에 runtime으로 넘어가게 되고 해당 에러가 NullPointException이 발생하기 전까지는 확인하기 어렵습니다.</p><h2><span id="추천-패턴-configurationproperties">추천 패턴 : ConfigurationProperties</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</div><div class="line"><span class="meta">@Validated</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleProperties</span> </span>&#123;</div><div class="line">    <span class="meta">@Email</span></div><div class="line">    <span class="keyword">private</span> String email;</div><div class="line">    <span class="meta">@NotEmpty</span></div><div class="line">    <span class="keyword">private</span> String nickname;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> auth;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</div><div class="line"></div><div class="line">    <span class="comment">// getter, setter</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SamplePropertiesRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SampleProperties properties;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span>  </span>&#123;</div><div class="line">        <span class="keyword">final</span> String email = properties.getEmail();</div><div class="line">        <span class="keyword">final</span> String nickname = properties.getNickname();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> age = properties.getAge();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> auth = properties.isAuth();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">double</span> amount = properties.getAmount();</div><div class="line"></div><div class="line">        log.info(<span class="string">"=================="</span>);</div><div class="line">        log.info(email); <span class="comment">// yun@test.com</span></div><div class="line">        log.info(nickname); <span class="comment">// yun</span></div><div class="line">        log.info(String.valueOf(age)); <span class="comment">// 27</span></div><div class="line">        log.info(String.valueOf(auth)); <span class="comment">// true</span></div><div class="line">        log.info(String.valueOf(amount)); <span class="comment">// 100.0</span></div><div class="line">        log.info(<span class="string">"=================="</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>아주 간단하고 명확한 해결 방법은 ConfigurationProperties를 이용해서 POJO 객체를 두는 것입니다. 장점들은 다음과 같습니다.</p><h3><span id="validation">Validation</span></h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">user:</span></div><div class="line"><span class="attr">  email:</span> <span class="string">"yun@"</span> <span class="string">//</span> <span class="string">이메일</span> <span class="string">형식</span> <span class="string">올바르지</span> <span class="string">않음</span> <span class="bullet">-&gt;</span> <span class="string">@Email</span></div><div class="line"><span class="attr">  nickname:</span> <span class="string">""</span> <span class="string">//</span> <span class="string">필수</span> <span class="string">값</span> <span class="bullet">-&gt;</span> <span class="string">@NotEmpty</span></div></pre></td></tr></table></figure><p>JSR-303 기반으로 Validate 검사를 할 수 있습니다. 위 코드 처럼 <code>@Validated</code>, <code>@Email</code> 어노테이션을 이용하면 쉽게 유효성 검사를 할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Binding to target com.cheese.springjpa.properties.SampleProperties$<span class="variable">$EnhancerBySpringCGLIB</span>$<span class="variable">$68016904</span>@3cc27db9 failed:</div><div class="line"></div><div class="line">    Property: user.email</div><div class="line">    Value: yun@</div><div class="line">    Reason: 이메일 주소가 유효하지 않습니다.</div><div class="line"></div><div class="line">Binding to target com.cheese.springjpa.properties.SampleProperties$<span class="variable">$EnhancerBySpringCGLIB</span>$<span class="variable">$d2899f85</span>@3ca58cc8 failed:</div><div class="line"></div><div class="line">    Property: user.nickname</div><div class="line">    Value: </div><div class="line">    Reason: 반드시 값이 존재하고 길이 혹은 크기가 0보다 커야 합니다.</div></pre></td></tr></table></figure><p><strong>위와 같이 컴파일 과정 중에 잡아주고 에러 메시지도 상당히 구체적입니다.</strong></p><h3><span id="빈으로-등록-해서-재사용성이-높음">빈으로 등록 해서 재사용성이 높음</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleProperties</span> </span>&#123;</div><div class="line">    <span class="meta">@Email</span></div><div class="line">    <span class="keyword">private</span> String email;</div><div class="line">    <span class="meta">@NotEmpty</span></div><div class="line">    <span class="keyword">private</span> String nickname;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> auth;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</div><div class="line"></div><div class="line">    <span class="comment">// getter, setter </span></div><div class="line">    <span class="comment">// properties 사용할 떄는 SampleProperties 객체를 사용함, 데이터의 응집력, 캡슐화가 높아짐</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>SamplePropertiesRunner 클래스를 보시면 SampleProperties를 의존성 주입을 받아서 다른 빈에서 재사용성이 높습니다. 단순히 재사용성이 높은 것이 아니라 user의 응집력이 높아집니다.</p><p>개별적으로 user에 대한 데이터 email, nickname, age…를 나열하는 것은 응집력을 심각하게 떨어트린다고 생각합니다. user가 가지고 있는 정보들은 또 무엇인지 확인 하기 어렵고 정확한 타입을 유추하기도 어렵습니다. 이로 인해서 캡슐화의 심각한 저하로 이어 집니다…</p><h3><span id="그밖에-장점들">그밖에 장점들</span></h3><p>Relaxed Binding으로 properties 키값에 유연하게 지정할 수 있습니다.</p><p>SampleProperties에 firstName 추가되었을 때 바인딩시킬 properties 키값을 first-name, FIRSTNAME, firstName 등을 사용해도 바인딩이 됩니다. 장점이긴 하지만 반드시 하나의 네이밍을 정하고 통일하는 게 바람직하다고 생각합니다.</p><h2><span id="결론">결론</span></h2><p><strong>위에서 설명한 부분을 properties의 한에서만 생각하지 않고 객체를 바라볼 때 데이터의 응집력, 캡슐화를 높이는 방법을 고민하는 것이 중요하다고 생각합니다.</strong></p><h2><span id="참고-자료">참고 자료</span></h2><ul><li><a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/" rel="external nofollow noopener noreferrer" target="_blank">Spring Boot Reference Guide</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/spring-jpa-best-practices&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Best Practices" scheme="https://cheese10yun.github.io/tags/Best-Practices/"/>
    
  </entry>
  
  <entry>
    <title>인텔리제이 Properties 자동완성</title>
    <link href="https://cheese10yun.github.io/intellij-Assistant/"/>
    <id>https://cheese10yun.github.io/intellij-Assistant/</id>
    <published>2018-08-04T15:00:00.000Z</published>
    <updated>2018-08-05T05:30:45.148Z</updated>
    
    <content type="html"><![CDATA[<p align="center">    <img src="https://i.imgur.com/X6giEx5.gif"> </p><p>위 그림처럼 유자가 추가한 properties 속성들도 자동 완성을 지원합니다.</p><p align="center">    <img src="https://i.imgur.com/AmkyrnX.gif"> </p><p>또 Properties 속성이 코드에 바인딩 되는지 확인 할 수 있어 아주 유용합니다.</p><h2><span id="properties">Properties</span></h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">sample:</span></div><div class="line"><span class="attr">  email:</span> <span class="string">"yun@test.com"</span></div><div class="line">  <span class="string">name</span> <span class="string">:</span> <span class="string">"yun"</span></div><div class="line"><span class="attr">  age:</span> <span class="number">27</span></div><div class="line"><span class="attr">  auth:</span> <span class="literal">true</span></div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"sample"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleProperties</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String email;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> auth;</div><div class="line"></div><div class="line">    <span class="comment">// getter, setter </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Properties 속성값과 바인딩 될 객체입니다.</p><h2><span id="plugin-추가">Plugin 추가</span></h2><p align="center">    <img src="https://i.imgur.com/rVX7XJz.png"> </p><p><strong>대부분 이미 설치가 되어있을 겁니다.</strong></p><h2><span id="의존성-추가">의존성 추가</span></h2><h3><span id="maven">maven</span></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><h3><span id="gradle">gradle</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    optional &quot;org.springframework.boot:spring-boot-configuration-processor&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="intellij-설정">Intellij 설정</span></h2><p align="center">    <img src="https://i.imgur.com/Gojvv1c.png"> </p><p><code>Settings &gt; Build, Execution &amp; Deployment &gt; Compiler &gt; Annotation Processors</code> 에서 <code>Enable annotation processing</code>를 체크</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://i.imgur.com/X6giEx5.gif&quot;&gt; 
&lt;/p&gt;
&lt;p&gt;위 그림처럼 유자가 추가한 properties 속성들도 자동 완성을 지원합니다.&lt;/p&gt;
&lt;p align=&quot;cente
      
    
    </summary>
    
    
      <category term="IntelliJ" scheme="https://cheese10yun.github.io/tags/IntelliJ/"/>
    
      <category term="Properties" scheme="https://cheese10yun.github.io/tags/Properties/"/>
    
      <category term="Assistant" scheme="https://cheese10yun.github.io/tags/Assistant/"/>
    
  </entry>
  
  <entry>
    <title>Spring 예제로 보는 SOLID DIP</title>
    <link href="https://cheese10yun.github.io/spring-solid-dip/"/>
    <id>https://cheese10yun.github.io/spring-solid-dip/</id>
    <published>2018-07-26T15:00:00.000Z</published>
    <updated>2018-07-26T15:24:55.270Z</updated>
    
    <content type="html"><![CDATA[<p>해당 코드는 <a href="https://github.com/cheese10yun/spring-SOLID" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인해주세요.</p><p>의존성역전의 원칙: Dependency Inversion Principle의 핵심 키워드는 다음과 같습니다.</p><p>상위 수준 정책은 하위 수준 세부 정보에 의존해서는 안됩니다.</p><ul><li>상위 모듈은 하위 모듈의 구현에 의존해서는 안 된다.</li><li>하위의 모듈이 상위 모듈에 정의한 추상 타입에 의존 해야한다.</li></ul><p>대표적인 DIP 핵심 키워드 입니다. 단어 하나 하나 플이를 하고 아래의 예제를 통해서 다 다시 이해하는 과정을 통해서 설명드리겠습니다. 다음예제는 아래와 같은 요구사항이 있습니다.</p><h1><span id="요구사항">요구사항</span></h1><ul><li>카드 결제 시스템을 만들어야 한다.</li><li>현재 지원하는 카드는 신한 카드 하나뿐이다.</li><li>이제 우리 카드 결제가 추가되어 구현해야 한다.</li><li>앞으로도 카드는 지속해서 추가될 예정이다.</li></ul><h1><span id="용어-풀이">용어 풀이</span></h1><blockquote><p><strong><em>상위 모듈 이란 ?</em></strong></p><p>상위 모듈이란 상위 정책을 의미합니다. 위의 요구사항에서는 카드 결제라는 것이 상위 정책을 뜻합니다.</p></blockquote><blockquote><p><strong><em>하위 모듈 이란 ?</em></strong></p><p>하위 모듈이란 상위 정책에 따른 하위 정책을 말합니다. 위의 요구사항에서 카드 결제라는 상위 정책이 있으면 신한 카드 결제라는 하위(세부) 정책이 있습니다.</p></blockquote><blockquote><p><strong><em>추상 타입 이란 ?</em></strong></p><p>추상 타입은 인터페이스, 추상화 클래스를 의미합니다. 상위 정책이 하위 정책에 의존하지 않고 추상 타입에 의존하라는 것은 <strong>카드 결제라는 상위 정책이 신한 카드 결제라는 하위 정책을 의존하지 말고 추상 클래스, 인터페이스를 의존하라는 것입니다.</strong></p></blockquote><h1><span id="dip-준수하지-않은-코드">DIP 준수하지 않은 코드</span></h1><p align="center">    <img src="https://i.imgur.com/Zkykv9m.png"></p><p><strong>위 그림은 쉽게 설명해보면 카드 결제(상위 수준 정책)가 신한 카드 결제(하위 수준)에 의존하고 있습니다.</strong> 그렇다면 이것이 갖는 단점이 무엇인지 아래 예제 코드를 통해서 확인해보겠습니다.</p><h2><span id="지나친-의존-관계">지나친 의존 관계</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/dip/anti/payment"</span>, method = RequestMethod.POST)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(@RequestBody ShinhanCardDto.PaymentRequest req)</span></span>&#123;</div><div class="line">        shinhanCardPaymentService.pay(req);</div><div class="line">    &#125;   </div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShinhanCardPaymentService</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(ShinhanCardDto.PaymentRequest req)</span> </span>&#123;</div><div class="line">        shinhanCardApi.pay(req);</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// RequestBody JSON 포멧</div><div class="line">&#123;</div><div class="line">  "shinhanCardNumber":"4845-9005-9423-4452",  //만약 shinhanCardNumber -&gt; cardNumber 으로 변경된다면 ?</div><div class="line">  "cvc":"233"</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>카드 결제 기능(상위 정책)이 신한 카드 결제(하위 정책)에 지나치게 의존적입니다. 그 결과 위처럼 신한 카드사의 카드 결제의 JSON의 키값만 변경 시 컨트롤러, 또 그 값을 넘겨주는 프론트엔드 까지 변경까지 영향을 미치게 됩니다. 이렇듯 지나친 의존 관계는 많은 변경 포인트를 유발합니다.</p><h2><span id="확장에-유연하지-못함">확장에 유연하지 못함</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/anti/payment"</span>, method = RequestMethod.POST)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(@RequestBody CardPaymentDto.PaymentRequest req)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(req.getType() == CardType.SHINHAN)&#123;</div><div class="line">        shinhanCardPaymentService.pay(req);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.getType() == CardType.WOORI)&#123;</div><div class="line">        wooriCardPaymentService.pay(req);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>우리 카드, 신한 카드 결제 요청을 받을 PaymentRequest Dto 클래스를 생성하였고 CardType으로 해당 맞는 카드 타입에 맞는 서비스를 호출하는 구조입니다. 가장 쉽게 생각할 수 있는 구조이지만 결코 좋은 구조가 아닙니다. 카드가 지속해서 추가될 때마다 해당 카드결제를 위한 if 문을 지속해서 추가해야 합니다. 이런 반복적인 if는 해당 리팩토링 대상일 확률이 매우 높습니다.</p><p>그 밖에도 추가될 카드의 결제를 담당하는 XXXPaymentService 클래스들이 지속해서 의존성 이루어집니다. 그 결과 PaymentController는 컨트롤러 계층임에도 너무 많은 책임을 갖게 되며, <strong>확장에 어렵고, 변경에 취약한 구조가 됩니다.</strong> 이 설명은 <a href="https://github.com/cheese10yun/spring-SOLID/blob/master/docs/OCP.md" rel="external nofollow noopener noreferrer" target="_blank">개방 폐쇄의 원칙: Open Close Principle</a>에서도 언급했던 내용입니다. 이렇듯 DIP와 OCP는 연관이 크며 SOLID도 각기 다른 메커니즘이 아니라 서로 유기적으로 연결되어 있습니다.</p><h1><span id="dip-준수">DIP 준수</span></h1><p align="center">    <img src="https://i.imgur.com/TdGYl8n.png"></p><ul><li>상위 모듈은 하위 모듈의 구현에 의존해서는 안 된다. 하위의 모듈이 상위 모듈에 정의한 추상 타입에 의존 해야한다.</li></ul><p>DIP의 핵심 내용이 문장장을 위의 요구사항에 맞춰서 풀어 보겠습니다.</p><p><strong>카드 결제(상위 모듈은)는 신한 카드 결제(하위 모듈)에 의존해서는 안된다. 신한 카드 결제(하위 모듈)은 카드 결제(상위 모듈)에 정의한 카드 결제 인터페이스(추상 타입)에 의존 해야한다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/payment"</span>, method = RequestMethod.POST)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(@RequestBody CardPaymentDto.PaymentRequest req)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> CardPaymentService cardPaymentService = cardPaymentFactory.getType(req.getType());</div><div class="line">        cardPaymentService.pay(req);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CardPaymentService</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">(CardPaymentDto.PaymentRequest req)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShinhanCardPaymentService</span> <span class="keyword">implements</span> <span class="title">CardPaymentService</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(CardPaymentDto.PaymentRequest req)</span> </span>&#123;</div><div class="line">        shinhanCardApi.pay(req);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>이제 코드 레벨에서 다시 정리해 보겠습니다. 의존관계를 인터페이스를 통해서 의존성을 역전 시켰습니다. 컴파일 단계에서는 PaymentController는 PaymentService 인터페이스를 바라보지만 런타임에서는 cardPaymentFactory 통해서 ShinhanCardPaymentService를 바라보게 됩니다.</p><p>또 하위 정책의 신한 카드, 우리 카드가 변경되더라도 PaymenrService 인터페이스를 의존하고 있으므로 확장에 열려 있고 변경에는 닫혀 있는 OCP를 준수하게 됩니다.</p><h1><span id="결론">결론</span></h1><p>그렇다면 모든 곳에 대해서 세부 구현체를 바라보는 것이 아니라 인터페이스로 바라보는 것이 올바른 것일까요? <strong>제 개인적인 생각은 그렇지 않다 입니다.</strong></p><p>모든 변경사항에 대응해서 설계한다는 것은 현실적으로 힘듭니다. 위 요구 사항처럼 지속해서 결제 가능한 카드사가 추가된다는 요구사항, 경험을 통해서 예측할 수 있는 상황들에 적용하는 것이 바람직하다고 생각합니다.</p><p>또 개인적인 생각으로는 인프라스트럭처에 대해서는 인터페이스로 바라보는 것이 적절하다고 생각합니다. 인프라스트럭처는 언제든지 대체될 수 있는 영역이기 때문에 이런 영역에 대해서는 인터페이스로 바라보게 설계해서 의존성을 역전 시키는 것이 좋을 거 같습니다.</p><h1><span id="참고">참고</span></h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;barcode=9788969090010" rel="external nofollow noopener noreferrer" target="_blank">도서 - 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴</a></li><li><a href="https://www.youtube.com/user/codetemplate/videos" rel="external nofollow noopener noreferrer" target="_blank">Youtube 강의(백명석님)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/spring-SOLID&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt;를 확인해주
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="SOLID" scheme="https://cheese10yun.github.io/tags/SOLID/"/>
    
      <category term="DIP" scheme="https://cheese10yun.github.io/tags/DIP/"/>
    
  </entry>
  
  <entry>
    <title>Spring 예제로 보는 SOLID OCP</title>
    <link href="https://cheese10yun.github.io/spring-solid-ocp/"/>
    <id>https://cheese10yun.github.io/spring-solid-ocp/</id>
    <published>2018-07-23T15:00:00.000Z</published>
    <updated>2018-07-24T16:30:15.685Z</updated>
    
    <content type="html"><![CDATA[<p>해당 코드는 <a href="https://github.com/cheese10yun/spring-SOLID" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인해주세요.</p><h1><span id="개방-폐쇄의-원칙-open-close-principle">개방 폐쇄의 원칙: Open Close Principle</span></h1><p>개방 폐쇄의 원칙: Open Close Principle 핵심 키워드는 다음과 같습니다. 해당 키워드를 기반으로 세부적으로 설명하겠습니다.</p><ul><li><strong>확장에는 열려 있고, 변경에는 닫혀 있다.</strong></li><li><strong>기능을 추가하거나 변경하면서 그것을 사용하는 코드는 수정하지 않는다.</strong></li></ul><p>대표적인 OCP의 핵심 개념입니다. SOLID를 처음 접하는 분들은 다소 어렵게 느껴지는 것들을 최대한 쉽게 풀어보겠습니다.</p><h2><span id="용어-정리">용어 정리</span></h2><blockquote><p><strong>확장 이란 ?</strong></p><p>새로운 타입을 추가함으로써 새로운 기능을 추가할 수 있다. 즉 확장이란 새로운 타입을 추가함으로써 새로운 기능(요구사항)을 구현한다. <strong>확장에는 열려 있다는 것은 새로운 타입(클래스)을 추가함으로써 기능(요구사항)을 확장하는 것이다…</strong></p></blockquote><blockquote><p><strong>변경 이란 ?</strong></p><p>확장이 발생했을 때 상위 레벨이 영향을 미치지 않아야 한다. <strong>확장(새로운 클래스)이 발생했을 때 해당 코드를 호출하는 쪽에서 변경이 발생하지 않다면 변경에 닫혀 있다는 것이다.</strong></p></blockquote><h1><span id="요구사항">요구사항</span></h1><ul><li>카드 결제 시스템을 만들어야 한다.</li><li>현재 지원하는 카드는 신한 카드 하나뿐이다.</li><li>이제 우리 카드 결제가 추가되어 구현해야 한다.</li><li>앞으로도 카드는 지속해서 추가될 예정이다.</li></ul><h1><span id="ocp를-준수하기-위한-실패-과정들">OCP를 준수하기 위한 실패 과정들</span></h1><p align="center">    <img src="https://i.imgur.com/a21midG.png"></p><p>기존 PamentController에서 ShinhanCardPaymentService를 의존해서 신한 카드 결제를 진행 헸습니다. 이제 우리 은행 카드결제가 추가되었으니 아래 컨트롤러처럼 기존 신한 카드를 건드리지(변경에 닫혀있다) 않고 우리 카드를 추가하는 가장 쉬운 방법은 아래처럼 컨트롤러를 각각 구성하는 방법입니다. 물론 OCP를 위반하는 코드입니다.</p><h2><span id="카드사-마다-api">카드사 마다 API</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/ocp/anti/payment/shinhan"</span>, method = RequestMethod.POST)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(@RequestBody ShinhanCardDto.PaymentRequest req)</span></span>&#123;</div><div class="line">    shinhanCardPaymentService.pay(req);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/ocp/anti/payment/woori"</span>, method = RequestMethod.POST)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(@RequestBody WooriCardDto.PaymentRequest req)</span></span>&#123;</div><div class="line">    wooriCardPaymentService.pay(req);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>해당 구조는 매우 좋지 않습니다. 카드사가 추가될 때 마다 API를 추가적으로 만들어야 합니다. 이는 확장에 좋지 않은 코드 뿐만 아니라 올바른 카드사의 API를 찾기위한 코드가 필요하게 됩니다.</p><h2><span id="공통-request로-api-통일">공통 Request로 API 통일</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentRequest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String cardNumber;</div><div class="line">    <span class="keyword">private</span> String csv;</div><div class="line">    <span class="keyword">private</span> CardType type;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 컨트롤러</span></div><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/ocp/anti/payment"</span>, method = RequestMethod.POST)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(@RequestBody CardPaymentDto.PaymentRequest req)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(req.getType() == CardType.SHINHAN)&#123;</div><div class="line">        shinhanCardPaymentService.pay(req);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.getType() == CardType.WOORI)&#123;</div><div class="line">        wooriCardPaymentService.pay(req);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 그 해당 카드 이외의 타입이 들어오면 예외처리는 어떻게??...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>넘겨받는 RequestBody 값의 통일로 하나의 API에서 신한 카드, 우리 카드 결제를 진행할 수 있게 되었습니다. 예를 들어 신한 카드는 카드 번호를 shinhanCardNumber, 우리 카드는 number로 사용했을 경우 매번 미세하게 다른 값들을 공통 Request로 통일하게 됩니다. 다음과 같은 장점이 같을 수 있습니다.</p><ul><li>기존 코드는 카드 파트너사의 API Request에 의존 관계를 분리할 수 있습니다.<ul><li>DIP의 '상위 레벨의 정책은 하위 레벨의 상세 합에 의존하면 안 된다.'를 준수하게 됩니다. (해당 개념은 DIP에 자세하게 포스팅하겠습니다.)</li></ul></li><li>Request 값을 통일 함으로써 추상화의 기초가 됩니다.</li></ul><p>위의 코드는 OCP를 준수하지는 않습니다. <strong>위에서 정리한 용어 변경에 위배됩니다.</strong></p><blockquote><p>확장(새로운 클래스)이 발생했을 때 해당 코드를 호출하는 쪽에서 <strong>변경이 발생하지 않다면</strong> 변경에 닫혀 있다는 것입니다.</p></blockquote><p>우리 카드가 추가되었을 경우 해당 컨트롤러의 코드에 if이 추가되었습니다. 이는 위에서 정리한 변경이 발생하는 경우입니다. 또 한 카드가 지속해서 추가될 때 마다 해당 카드결제를 위한 if 문을 지속해서 추가해야 합니다. 이런 반복적인 if는 해당 리팩토링 대상일 확률이 매우 높습니다.</p><p>그 밖에도 추가될 카드의 결제를 담당하는 XXXPaymentService 클래스들이 지속해서 의존성 이루어집니다. 그 결과 PaymentController는 컨트롤러 계층임에도 너무 많은 책임을 갖게 되며, <strong>확장에 어렵고, 변경에 취약한 구조가 됩니다.</strong></p><h1><span id="ocp-준수">OCP 준수</span></h1><p align="center">    <img src="https://i.imgur.com/TdGYl8n.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/payment"</span>, method = RequestMethod.POST)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(@RequestBody CardPaymentDto.PaymentRequest req)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> CardPaymentService cardPaymentService = cardPaymentFactory.getType(req.getType());</div><div class="line">        cardPaymentService.pay(req);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShinhanCardPaymentService</span> <span class="keyword">implements</span> <span class="title">CardPaymentService</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(CardPaymentDto.PaymentRequest req)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ShinhanCardDto.PaymentRequest paymentRequest = buildPayment(req);</div><div class="line">        shinhanCardApi.pay(paymentRequest);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WooriCardPaymentService</span> <span class="keyword">implements</span> <span class="title">CardPaymentService</span> </span>&#123;    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(CardPaymentDto.PaymentRequest req)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> WooriCardDto.PaymentRequest paymentRequest = buildPayment(req);</div><div class="line">        wooriCardApi.pay(paymentRequest);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>의존관계를 인터페이스를 통해서 역전시키는 것입니다. <strong>새로운 카드 결제가 추가된다고 하더라도 PaymentController 수정 없이 CardPayment를 확장하고 있습니다.</strong></p><p>다시 한번 정리하면 <strong>새로운 카드 결제가 추가(새로운 결제 타입 추가) 되더라도(확장에 열려있음) 카드 결제를 호출하는 코드 쪽에서 변경이(변경에는 닫혀 있음) 변경이 발생하지 않습니다. 물론 cardPaymentFactory 클래스의 의존성 주입 코드가 한번은 추가됩니다.</strong></p><p>즉 우리 카드 결제라는 새로운 기능이 추가되었을 때 이것을 새로운 타입으로 추가해서 런타임시 교체하여 <strong>확장에는 열려 있고</strong>, 또 그 코드를 호출하는 쪽은 인터페이스를 바라보고 있으므로 <strong>변경에는 닫혀 있는</strong> 구조가 됩니다.</p><p>이처럼 인터페이스를 두는 것만 해도 클래스 간의 강한 결합 관계를 느슨한 관계로 만들 수 있습니다. 그렇다면 모든 클래스의 결합 관계를 인터페이스를 두고 느슨한 관계로 유지해야 하는 걸까요?</p><p><strong>제 개인적인 생각은 아니라고 생각합니다.</strong> 모든 변경사항을 예상하는 것은 불가능하며 그것을 하는 것 또한 지나치게 비효율적이라고 생각합니다. 위처럼 명확한 요구사항인 지속해서 카드 결제가 추가되어야 한다. 라는 명확한 변경이 예상되는 시점, 경험을 통해서 예측할 수 있는 시점에 적용하는 것이 바람직하다고 생각합니다.</p><p><strong>그렇다면 중요한 것은 캡슐화, 객체의 올바른 책임, 역할을 부여하여 예측 변경 시점에 OCP를 쉽게 적용할 수 있도록 하는 것이 중요하다고 생각합니다.</strong></p><h1><span id="참고">참고</span></h1><ul><li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;barcode=9788969090010" rel="external nofollow noopener noreferrer" target="_blank">도서 - 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴</a></li><li><a href="https://www.youtube.com/user/codetemplate/videos" rel="external nofollow noopener noreferrer" target="_blank">Youtube 강의(백명석님)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/spring-SOLID&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt;를 확인해주
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="SOLID" scheme="https://cheese10yun.github.io/tags/SOLID/"/>
    
      <category term="OCP" scheme="https://cheese10yun.github.io/tags/OCP/"/>
    
  </entry>
  
  <entry>
    <title>인텔리제이 GitHub 활용법</title>
    <link href="https://cheese10yun.github.io/intellij-github/"/>
    <id>https://cheese10yun.github.io/intellij-github/</id>
    <published>2018-07-17T15:00:00.000Z</published>
    <updated>2018-07-18T14:05:30.601Z</updated>
    
    <content type="html"><![CDATA[<p>IntelliJ에서 다양한 Github 기능들을 제공해줍니다. 그 대표적인 기능들에 대한 정리입니다. 단축키는 하단 녹색박스에 표시되어 있습니다.</p><h2><span id="github-아이디-연동">Github 아이디 연동</span></h2><p>인텔리제이에서 지원하는 다양한 기능들을 사용하기 위해서는 Github 연동이 반드시 필요 합니다.</p><p><img src="https://i.imgur.com/wdn4bEW.png" alt=""></p><ol><li>설정에서 github 텝 인동</li><li>해당 Auth Type 선택 후 Test 버튼 클릭</li><li>Success 출력 확인후 OK 버튼 클릭</li></ol><h2><span id="share-proejct">Share Proejct</span></h2><p align="center">    <img src="https://github.com/cheese10yun/IntelliJ/blob/master/image/github-share.gif?raw=true"></p><p>해당 프로젝트를 GitHub Repository에 쉽게 업로드 할 수 있습니다.</p><h2><span id="gist-올리기">Gist 올리기</span></h2><p align="center">  <img src="https://github.com/cheese10yun/IntelliJ/blob/master/image/gist.gif?raw=true"></p>![](https://i.imgur.com/8XoRPgf.png)<p>원하는 코드를 드래그하고 위 그림처럼 Gist를 편하게 업로드 할 수 있습니다.</p><h2><span id="task-연동">Task 연동</span></h2><p><img src="https://i.imgur.com/qiDODzI.png" alt=""></p><p>Github Repository에 등록된 이슈들 기반으로 Branch를 생성 할 수있습니다. 세부 적인 워크 플로우는 <a href="https://github.com/cheese10yun/github-project-management" rel="external nofollow noopener noreferrer" target="_blank">Github로 프로젝트 관리하기</a>에서 확인 할 수 있습니다.</p><h3><span id="taskissue-기반-branch-생성">Task(Issue) 기반 Branch 생성</span></h3><p align="center">  <img src="https://github.com/cheese10yun/IntelliJ/blob/master/image/task.gif?raw=true"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IntelliJ에서 다양한 Github 기능들을 제공해줍니다. 그 대표적인 기능들에 대한 정리입니다. 단축키는 하단 녹색박스에 표시되어 있습니다.&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;github-아이디-연동&quot;&gt;Github 아이디 연동&lt;/span&gt;&lt;/
      
    
    </summary>
    
    
      <category term="IntelliJ" scheme="https://cheese10yun.github.io/tags/IntelliJ/"/>
    
      <category term="Tip" scheme="https://cheese10yun.github.io/tags/Tip/"/>
    
      <category term="Git" scheme="https://cheese10yun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Github로 프로젝트 관리하기 Part3</title>
    <link href="https://cheese10yun.github.io/github-project-part3/"/>
    <id>https://cheese10yun.github.io/github-project-part3/</id>
    <published>2018-07-16T15:00:00.000Z</published>
    <updated>2018-07-17T13:53:55.186Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="프로젝트-소개">프로젝트 소개</span></h2><p>Github를 이용해서 Project Management 하는 방법 및 전체적인 프로세스에 대해서 정리했습니다. <strong>issue 관리, 일정 관리, 코드리뷰, 버그 리포트 등 다양한 일들을 Github 하나에서 다 관리할 수 있고 어느 하나 부족하다고 생각하지 않습니다.</strong> 이미 Remote Repository로 Github를 사용 중 이리 사면 적극 추천해 드립니다.</p><p><img src="https://i.imgur.com/F5c78MC.png" alt=""></p><p>수 많은 이슈들이 발급되면 그것을 한눈에 보는 것은 기존 UI에서는 어렵습니다. 이런 문제를 칸반보드 형식으로 해결해주는 것이 ZenHub 입니다.</p><p><img src="https://cristinasantamarina.files.wordpress.com/2015/06/zenhub-task-board.png" alt=""><br>Public Repository를 이용 중이라면 무료로 사용 가능합니다. Private Repository는 비용을 지급하셔 야합니다.</p><p>물론 GitHub에서 제공해주는 Proeject도 칸반보드를 제공해주어서 대안이 되지만 여러 레파지토리에 대한 표시, 애픽 기능 등 다양한 기능들을 제공해주기 때문에 개인적으로 ZenHub를 추천해 드립니다.</p><p><strong>설치는 크롬 확장도구에서 다운로드 받으실 수 있습니다.</strong></p><h2><span id="기본-칸반보드">기본 칸반보드</span></h2><p>기본적인 구조는 New Issue, Icebox, Backlog, In Progress, Review/QA, Done을 갖습니다.</p><p>각자 본인의 프로젝트와 성향에 맞게 사용하시면 됩니다. 저 같은 경우에는 생각나는 모든 것들을 New Issue 항목에 추가하고 우선순위가 낮고 당장 필요 없는 작업은 Icebox, 우선순위가 높은 작업은 Backlog 항목에 넣습니다. 진행 중인 작업은 In Progress 나머지 Review/QA는 Pull Request 항목, Done은 Issue가 Close 되면 자동으로 Done으로 가게 됩니다.</p><p><strong>이처럼 모든 항목에 대해서 Issue로 관리하고 해당 Issue Number 기반으로 Branch가 생성되면서 코드리뷰, 반영 작업 사이클이 돌아가는 구조입니다.</strong></p><h2><span id="milestone-적극-활용">Milestone 적극 활용</span></h2><p><img src="https://i.imgur.com/3lDuAxi.png" alt=""></p><p>ZenHub 사용과 직접적인 기능은 아니지만, Milestone 여러 항목을 만들고 대부분 Icebox에 있는 issue가 아니라면 적절한 Milestone에 위치시키는 것을 권장합니다. 전체적인 작업에 진행 척도를 가시적으로 확인하기 좋은 점, 해당 Milestone(버전)에 추가되는 기능, 강화되는 기능, 수정된 버그 등을 직관적이로 표시 할 수 있습니다. 또 전체 Milestone 진척도를 알 수 있어 남은 시간도 산출하기 좋은 장점이 있습니다.</p><h2><span id="epic-적극-활용">Epic 적극 활용</span></h2><p><img src="https://i.imgur.com/dZhrATb.png" alt=""><br>Epic은 Milestone과 비슷하게 이해하시면 됩니다. 큰 작업(Issue)이 있다면 그 작업(Issue)을 여러 Issue로 등록하고 한 묶음으로 관리하는 것입니다.</p><p>Milestone의 장점처럼 작업에 대한 진척도를 가시적으로 표시하는 장점이 있습니다. 또 큰 작업물에 대한 작업은 여러 개발자가 나누어서 하다 보니 내가 그 기능을 작업하기 전에 선행적으로 진행되어야 하는 작업도 있을 수 있습니다. 이런 것들을 대한 피드백을 Epic을 이용하면 관리하기 편합니다.</p><p><img src="https://i.imgur.com/nIMGciB.png" alt=""><br>해당 Issue를 Epic으로 등록 시킬 경우 Create an epic 버튼을 클릭하면 됩니다.</p><p><img src="https://i.imgur.com/lN2uziy.png" alt=""><br>Issue를 등록할 때 오른쪽 하단의 Epic에서 등록시킬 수 있습니다.</p><h2><span id="issue-연결">Issue 연결</span></h2><p><img src="https://i.imgur.com/XYa3My3.png" alt=""><br>Connect with an issue 기능을 통해서 이슈끼리 연결을 할 수 있습니다. <strong>위처럼 Pull Request를 할 때 아주 유용하게 사용할 수 있습니다.</strong></p><p><img src="https://i.imgur.com/DPrWlUd.png" alt=""><br>Issue 13과 해당 이슈를 작업해서 Pull Request Issue 17 번이 ZenHub 보드에서 연결돼 있는 것을 확인 할 수 있습니다. <strong>이처럼 연관된 작업을 묶어주는 장점이 있습니다.</strong></p><h2><span id="filter-기능">Filter 기능</span></h2><p><img src="https://i.imgur.com/4pZEYsB.png" alt=""></p><p>다양한 Filter 기능을 제공합니다. Label, Assignee, Milestone, Repo 등등이 있습니다. 해당 기능은 직관적이니<br>Repo를 제외하고 따로 설명을 진행하지는 않겠습니다.</p><p>Repo는 여러 Repo를 한꺼번에 보여줄 수 있습니다. 가령 <strong>Back-end, Front-end Repository가 각각 두 개 이고 그 Repo를 한 보드에 표시할 수 있습니다.</strong> 실무 개발에서는 여러 Repo가 있기 때문에 이것을 한 보드에서 볼 수 있다는 것은 정말 좋은 Filter 기능이라고 생각합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;프로젝트-소개&quot;&gt;프로젝트 소개&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Github를 이용해서 Project Management 하는 방법 및 전체적인 프로세스에 대해서 정리했습니다. &lt;strong&gt;issue 관리, 일정 관리, 코드리뷰, 
      
    
    </summary>
    
    
      <category term="Github" scheme="https://cheese10yun.github.io/tags/Github/"/>
    
      <category term="Issue" scheme="https://cheese10yun.github.io/tags/Issue/"/>
    
      <category term="Proejct Management" scheme="https://cheese10yun.github.io/tags/Proejct-Management/"/>
    
      <category term="ZenHub" scheme="https://cheese10yun.github.io/tags/ZenHub/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Jpa Best Practices Step-09 - OneToMany 관계 설정 팁(2)</title>
    <link href="https://cheese10yun.github.io/spring-jpa-best-09/"/>
    <id>https://cheese10yun.github.io/spring-jpa-best-09/</id>
    <published>2018-07-16T15:00:00.000Z</published>
    <updated>2018-07-16T17:42:59.867Z</updated>
    
    <content type="html"><![CDATA[<p>해당 코드는 <a href="https://github.com/cheese10yun/spring-jpa-best-practices" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인해주세요.</p><p>이전에 OneToMany 관계 설정 포스팅이 관계설정의 초점보다는 풍부한 객체 관점 중심으로 다루었습니다. 그러다 보니 OneToMany에 대한 관계에 대한 설명 부분이 부족해서 추가 포스팅을 하게 되었습니다.</p><h2><span id="요구사항">요구사항</span></h2><ul><li>배송이 이 있고 배송의 상태를 갖는 배송 로그가 있습니다.</li><li>배송과 배송 상태는 1:N 관계를 갖는다.</li><li>배송은 배송 상태를 1개 이상 반드시 갖는다.</li></ul><h2><span id="entity">Entity</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Delivery</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line"></div><div class="line">    <span class="meta">@Embedded</span></div><div class="line">    <span class="keyword">private</span> Address address;</div><div class="line"></div><div class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"delivery"</span>, cascade = CascadeType.PERSIST, orphanRemoval = <span class="keyword">true</span>, fetch = FetchType.EAGER)</div><div class="line">    <span class="keyword">private</span> List&lt;DeliveryLog&gt; logs = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeliveryLog</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line"></div><div class="line">    <span class="meta">@Enumerated</span>(EnumType.STRING)</div><div class="line">    <span class="meta">@Column</span>(name = <span class="string">"status"</span>, nullable = <span class="keyword">false</span>, updatable = <span class="keyword">false</span>)</div><div class="line">    <span class="keyword">private</span> DeliveryStatus status;</div><div class="line"></div><div class="line">    <span class="meta">@ManyToOne</span></div><div class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"delivery_id"</span>, nullable = <span class="keyword">false</span>, updatable = <span class="keyword">false</span>)</div><div class="line">    <span class="keyword">private</span> Delivery delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="delivery-저장">Delivery 저장</span></h2><p>일대다 관계에서는 다 쪽이 외래 키를 관리하게 됩니다. JPA 상에서는 왜래 키가 갖는 쪽이 연관 관계의 주인이 되고 연관 관계의 주인만이 데이터베이스 연관 관계와 매핑되고 왜래 키를 관리(등록, 수정, 삭제)할 수 있으므로 DeliveryLog에서 Delivery를 관리하게 됩니다. <strong>하지만 DeliveryLog는 Delivery 상태를 저장하는 로그 성격 이기 때문에 핵심 비즈니스 로직을 Delivery에서 작성하는 것이 바람직합니다.</strong></p><p>이럴 때 편의 메소드와 Cascade 타입 PERSIST 이용하면 보다 이러한 문제를 해결 할 수 있습니다.</p><h3><span id="편의-메소드">편의 메소드</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delivery</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLog</span><span class="params">(DeliveryStatus status)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.logs.add(DeliveryLog.builder()</div><div class="line">                .status(status)</div><div class="line">                .delivery(<span class="keyword">this</span>) <span class="comment">// this를 통해서 Delivery를 넘겨준다.</span></div><div class="line">                .build());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeliveryLog</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeliveryLog</span><span class="params">(<span class="keyword">final</span> DeliveryStatus status, <span class="keyword">final</span> Delivery delivery)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.delivery = delivery;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeliveryService</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Delivery <span class="title">create</span><span class="params">(DeliveryDto.CreationReq dto)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Delivery delivery = dto.toEntity();</div><div class="line">        delivery.addLog(DeliveryStatus.PENDING);</div><div class="line">        <span class="keyword">return</span> deliveryRepository.save(delivery);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Delivery가 시작되면 DeliveryLog는 반드시 PENDDING이어야 한다고 가정했을 경우 편의 메소드를 이용해서 두 객체에 모두 필요한 값을 바인딩시켜줍니다.</p><h3><span id="casecade-persist-설정">CaseCade PERSIST 설정</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// cascade 없는 경우</div><div class="line">Hibernate: <span class="keyword">insert</span> <span class="keyword">into</span> delivery (<span class="keyword">id</span>, address1, address2, zip, created_at, update_at) <span class="keyword">values</span> (<span class="literal">null</span>, ?, ?, ?, ?, ?)</div><div class="line"></div><div class="line">// <span class="keyword">cascade</span> PERSIST 설정 했을 경우</div><div class="line">Hibernate: <span class="keyword">insert</span> <span class="keyword">into</span> delivery (<span class="keyword">id</span>, address1, address2, zip, created_at, update_at) <span class="keyword">values</span> (<span class="literal">null</span>, ?, ?, ?, ?, ?)</div><div class="line">Hibernate: <span class="keyword">insert</span> <span class="keyword">into</span> delivery_log (<span class="keyword">id</span>, created_at, update_at, delivery_id, <span class="keyword">status</span>) <span class="keyword">values</span> (<span class="literal">null</span>, ?, ?, ?, ?)</div></pre></td></tr></table></figure><p>CaseCade PERSIST을 통해서 Delivery 엔티티에서 DeliveryLog를 생성할수 있게 설정합니다. CaseCade PERSIST가 없을 때 실제 객체에는 저장되지만, 영속성 있는 데이터베이스에 저장에 필요한 insert query가 동작하지 않습니다.</p><p><strong>JPA를 잘활용하면 도메인의 의도가 분명하게 들어나도록 개발할 수 있다는 것을 강조드리고 싶습니다.</strong></p><h2><span id="고아-객체-orphanremoval">고아 객체 (orphanRemoval)</span></h2><p>JPA는 부모 엔티티와 연관 관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체 제거라 합니다. 이 기능을 사용해서 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제 돼서 개발의 편리함이 있습니다.</p><h3><span id="deliverylog-삭제">DeliveryLog 삭제</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Delivery <span class="title">removeLogs</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Delivery delivery = findById(id);</div><div class="line">    delivery.getLogs().clear(); <span class="comment">// DeloveryLog 전체 삭제</span></div><div class="line">    <span class="keyword">return</span> delivery; <span class="comment">// 실제 DeloveryLog 삭제 여부를 확인하기 위해 리턴</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// <span class="keyword">delete</span> <span class="keyword">SQL</span></div><div class="line">Hibernate: <span class="keyword">delete</span> <span class="keyword">from</span> delivery_log <span class="keyword">where</span> <span class="keyword">id</span>=?</div></pre></td></tr></table></figure><p>Delivery 객체를 통해서 DeliveryLog를 위처럼 직관적으로 삭제 할 수 있습니다. 이 처럼 직관적으로 그 의도가 드러나는 장점이 있다고 생각합니다.</p><h3><span id="delivery-삭제">Delivery 삭제</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</div><div class="line">    deliveryRepository.delete(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// <span class="keyword">delete</span> <span class="keyword">SQL</span></div><div class="line">Hibernate: <span class="keyword">delete</span> <span class="keyword">from</span> delivery_log <span class="keyword">where</span> <span class="keyword">id</span>=?</div><div class="line">Hibernate: <span class="keyword">delete</span> <span class="keyword">from</span> delivery <span class="keyword">where</span> <span class="keyword">id</span>=?</div></pre></td></tr></table></figure><p>delivery, deliverylog 참조 관계를 맺고 있어 Delivery만 삭제할 수 없습니다. delete SQL을 보시다시피 delivery_log 부터 제거 이후 delivery를 제거하는 것을 알 수 있습니다. 이처럼 orphanRemoval 속성으로 더욱 쉽게 삭제 할 수 있습니다.</p><h3><span id="orphanremoval-설정이-없는-경우">orphanRemoval 설정이 없는 경우</span></h3><p>DeliveryLog 삭제 같은 경우에는 실제 객체에서는 clear() 메서드로 DeliveryLog가 삭제된 것처럼 보이지만 영속성 있는 데이터를 삭제하는 것은 아니기에 해당 Delivery를 조회하면 DeliveryLog가 그대로 조회됩니다. 실수하기 좋은 부분이기에 반드시 삭제하고 조회까지 해서 데이터베이스까지 확인하시는 것을 권장해 드립니다.</p><p><img src="https://i.imgur.com/bPhMX9e.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// erorr log</div><div class="line">o.h.engine.jdbc.spi.SqlExceptionHelper   : Referential integrity constraint violation: &quot;FKFS49KM0EA809MTH3OQ4S6810H: PUBLIC.DELIVERY_LOG FOREIGN KEY(DELIVERY_ID) REFERENCES PUBLIC.DELIVERY(ID) (1)&quot;; SQL statement:</div></pre></td></tr></table></figure><p>위에서 언급했듯이 delivery를 삭제하려면 참조 하는 deliverylog 먼저 삭제를 진행 해야 합니다. orphanRemoval 설정이 없는 경우 그 작업을 선행하지 않으니 위 같은 에러가 발생하게 됩니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/spring-jpa-best-practices&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Best Practices" scheme="https://cheese10yun.github.io/tags/Best-Practices/"/>
    
  </entry>
  
  <entry>
    <title>Github로 프로젝트 관리하기 Part2</title>
    <link href="https://cheese10yun.github.io/github-proejct-part2/"/>
    <id>https://cheese10yun.github.io/github-proejct-part2/</id>
    <published>2018-07-13T15:00:00.000Z</published>
    <updated>2018-07-17T13:48:26.576Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="프로젝트-소개">프로젝트 소개</span></h1><p>Github를 이용해서 Project Management 하는 방법 및 전체적인 프로세스에 대해서 정리했습니다. <strong>issue 관리, 일정 관리, 코드리뷰, 버그 리포트 등 다양한 일들을 Github 하나에서 다 관리할 수 있고 어느 하나 부족하다고 생각하지 않습니다.</strong> 이미 Remote Repository로 Github를 사용 중 이리 사면 적극 추천해 드립니다.</p><h1><span id="ci-amp-test-coverage">CI &amp; Test Coverage</span></h1><p><img src="https://i.imgur.com/G5jo0Ty.png" alt=""></p><p><a href="https://github.com/marketplace/category/continuous-integration" rel="external nofollow noopener noreferrer" target="_blank">GitHub Marketplace</a> Public Repository를 이용하면 대부분 무료로 이용 가능합니다. <strong>본 포스팅에서는  CI는 Travis CI, Test Coverage는 Coveralls를 이용해서 진행하겠습니다.</strong></p><p>전체적인 플로우를 설명하는 것이 목적 이리서 특정 툴에 대한 직접적인 사용법을 다루지는 않겠습니다. 언어의 특성 및 개인에 기호에 맞는 제품을 사용하시면 됩니다.</p><h2><span id="전체-플로우">전체 플로우</span></h2><ol><li>Pull Request 요청 -&gt; Code Review 진행</li><li>Code Review 완료 -&gt; 특정 Branch에 반영</li><li>특정 Branch 수정시 자동 CI Build 작업 진행 -&gt; 테스트 코드 실행</li><li>테스트 커버지리 표시</li></ol><h2><span id="pull-request-amp-code-review">Pull Request &amp; Code Review</span></h2><p><img src="https://i.imgur.com/q6HmT7o.png" alt=""></p><p>별다른 설정을 하지 않았다면 Pull Request를 요청할 경우 Travis에서 자동으로 해당 요청한 코드 기반으로 Build 작업이 진행됩니다. Build가 실패했을 경우는 Pull Request 요청자는 코드를 수정해서 최소한 Build가 된 코드 기반으로 Code Review를 진행하게 해야 됩니다(Build도 안 되는 코드를 리뷰할 이유는 없을 거 같습니다.)</p><p>요청받은 Pull Request에 대해서 Code Review 작업을 진행하게 됩니다. Code Review가 완료되면 Merge pull request를 통해서 해당 작업(issue)을 반영합니다.</p><h2><span id="테스트-커버지리-표시">테스트 커버지리 표시</span></h2><p><img src="https://i.imgur.com/U1ROYeE.png" alt=""></p><p>위에서 Merge pull request를 통해서 해당 작업(issue)을 반영했다면 Travis가 Build 할 때 작성된 Test Code 기반으로 Coverage 정보를 위처럼 자동으로 코멘드를 추가해줍니다.</p><p>누군가가 테스트 코드를 작성하지 않았다면 <code>Change from base</code> 항목에서 - 표시가 됩니다. <strong>이렇게 해당 작업마다 커버리지를 표시하는 것이 전체 커버리지를 높이고 그 값을 유지하는 좋은 방법이라고 생각합니다.</strong></p><h1><span id="wiki">Wiki</span></h1><p>GitHub에서는 기본적인 WIKI 기능을 제공해줍니다.</p><h2><span id="wiki-등록">Wiki 등록</span></h2><p><img src="https://github.com/cheese10yun/github/blob/master/images/wiki.gif?raw=true" alt=""></p><h2><span id="github-작성">GitHub 작성</span></h2><p><img src="https://i.imgur.com/t3LuQsm.png" alt=""><br>GitHub에서 위키를 작성할 수 있습니다.</p><h2><span id="local-작성">Local 작성</span></h2><p><img src="https://i.imgur.com/Ff6Heeb.png" alt=""><br><strong>위키를 로컬환경에서 작성해서 Push 할 수 있습니다. 이렇게 사용하시는 것을 추천 드립니다.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;프로젝트-소개&quot;&gt;프로젝트 소개&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;Github를 이용해서 Project Management 하는 방법 및 전체적인 프로세스에 대해서 정리했습니다. &lt;strong&gt;issue 관리, 일정 관리, 코드리뷰, 
      
    
    </summary>
    
    
      <category term="Github" scheme="https://cheese10yun.github.io/tags/Github/"/>
    
      <category term="Issue" scheme="https://cheese10yun.github.io/tags/Issue/"/>
    
      <category term="Proejct Management" scheme="https://cheese10yun.github.io/tags/Proejct-Management/"/>
    
  </entry>
  
  <entry>
    <title>Jackson 어노테이션 총 정리</title>
    <link href="https://cheese10yun.github.io/jackson-annotation-final/"/>
    <id>https://cheese10yun.github.io/jackson-annotation-final/</id>
    <published>2018-07-08T10:00:00.000Z</published>
    <updated>2018-07-08T10:03:55.914Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//www.slideshare.net/slideshow/embed_code/key/3bcVswknGqlE8u" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/ssuser565d51/jackson-104816215" title="Jackson 사용법" target="_blank">Jackson 사용법</a> </strong> from <strong><a href="https://www.slideshare.net/ssuser565d51" target="_blank" rel="external nofollow noopener noreferrer">남윤 김</a></strong> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/3bcVswknGqlE8u&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginhe
      
    
    </summary>
    
    
      <category term="Jackson" scheme="https://cheese10yun.github.io/tags/Jackson/"/>
    
      <category term="Slideshare" scheme="https://cheese10yun.github.io/tags/Slideshare/"/>
    
  </entry>
  
  <entry>
    <title>Github로 프로젝트 관리하기 Part1</title>
    <link href="https://cheese10yun.github.io/github-proejct/"/>
    <id>https://cheese10yun.github.io/github-proejct/</id>
    <published>2018-07-08T08:13:46.000Z</published>
    <updated>2018-07-14T10:32:04.300Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="프로젝트-소개">프로젝트 소개</span></h1><p>Github를 이용해서 Project Management 하는 방법 및 전체적인 프로세스에 대해서 정리했습니다. <strong>issue 관리, 일정 관리, 코드리뷰, 버그 리포트 등 다양한 일들을 Github 하나에서 다 관리할 수 있고 어느 하나 부족하다고 생각하지 않습니다.</strong> 이미 Remote Repository로 Github를 사용 중 이리 사면 적극 추천해 드립니다.</p><p>프로젝트는 지속해서 추가될 예정이라 상단의 전체 사용법은 <a href="https://github.com/cheese10yun/github" rel="external nofollow noopener noreferrer" target="_blank">Github</a>에서 확인하실 수 있습니다.</p><h1><span id="목차">목차</span></h1><!-- TOC --><ul><li><a href="#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%86%8C%EA%B0%9C">프로젝트 소개</a></li><li><a href="#%EB%AA%A9%EC%B0%A8">목차</a></li><li><a href="#%EC%A0%84%EC%B2%B4-%ED%94%8C%EB%A1%9C%EC%9A%B0">전체 플로우</a><ul><li><a href="#issue-%EB%B0%9C%ED%96%89">Issue 발행</a><ul><li><a href="#issue%EB%9E%80">Issue란?</a></li><li><a href="#issue-template">Issue Template</a><ul><li><a href="#issue-template-%EB%93%B1%EB%A1%9D">Issue Template 등록</a></li><li><a href="#issue-template-%EC%82%AC%EC%9A%A9%EB%B2%95">Issue Template 사용법</a></li><li><a href="#issue-template-%ED%8C%8C%EC%9D%BC">Issue Template 파일</a></li></ul></li></ul></li><li><a href="#issue-%EC%9E%91%EC%97%85">Issue 작업</a><ul><li><a href="#%EB%93%B1%EB%A1%9D%EB%90%9C-issue-%EC%82%B4%ED%8E%B4-%EB%B3%B4%EA%B8%B0">등록된 issue 살펴 보기</a></li><li><a href="#issue-%EC%97%B0%EB%8F%99">Issue 연동</a></li><li><a href="#issue-%EA%B8%B0%EB%B0%98-bracnh-%EC%83%9D%EC%84%B1">Issue 기반 Bracnh 생성</a></li></ul></li><li><a href="#pull-requestcode-review">Pull Request[Code Review]</a><ul><li><a href="#jetbrains-pull-request">Jetbrains Pull Request</a></li><li><a href="#github-pull-request">GitHub Pull Request</a></li><li><a href="#pull-request-%EC%9E%91%EC%84%B1%EB%B2%95">Pull Request 작성법</a></li><li><a href="#code-review">Code Review</a></li></ul></li></ul></li><li><a href="#%EC%84%B8%EB%B6%80-%EC%82%AC%EC%9A%A9%EB%B2%95">세부 사용법</a></li><li><a href="#zenhub-%EC%82%AC%EC%9A%A9%EB%B2%95">ZenHub 사용법</a></li><li><a href="#code-coverage">Code Coverage</a></li></ul><!-- /TOC --><h1><span id="전체-플로우">전체 플로우</span></h1><ol><li>Isuee 발급</li><li>Issue 작업</li><li>Pull Request Coide Review 진행</li><li>Issue 반영</li></ol><h2><span id="issue-발행">Issue 발행</span></h2><h3><span id="issue란">Issue란?</span></h3><p>모든것이 이슈라고 볼 수 있습니다. 새로운 추가될 가능, 개선 해야할 가능, 버그 등등 모든것이 이슈라고 볼 수 있습니다. 모든 활동 내역에 대해서 이슈를 등록하고 그 이슈기반으로 작업을 진행하게 됩니다.</p><p>이슈를 등록할 때 자주 사용하는 템플릿을 등록해서 사용하는 방법이 효율적입니다. 이슈 템플릿을 등록하는 방법을 소개해드리겠습니다.</p><h3><span id="issue-template">Issue Template</span></h3><h4><span id="issue-template-등록">Issue Template 등록</span></h4><p><img src="https://github.com/cheese10yun/github/blob/master/images/issue-template-rg.gif?raw=true" alt=""></p><p>환경에 앎맞는 Issue Template 생성을 합니다.</p><h4><span id="issue-template-사용법">Issue Template 사용법</span></h4><p><img src="https://github.com/cheese10yun/github/blob/master/images/add-new-issue.gif?raw=true" alt="new_issue"></p><p>위에서 등록한 Issue Template 기반으로 이슈를 생성할 수 있습니다.</p><h4><span id="issue-template-파일">Issue Template 파일</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── .github</div><div class="line">│   └── ISSUE_TEMPLATE</div><div class="line">│       ├── bug_report.md</div><div class="line">│       └── feature_request.md</div><div class="line">├── README.md</div><div class="line">├── github.iml</div><div class="line">├── images</div><div class="line">├── mvnw</div><div class="line">├── mvnw.cmd</div><div class="line">├── pom.xml</div><div class="line">└── src</div></pre></td></tr></table></figure><p>위에서 등록된 Issue Template은 .github/ISSUE_TEMPLATE 디렉터리에 생성된 것을 확인할 수 있습니다.<br><strong>각자의 맞는 한경에 따라서 Issue Template를 작성하시면 됩니다.</strong> 저 같은 경우에는 Back-end를 주로 담당하기 때문에 bug tempalte 에서 서버로그, response body 값을 등록했습니다.</p><h2><span id="issue-작업">Issue 작업</span></h2><h3><span id="등록된-issue-살펴-보기">등록된 issue 살펴 보기</span></h3><p><img src="https://i.imgur.com/2ciNoCd.png" alt="등록된-이슈"></p><ul><li>Assignees : 해당 작업의 담당자</li><li>Labels: 해당 작업의 성격</li><li>Milestone: 해당 작업이 속한 파트</li></ul><p><img src="https://i.imgur.com/DkniJHn.png" alt=""></p><p>다른 것들은 이해하기 쉬울 텐데 Milestone은 조금 생소할 수 있습니다. Milestone에 간단하게 설명해 드리면 이번 출시 버전이 1.0.0 일 경우 해당 버전이든 이슈(작업) 기능 강화, 새 기능추가, 버그 기타 등등 모든 이슈를 Version 1.0.0 Milestone이라는 항목에 추가하면 위 그림처럼 Version 1.0.0에 대한 전체적인 상황을 한눈에 볼 수가 있는 장점이 있습니다.</p><h3><span id="issue-연동">Issue 연동</span></h3><p><img src="https://i.imgur.com/FtO0Xme.png" alt="intellij-task"></p><p>만약 Jetbrains의 IDE를 사용하고 계신다면 Task 연동을 통해서 Github와 연동하시는 것을 적극 권장해 드립니다.</p><h3><span id="issue-기반-bracnh-생성">Issue 기반 Bracnh 생성</span></h3><p><img src="https://i.imgur.com/R8aFoCL.png" alt="issue-base-branch"><br>위에서 언급한 Jetbrains의 Task 연동을 하지 않아도 크게 상관없습니다. Task의 갖는 가장 큰 기능은 Github 이슈 기반으로 Branch를 생성을 쉽게 도와주는 것으로 생각합니다. <strong>즉 Github에서 생성된 Issue 기반으로 Branch를 생성하는 것이 핵심입니다.</strong></p><p>Github Issue는 각자의 유니크한 값인 Issue Number를 갖습니다. 또 그 Iusse Number 기반으로 Branch를 이름을 갖게 하여 해당 Branch의 명확한 작업의 의도를 갖게 할 수 있습니다.</p><p>Branch 네이밍을 통해서 해당 작업의 의도를 갖게 하는 것은 한계가 있습니다. 또 동료 개발자들이 정확히 무슨 작업을 하는지도 Branch 네이밍을 통해서 유추해내기도 어렵고, 해당 작업이 반영(머지)될 때 도 마찬가지입니다. 이러한 문제들을 Issue Number 기반으로 Branch를 생성(Issue Number Branch 네이밍에 추가)하면 아주 명확해집니다.</p><h2><span id="pull-requestcode-review">Pull Request[Code Review]</span></h2><p><a href="https://github.com/cheese10yun/github/issues/1" rel="external nofollow noopener noreferrer" target="_blank">issue-1</a>에 대한 풀리퀘스트를 통해서 코드리뷰를 진행해 보겠습니다.</p><h3><span id="jetbrains-pull-request">Jetbrains Pull Request</span></h3><p><img src="https://i.imgur.com/vkNR06g.png" alt="intellij-pull-request"><br>만약 Jetbrains IDE를 사용하신다면 위 방법 처럼 Pull Request를 하는 방법을 권장드립니다.</p><h3><span id="github-pull-request">GitHub Pull Request</span></h3><p><img src="https://i.imgur.com/6bBTJUV.png" alt="github-pull-request"></p><p>Github Code 텝에서 <code>New Pull Request</code> 버튼을 클릭해서 Pull Request를 진행 합니다.</p><h3><span id="pull-request-작성법">Pull Request 작성법</span></h3><p><img src="https://i.imgur.com/3TnHt0c.png" alt=""></p><ul><li>왼쪽 위에 Reviewers 톱니바퀴 버튼을 클릭해서 리뷰어를 지정합니다.</li><li>resolved: #1(해당 Issue Number) 풀리퀘스트 요청하는 이유 즉 무슨 이슈에 대한 작업인지 명시합니다.</li></ul><p><code>resolved</code> 키워드를 입력하면 해당 풀리퀘스트가 master Branch에 반영되면 자동으로 close 됩니다. 자동으로 close 되는 것이 싫으시다면 issue: #[해당 Issue Number]를 작성해주세요.</p><p>이렇게 Pull Request가 생성되면 새로운 Issue Number가 부여됩니다. <strong>즉 Pull Request도 Issue입니다.</strong></p><p><img src="https://i.imgur.com/skNmpeQ.png" alt="issue-pull-request-연결"></p><p><strong>반드시 해당 풀리퀘스트가 무슨 이슈에 따른 요청인지 명시하시는 것을 권장합니다.</strong> 그렇게 되면 위 그림처럼 해당 이슈에 #2[방금 요청한 풀리퀘스트]가 연결되어 해당 이슈가 무슨 코드로 인해서 진행됐는지 추적하기 좋습니다.</p><h3><span id="code-review">Code Review</span></h3><p>리뷰어가 요청받은 Pull Request로 가서 <code>Add your review</code> 버튼을 클릭합니다.</p><p><img src="https://i.imgur.com/k11vL5w.png" alt="리뷰진행"><br>소스코드에 대한 질문 등 다양한 comment를 남기는 방식으로 pull reqeust가 진행합니다.</p><ul><li>Approve: 코드에 대한 의문점이 없다면 승인 .</li><li>Comment: 간단한 피드백 제출</li><li>Request changes: 해당 코드에 문제가 있다고 판단되며 코드를 반드시 수정 요구</li></ul><p>위 항목은 Comment로 Submit review를 진행했습니다.</p><p><img src="https://i.imgur.com/EHnVEjU.png" alt="comment-표시"><br>위에서 작성한 comment가 해결됬었다면 <code>Merge pull request</code> 버튼을 눌러서 해당 pull request를 반영합니다. 반영이 완료되고 해당 branch가 더는 필요 없다고 판단되시면 <code>Delete branch</code> 버튼을 통해서 Remote에 있는 Branch를 삭제할 수 있습니다.</p><p><strong>위에서 작성한 resolved: #1 키워드 덕분에 소스코드가 해당 Branch에 적용됐으니 자동으로 #1에 대한 이슈는 close 처리됩니다.</strong></p><h1><span id="세부-사용법">세부 사용법</span></h1><ul><li>추가 예정</li></ul><h1><span id="zenhub-사용법">ZenHub 사용법</span></h1><ul><li>추가 예정</li></ul><h1><span id="code-coverage">Code Coverage</span></h1><ul><li>추가 예정</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;프로젝트-소개&quot;&gt;프로젝트 소개&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;Github를 이용해서 Project Management 하는 방법 및 전체적인 프로세스에 대해서 정리했습니다. &lt;strong&gt;issue 관리, 일정 관리, 코드리뷰, 
      
    
    </summary>
    
    
      <category term="Github" scheme="https://cheese10yun.github.io/tags/Github/"/>
    
      <category term="Issue" scheme="https://cheese10yun.github.io/tags/Issue/"/>
    
      <category term="Proejct Management" scheme="https://cheese10yun.github.io/tags/Proejct-Management/"/>
    
  </entry>
  
  <entry>
    <title>Spring OOP 프로그래밍 예제(5) - 외부 API(PagerDuty) 호출</title>
    <link href="https://cheese10yun.github.io/spring-oop-05/"/>
    <id>https://cheese10yun.github.io/spring-oop-05/</id>
    <published>2018-07-05T15:00:00.000Z</published>
    <updated>2018-07-07T15:18:52.937Z</updated>
    
    <content type="html"><![CDATA[<p>예제 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/pagerduty" rel="external nofollow noopener noreferrer" target="_blank">Github : blog-sample</a>에 공개 되어 있습니다.</p><h1><span id="외부-apipagerduty-호출">외부 API(PagerDuty) 호출</span></h1><p>최근 외부 API를 통신하는 일들이 많이 있었고 최근 PagerDuty API 작업을 하면서 외부 API를 사용할 때 많은 시행착오와 고민을 나름 정리해 보았습니다.</p><h2><span id="pagerduty-request">PagerDuty Request</span></h2><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"routing_key"</span>: <span class="string">"routing_key..."</span>,</div><div class="line">    <span class="attr">"event_action"</span>: <span class="string">"only trigger, acknowledge, resolve"</span>,</div><div class="line">    <span class="attr">"images"</span>: [],</div><div class="line">    <span class="attr">"links"</span>: [],</div><div class="line">    <span class="attr">"payload"</span>: &#123;</div><div class="line">        <span class="attr">"summary"</span>: <span class="string">"summary...(string)"</span>,</div><div class="line">        <span class="attr">"source"</span>: <span class="string">"System..."</span>,</div><div class="line">        <span class="attr">"severity"</span>: <span class="string">"only critical, error, warning, info"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2><span id="pagerduty-response">PagerDuty Response</span></h2><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"status"</span>: <span class="string">"success"</span>,</div><div class="line">  <span class="attr">"message"</span>: <span class="string">"Event processed"</span>,</div><div class="line">  <span class="attr">"dedup_key"</span>: <span class="string">"samplekeyhere"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="https://v2.developer.pagerduty.com/docs/send-an-event-events-api-v2" rel="external nofollow noopener noreferrer" target="_blank">PagerDuty Document</a>에 나와 있는 Request, Response를 JSON으로 정리했습니다. Request 값은 필수 값 위주로 정리했습니다.</p><h2><span id="request-response-class">Request, Response Class</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"event_action"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventAction eventAction;</div><div class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"routing_key"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String routingKey = <span class="string">"routingKey..."</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Payload payload;</div><div class="line"></div><div class="line">    <span class="meta">@Builder</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(<span class="keyword">final</span> EventAction eventAction, <span class="keyword">final</span> Payload payload)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.eventAction = eventAction;</div><div class="line">        <span class="keyword">this</span>.payload = payload;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Payload</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String summary;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String timestamp = ZonedDateTime.now().toOffsetDateTime().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Severity severity;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Group group;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Source source;</div><div class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"custom_details"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object customDetails;</div><div class="line"></div><div class="line">    <span class="meta">@Builder</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Payload</span><span class="params">(<span class="keyword">final</span> String summary, <span class="keyword">final</span> Severity severity, <span class="keyword">final</span> Group group, <span class="keyword">final</span> Source source, <span class="keyword">final</span> Object customDetails)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.summary = summary;</div><div class="line">        <span class="keyword">this</span>.severity = severity;</div><div class="line">        <span class="keyword">this</span>.group = group;</div><div class="line">        <span class="keyword">this</span>.source = source;</div><div class="line">        <span class="keyword">this</span>.customDetails = customDetails;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String status;</div><div class="line">    <span class="keyword">private</span> String message;</div><div class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"dedup_key"</span>)</div><div class="line">    <span class="keyword">private</span> String dedupKey;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3><span id="request-response에-대한-dto-클래스-생성">Request, Response에 대한 DTO 클래스 생성</span></h3><p>위의 JSON을 클래스로 바인딩시킬 DTO 클래스를 생성해서 API에 대한 Request, Response를 관리하는 것이 바람직합니다. 간혹 Map, JSON(gsoon, jackson) 등을 이용해서 유연하게 두는 예도 있지만 <strong>저는 개인적으로 권장하지 않습니다.</strong> 가장 큰 이유는 해당 값에 무슨 데이터가 있는지 확인하기 어렵습니다. 코드 가독성이 심각하게 떨어지며 정확히 어떤 자료형인지 확인하기도 어렵습니다. 또 @JsonProperty를 통해서 해당 실제 JSON 키값과 객체의 멤버 필드 값을 다르게 설정 할 수 있습니다.</p><h3><span id="setter를-사용하지-않기">Setter를 사용하지 않기</span></h3><p>이전 포스팅에서도 <a href="https://github.com/cheese10yun/spring-jpa-best-practices/blob/master/doc/step-06.md" rel="external nofollow noopener noreferrer" target="_blank">Setter 사용하지 않기</a>를 언급한 적이 있습니다. Response DTO 클래스 같은 경우는 더욱 Setter를 제공할 필요가 없지만, 관습적으로 Setter 메서드를 추가하는 경우가 많습니다. <strong>해당 객체를 어디서든지 변경이 가능한 객체가 되기 때문에 명확한 이유 없이 관습적인 Setter는 반드시 지양 해야 합니다.</strong></p><p>반면 Request 객체는 필요한 값을 바인딩시켜 보내줘야 합니다. 이러한 경우는 Builder 패턴을 이용해서 객체를 생성하면 많은 장점이 있습니다. 제가 느끼는 대표적인 장점들 아래와 같습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PagerDutyDto.Request.builder()</div><div class="line">    .eventAction(PagerDutyDto.EventAction.acknowledge)</div><div class="line">    .payload(Payload ...)</div><div class="line">    .build();</div></pre></td></tr></table></figure><ol><li>인자의 순서에 영향 받지 않습니다. 생성자로 생성했을 경우 인자의 순서가 중요하며, 특히 같은 자료형에 대한 인자는 실수할 수 있는 여지가 높습니다.</li><li><strong>Setter 메서드가 없어 변경 불가능 객체를 만들 수 있습니다.</strong></li></ol><p>그렇다면 객체의 수정이 필요 하면 어떻게 어떻게 해야 할까요?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String email;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeEmail</span><span class="params">(String email)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.email = email;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>객체의 멤버필드를 수정 할 수 있는 수정 메소드를 재공 해주면 됩니다. 단순하게 setter라는 네이밍으로 공개하는 것보다 해당 메소드의 기능을 잘 표현하는 네이밍을 갖는 것이 적합합니다. 더 구체적인 내용은 이전 포스팅 <a href="https://github.com/cheese10yun/spring-jpa-best-practices/blob/master/doc/step-06.md#updatemyaccount-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8" rel="external nofollow noopener noreferrer" target="_blank">Settet 사용하지 않기</a>에 정리 되어 있습니다.</p><h2><span id="enum을-활용한-안전성-보장">Enum을 활용한 안전성 보장</span></h2><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"event_action"</span>: <span class="string">"only trigger, acknowledge, resolve"</span>,</div><div class="line">    <span class="attr">"payload"</span>: &#123;</div><div class="line">        <span class="attr">"severity"</span>: <span class="string">"only critical, error, warning, info"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PagerDuty API event_action, payload.severity 의 value는 위에서 정의한 값 이외의 값이 넘어오면 status 400이 리턴 됩니다. 이러한 값들에 대해서는 아래 코드처럼 enum 클래스로 안전성을 확보하는 것이 바람직합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EventAction &#123;</div><div class="line">    trigger, acknowledge, resolve</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Severity &#123;</div><div class="line">    info, error, warn</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>String으로 관리할 경우 해당 값 이외의 입력에 대한 예외코드를 작성하면 런타임시에 발생하게 됩니다. enum 클래스로 관리했을 경우 개발자는 해당 enum 값이 외에는 값을 넣을 수도 없게끔 강제하는 것이 실수를 줄이는 방법입니다. String은 변경 및 유지 보수에 취약합니다. 이처럼 API에서 강제된 항목들은 enum 클래스로 관리하는 것이 바람직합니다.</p><h2><span id="각각의-메소드에-책임-부여">각각의 메소드에 책임 부여</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendErrorMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 적절한 Error Message를 가공하는 책임</span></div><div class="line">    <span class="comment">// 해당 메소드의 변경시 이유는 Error Message의 변경시에만 변경 이유를 갖는다</span></div><div class="line">    <span class="keyword">final</span> PagerDutyDto.Request request = buildErrorMessage();</div><div class="line">    send(request);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfoMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 적절한 Info Message를 가공하는 책임</span></div><div class="line">    <span class="comment">// 해당 메소드의 변경시 이유는 Info Message의 변경시에만 변경 이유를 갖는다</span></div><div class="line">    <span class="keyword">final</span> PagerDutyDto.Request request = buildInfoMessage();</div><div class="line">    send(request);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> PagerDutyDto.<span class="function">Response <span class="title">send</span><span class="params">(<span class="keyword">final</span> PagerDutyDto.Request request)</span> </span>&#123;</div><div class="line">    <span class="comment">// 넘겨 받은 request를 PagerDuty 에게 보내는 책임</span></div><div class="line">    <span class="comment">// 해당 메소드의 변경시 이유는 PagerDuty API 변경시만 변경 이유를 갖는다. -&gt; Request, Response 변경이 대표적인 예</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">final</span> String url = <span class="string">"https://events.pagerduty.com/v2/enqueue"</span>;</div><div class="line">        <span class="keyword">return</span> restTemplate.postForObject(url, request, PagerDutyDto.Response.class);</div><div class="line">    &#125; <span class="keyword">catch</span> (HttpClientErrorException e) &#123;</div><div class="line">        log.error(e.getResponseBodyAsString(), e);</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>클린 코드 출처</p><p><strong>작게 만들어라!</strong></p><p>함수를 만드는 첫 번째 규칙은 '작게!'다. 함수를 만드는 둘째 규칙은 '더 작게!'다. …중략<br><strong>한 가지만 해라!</strong></p><p>함수는 한 가지를 해야 한다. 그 한 가지를 잘해야 한다. 그 한 가지만을 해야 한다. … 중략</p></blockquote><p><strong>클린 코드에서 언급했듯이 함수의 기본단위는 정말 작아야 한다고 생각합니다. 그래야 재사용성이 높아지며 가독성, 유지보수에 좋은 코드가 된다고 생각합니다.</strong></p><p>sendErrorMessage() 메소드는 적절하게 Error Message를 만들어서 send 메소드에게 전달해주는 것이 그 함수가 하는 일입니다. 함수의 크기가 작으며 적은 일을 수행하고 있습니다.</p><p>send() 메소드도 넘겨받은 request값을 PagerDutry API 에게 요청하고 그에 따른 응답값을 받는 일만 합니다. 그렇게 된 결과 sendInfoMessage() 메서드에서도 재사용성이 높아지고, 해당 함수가 하는 일이 단순해져서 가독성이 높아집니다. 또 위에서도 언급했듯이 PagerDuty API 변경시에만 해당 메소드가 변경됩니다. 그런 결과 유지 보수하기 편한 이점이 있다고 생각합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;예제 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/pagerduty&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="OOP" scheme="https://cheese10yun.github.io/tags/OOP/"/>
    
  </entry>
  
</feed>
