<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yun Blog</title>
  <icon>https://www.gravatar.com/avatar/d313a2c442931458ed624a3999d75011</icon>
  <subtitle>기술 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://cheese10yun.github.io/"/>
  <updated>2020-03-04T13:45:40.135Z</updated>
  <id>https://cheese10yun.github.io/</id>
  
  <author>
    <name>Yun</name>
    <email>cheese10yun@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JPA 기반 테스트 코드 작성 팁</title>
    <link href="https://cheese10yun.github.io/jpa-test-support/"/>
    <id>https://cheese10yun.github.io/jpa-test-support/</id>
    <published>2020-02-29T15:00:00.000Z</published>
    <updated>2020-03-04T13:45:40.135Z</updated>
    
    <content type="html"><![CDATA[<p>JPA 기반으로 테스트 코드를 작성하면서 불편했던 부분을 소개하고 해결 방법에 관한 포스팅입니다.</p><h2><span id="jpa-기반-테스트-불편한-점">JPA 기반 테스트 불편한 점</span></h2><h3><span id="과도한-dependency">과도한 Dependency</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paymentRepository: PaymentRepository,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> memberRepository: MemberRepository,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> orderRepository: OrderRepository</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `특정 테스트를 하기위해서는 외부 dependency가 필요하다`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 특정 테스트를 하기 위해서 많은 디펜던시가 필요하다.</span></span><br><span class="line">        paymentRepository.save(Payment(BigDecimal.TEN))</span><br><span class="line">        memberRepository.save(Member(<span class="string">"username"</span>, <span class="number">10</span>, Team(<span class="string">"team-name"</span>)))</span><br><span class="line">        orderRepository.save(Order(BigDecimal.TEN))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>많은 디펜던시가 필요한 부분의 테스트 코드를 작성할 때는 많은 Repository를 주입 받아서 테스트를 진헹 해야합니다. 위 코드처럼 특정 구간의 서비스를 테스트하기 위해서는 <code>Given</code>절을 작성할 때 흔하게 발생합니다.</p><p>물론 테스트 코드이기 때문에 DI 받아야하는 항목들이 많아지는것이 상대적으로 문제가 크게 발생하지는 않지만 코드 양이 많이 발생하는 문제가 있습니다.</p><h3><span id="검증이-필요한데">검증이 필요한데 ?..</span></h3><p>무엇보다 큰 문제가 해당 테스트의 <code>Then</code>절에 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `특정 테스트를 하기위해서는 외부 dependency가 필요하다`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 특정 테스트를 하기 위해서 많은 디펜던시가 필요하다.</span></span><br><span class="line">    paymentRepository.save(Payment(BigDecimal.TEN))</span><br><span class="line">    memberRepository.save(Member(<span class="string">"username"</span>, <span class="number">10</span>, Team(<span class="string">"team-name"</span>)))</span><br><span class="line">    orderRepository.save(Order(BigDecimal.TEN))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 특정 서비스가 여러 entity rows를 변경할때 아래와 같은 조회로 Then 이어가야 합니다.</span></span><br><span class="line">    <span class="comment">// paymentRepository.findBy... epository 메서드는 없는데??...</span></span><br><span class="line">    <span class="comment">// memberRepository.findBy...</span></span><br><span class="line">    <span class="comment">// orderRepository.findBy...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당 서비스의 코드가 여러 enttiy의 여러 row의 변경을 가할 때 <code>Then</code>절에서 검증을 진행할 때 문제가 발생합니다. 해당 조회 코드가 없는 경우 <strong>오직 테스트를 위해서만 조회용 코드를 일반 코드에 작성해야 합니다.</strong> 그렇지 않다면 <strong>Test Scope에서 사용할 Repository를 따로 작성해야 합니다.</strong></p><p>두 방식 모두 좋은 해결 방법이 아니라고 생각합니다.</p><h2><span id="해결-방법">해결 방법</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(<span class="meta-string">"test"</span>)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootTestSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> entityManagerFactory: EntityManagerFactory</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> query: JPAQueryFactory</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> entityManager: EntityManager <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        entityManagerFactory.createEntityManager()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> transaction: EntityTransaction <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        entityManager.transaction</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">save</span><span class="params">(entity: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">        transaction.begin()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            entityManager.persist(entity)</span><br><span class="line">            entityManager.flush() <span class="comment">// transaction commit시 자동으로 flush 발생시키나 명시적으로 선언</span></span><br><span class="line">            transaction.commit()</span><br><span class="line">            entityManager.clear()</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            transaction.rollback()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> entity</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">saveAll</span><span class="params">(entities: <span class="type">Iterable</span>&lt;<span class="type">T</span>&gt;)</span></span>: Iterable&lt;T&gt; &#123;</span><br><span class="line">        transaction.begin()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (entity <span class="keyword">in</span> entities) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                entityManager.persist(entity)</span><br><span class="line">                entityManager.flush() <span class="comment">// transaction commit시 자동으로 flush 발생시키나 명시적으로 선언</span></span><br><span class="line">                transaction.commit()</span><br><span class="line">                entityManager.clear()</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                transaction.rollback()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entities</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해결 방법은 테스트 코드를 위해서 필요한 기능을 제공해 주는 <code>SpringBootTestSupport</code>을 제공해 주는 것입니다. 자세한 코드는 아래에서 설명하겠습니다.</p><h3><span id="과도한-dependency-해결-방법">과도한 Dependency 해결 방법</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">save</span><span class="params">(entity: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    transaction.begin()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        entityManager.persist(entity)</span><br><span class="line">        entityManager.flush() <span class="comment">// transaction commit시 자동으로 flush 발생시키나 명시적으로 선언</span></span><br><span class="line">        transaction.commit()</span><br><span class="line">        entityManager.clear()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        transaction.rollback()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">saveAll</span><span class="params">(entities: <span class="type">Iterable</span>&lt;<span class="type">T</span>&gt;)</span></span>: Iterable&lt;T&gt; &#123;</span><br><span class="line">    transaction.begin()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (entity <span class="keyword">in</span> entities) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            entityManager.persist(entity)</span><br><span class="line">            entityManager.flush() <span class="comment">// transaction commit시 자동으로 flush 발생시키나 명시적으로 선언</span></span><br><span class="line">            transaction.commit()</span><br><span class="line">            entityManager.clear()</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            transaction.rollback()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entities</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Given</code>절에서 작성하는 데이터 Set up이기 때문에 <strong>트랜잭션을 완전히 분리하기 위해서 transactionn을 commit을 직접 수행 시킵니다.</strong> transaction commit 시에 flush가 동작하지만 명시적으로 코드를 작성했습니다.</p><p>주의해야할 점은</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entityManager.clear()</span><br></pre></td></tr></table></figure><p><strong>EntityManager를 이용해서 clear()을 강제로 발생시키는 있는 점입니다.</strong></p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/query-result-.png" alt=""></p><p>영속성 컨텍스트는 1차 캐시를 우선시 합니다. 즉 추가적인 JPQL 쿼리로 조회한 값이 영속성 컨텍스트에 존재하는 경우(식별자 값으로 동일성을 판단함) JPQL로 조회한 데이터를 버립니다. <strong>즉 1차 캐시된것을 우선시합니다.</strong></p><p>그러기 때문에 EntityManager를 이용해서 <strong>영속성 컨텍스트를 초기화하는 것입니다.</strong> 자세한 내용은 <a href="https://cheese10yun.github.io/jpa-bulk/#1">JPA 벌크 작업 주의점 - 영속성 컨텍스트는 1차 캐시된 것이 우선이다.</a> 포스팅을 참고해 주세요</p><p>그리고 <code>Give</code>절에 작성하는 데이터는 이미 데이터베이스에 영속화되어 있다는 개념으로 테스트하는 것이니 이런 문제가 없더라도 최대한 동일한 환경을 구성해주는 것이 좋다고 생각합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaTestSupport</span> : <span class="type">SpringBootTestSupport</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `entityManager를 이용해서 dependency가 최소화 `<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 특정 테스트를 하기 위해서 많은 디펜던시가 필요하다.</span></span><br><span class="line">        save(Payment(BigDecimal.TEN))</span><br><span class="line">        save(Member(<span class="string">"username"</span>, <span class="number">10</span>, save(Team(<span class="string">"team-ename"</span>))))</span><br><span class="line">        save(Coupon(BigDecimal.TEN))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entity의 영속성을 EnttiyManager를 통해서 진행하기 때문에 단순 save를 위해서 DI 받는 Repository가 없어졌습니다.</p><h3><span id="검증이-필요한데-해결방법">검증이 필요한데 ?.. 해결방법</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">query</span><span class="params">(entityManager: <span class="type">EntityManager</span>)</span></span>: JPAQueryFactory &#123;</span><br><span class="line">        <span class="keyword">return</span> JPAQueryFactory(entityManager)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootTestSupport</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> query: JPAQueryFactory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JPAQueryFactory</code>을 <code>query</code>으로 Bean 등록을 진행합니다. Test Scope에서만 사용하는 것을 원하는 경우에는 Test directory에 <code>@TestConfiguration</code>으로 지정해도 됩니다.</p><p><code>query</code>을 이용해서 테스트 코드 검증을 진행할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaTestSupport</span> : <span class="type">SpringBootTestSupport</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `entityManager를 이용해서 dependency가 최소화 `<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 특정 테스트를 하기 위해서 많은 디펜던시가 필요하다.</span></span><br><span class="line">        save(Payment(BigDecimal.TEN))</span><br><span class="line">        save(Member(<span class="string">"username"</span>, <span class="number">10</span>, save(Team(<span class="string">"team-ename"</span>))))</span><br><span class="line">        save(Coupon(BigDecimal.TEN))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 특정 서비스가 여러 entity rows를 변경할때 아래와 같은 조회로 Then 이어가야 합니다.</span></span><br><span class="line">        <span class="comment">// paymentRepository.findBy... epository 메서드는 없는데??...</span></span><br><span class="line">        <span class="comment">// memberRepository.findBy...</span></span><br><span class="line">        <span class="comment">// couponRepository.findBy...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> payments = query.selectFrom(QPayment.payment)</span><br><span class="line">            .where(QPayment.payment.amount.gt(BigDecimal.TEN))</span><br><span class="line">            .fetch()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> members = query.select(QMember.member.age)</span><br><span class="line">            .from(QMember.member)</span><br><span class="line">            .where(QMember.member.age.gt(<span class="number">20</span>))</span><br><span class="line">            .fetch()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> coupons = query.selectFrom(QCoupon.coupon)</span><br><span class="line">            .where(QCoupon.coupon.amount.eq(<span class="number">123.</span>toBigDecimal()))</span><br><span class="line">            .fetch()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여러 엔티티의 여러 row의 수정을 진행했을 경우 해당 엔티티의 변경을 확인하기 위한 검증이 필요합니다. 이때 조회용 메서드를 단순히 테스트 코드에서만 사용하기 위해서 작성하기 위해서 작성하거나 Test Scope에 별도의 Repository를 구성해야 했지만 이제는 위에서 등록한 <code>query</code>을 이용해서 해당 비즈니스에 맞는 쿼리를 작성할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentServiceTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paymentService: PaymentService</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `paymentZero test`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">val</span> targetAmount = <span class="number">105.</span>toBigDecimal()</span><br><span class="line">        saveAll((<span class="number">1.</span><span class="number">.100</span>).map &#123;</span><br><span class="line">            Payment(it.toBigDecimal().plus(BigDecimal.TEN).setScale(<span class="number">0</span>))</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        paymentService.paymentZero(targetAmount)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        <span class="keyword">val</span> count = query</span><br><span class="line">            .selectFrom(qPayment)</span><br><span class="line">            .where(qPayment.amount.gt(targetAmount))</span><br><span class="line">            .fetchCount()</span><br><span class="line"></span><br><span class="line">        then(count).isEqualTo(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>이런 식으로 심플하게 테스트 코드를 작성할 수 있습니다.</p><h2><span id="주의할-점">주의할 점</span></h2><p><code>SpringBootTestSupport</code> 클래스에서 정의한 <code>save()</code>, <code>saveAll()</code> 메서드를 사용하는 경우 테스트에서 사용하는 트랜잭션과 완전하게 분리가 됩니다.</p><p>스프링 테스트에서는 <code>@Transactional</code>이 있는 경우 해당 테스트 메서드가 종료되면 트랜잭션으로 같이 Rollback이 진행되게 됩니다. 하지만 <code>SpringBootTestSupport</code>에서 작성한 <code>save()</code>, <code>saveAll()</code>메서드 같은 경우에는 완전히 다른 트랜잭션이므로 <code>given</code>절에서 작성한 트랜잭션이 롤백 되지 않습니다.</p><h2><span id="마무리">마무리</span></h2><p>테스트 코드의 중요성의 강조는 의미 없을 정도로 현업에서 자리 잡았다고 생각합니다. 이렇게 중요성이 있는 부분이니 테스트 코드를 작성하기 편한 방법도 많이 연구되었으면 좋겠다는 생각이 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JPA 기반으로 테스트 코드를 작성하면서 불편했던 부분을 소개하고 해결 방법에 관한 포스팅입니다.&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;jpa-기반-테스트-불편한-점&quot;&gt;JPA 기반 테스트 불편한 점&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span id=&quot;과도한
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Test" scheme="https://cheese10yun.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>Querydsl Repository Support 활용</title>
    <link href="https://cheese10yun.github.io/querydsl-support/"/>
    <id>https://cheese10yun.github.io/querydsl-support/</id>
    <published>2020-02-28T15:00:00.000Z</published>
    <updated>2020-02-29T14:02:39.470Z</updated>
    
    <content type="html"><![CDATA[<p>개발을 진행할 하다 보면 다양한 조회 쿼리를 만들게 됩니다. JPA를 이용한다면 Querydsl Support를 사용하면 세부 구현체를 숨기고 Repository를 통해서 조회 쿼리를 제공해 줄 수 있어 장점이 있습니다.</p><p>관련 <a href="https://github.com/cheese10yun/spring-jpa-best-practices/blob/master/doc/step-15.md" rel="external nofollow noopener noreferrer" target="_blank">step-15: Querydsl를 이용해서 Repository 확장하기 (1)</a>, <a href="https://cheese10yun.github.io/jpa-preference/">JPA 선호하는 패턴</a>을 참고해 주세요</p><h2><span id="querydslrepositorysupport-사용시-문제점">QuerydslRepositorySupport 사용시 문제점</span></h2><p>QuerydslRepositorySupport은 <code>JPQLQuery</code>를 이용해서 JPQL 작업을 진행합니다. 그래서 약간 단점이 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.querydsl.domain.QPayment.payment <span class="keyword">as</span> qPayment</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentCustomRepositoryImpl</span> : <span class="type">QuerydslCustomRepositorySupport</span></span>(Payment::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>), <span class="type">PaymentCustomRepository &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findUseFrom</span><span class="params">(targetAmount: <span class="type">BigDecimal</span>)</span></span>: List&lt;Payment&gt;? &#123;</span><br><span class="line">        <span class="keyword">return</span> from(qPayment)</span><br><span class="line">            .where(qPayment.amount.gt(targetAmount))</span><br><span class="line">            .fetch()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당 코드를 보면 <code>from</code>으로 시작해야 합니다. <code>QuerydslRepositorySupport</code> 구현체의 from 메서드는 아래와 같습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; JPQLQuery&lt;T&gt; from(EntityPath&lt;T&gt; path) &#123;</span><br><span class="line">    <span class="keyword">return</span> getRequiredQuerydsl().createQuery(path).select(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>즉 <code>JPQLQuery</code>을 사용해서 쿼리 작업을 진행해야 되기 때문에 <code>from</code>으로 시작할 수밖에 없습니다.</p><p>사실 별거 아닌 거 같지만 우리는 일반적으로 query를 시작할 때는 <code>select</code>으로 시작합니다. <code>queryFactory</code>을 이용하면 select, selectFrom으로 쿼리를 시작할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findUseSelectFrom</span><span class="params">(targetAmount: <span class="type">BigDecimal</span>)</span></span>: List&lt;Payment&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> selectFrom(qPayment)</span><br><span class="line">        .where(qPayment.amount.gt(targetAmount))</span><br><span class="line">        .fetch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findUseSelect</span><span class="params">(targetAmount: <span class="type">BigDecimal</span>)</span></span>: List&lt;<span class="built_in">Long</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> select(qPayment.id)</span><br><span class="line">        .from(qPayment)</span><br><span class="line">        .where(qPayment.amount.gt(targetAmount))</span><br><span class="line">        .fetch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>selectFrom</code>은 조회하는 타입이 일치하는 경우 사용할 수 있고, <code>select</code>는 리턴 받을 타입을 지정할 수 있습니다. 우리가 일반적으로 사용하는 SQL 문과 아주 유사한 구조입니다.</p><h2><span id="querydslcustomrepositorysupport-작성하기">QuerydslCustomRepositorySupport 작성하기</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">QuerydslCustomRepositorySupport</span></span>(domainClass: Class&lt;*&gt;) : QuerydslRepositorySupport(domainClass) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> queryFactory: JPAQueryFactory <span class="keyword">by</span> Delegates.notNull()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setEntityManager</span><span class="params">(entityManager: <span class="type">EntityManager</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setEntityManager(entityManager)</span><br><span class="line">        <span class="keyword">this</span>.queryFactory = JPAQueryFactory(entityManager)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">select</span><span class="params">(expr: <span class="type">Expression</span>&lt;<span class="type">T</span>&gt;)</span></span>: JPAQuery&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> queryFactory.select(expr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">selectFrom</span><span class="params">(from: <span class="type">EntityPath</span>&lt;<span class="type">T</span>&gt;)</span></span>: JPAQuery&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> queryFactory.selectFrom(from)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용법은 간단합니다. <code>QuerydslRepositorySupport</code>을 상속하는 클래스를 <strong>직접 정의해서 제공하는 것입니다.</strong></p><p>코드는 간단합니다. <code>EntityManager</code>을 상위 클래스에서 전달해 주며 <code>JPAQuery</code>에서 제공해 주는 <code>select</code>, <code>selectFrom</code>을 구현(JPAQuery의 메서드를 복붙)하면 됩니다. <code>select</code>, <code>selectFrom</code> 외에도 다양한 기능들을 제공해 줄 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentRepositoryTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paymentRepository: PaymentRepository</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `findUseSelectFrom`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">val</span> targetAmount = <span class="number">200.</span>toBigDecimal()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="keyword">val</span> payments = paymentRepository.findUseSelectFrom(targetAmount)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        then(payments).anySatisfy &#123;</span><br><span class="line">            then(it.amount).isGreaterThan(targetAmount)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `findUseSelect`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">val</span> targetAmount = <span class="number">200.</span>toBigDecimal()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="keyword">val</span> ids = paymentRepository.findUseSelect(targetAmount)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        then(ids).hasSizeGreaterThan(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/queydsl-support-result.png" alt=""></p><p>테스트 코드를 통과로 정상 동작하는 것을 확인할 수 있습니다.<br><code>select</code>, <code>selectFrom</code> 시작해서 큰 이득을 얻을 수 없지만 최대한 SQL스럽게 코드를 작성할 수 있어서 개인적으로 선호하는 방식입니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;개발을 진행할 하다 보면 다양한 조회 쿼리를 만들게 됩니다. JPA를 이용한다면 Querydsl Support를 사용하면 세부 구현체를 숨기고 Repository를 통해서 조회 쿼리를 제공해 줄 수 있어 장점이 있습니다.&lt;/p&gt;
&lt;p&gt;관련 &lt;a 
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Querydsl" scheme="https://cheese10yun.github.io/tags/Querydsl/"/>
    
  </entry>
  
  <entry>
    <title>Querydsl Projection 방법 소개 및 선호하는 패턴 정리</title>
    <link href="https://cheese10yun.github.io/querydsl-projections/"/>
    <id>https://cheese10yun.github.io/querydsl-projections/</id>
    <published>2020-02-20T14:39:57.000Z</published>
    <updated>2020-02-21T15:15:13.808Z</updated>
    
    <content type="html"><![CDATA[<p>Querydsl를 이용하는 경우 엔티티와 다른 반환 타입인 경우 <code>Projections</code>를 사용합니다. <code>Projections</code>을 하는 방법과 선호하는 패턴을 정리해보았습니다.</p><p><code>Projections</code>을 이용해서 projection 하는 방법은 크게 3가지가 있습니다.</p><ol><li><code>Projections.bean</code>을 이용하는 방법</li><li><code>Projections.constructor</code>를 이용하는 방법</li><li><code>@QueryProjection</code>를 사용하는 방법</li></ol><p>결론부터 말씀드리면 <code>@QueryProjection</code>을 사용하는 방법이 가장 좋다고 생각합니다. 각 패턴의 장단점을 설명드리겠습니다.</p><h2><span id="projectionsbean">Projections.bean</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberDtoBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectionTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> em: EntityManager</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> query = JPAQueryFactory(em)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `projection bean`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> members = query</span><br><span class="line">            .select(Projections.bean(</span><br><span class="line">                MemberDtoBean::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>,<span class="type"></span></span></span><br><span class="line">                qMember.username,</span><br><span class="line">                qMember.age</span><br><span class="line">            ))</span><br><span class="line">            .from(qMember)</span><br><span class="line">            .fetch()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">            println(member)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Projections.bean</code> 방식은 setter 기반으로 동작하게 됩니다. 그러기 때문에 <code>MemberDtoBean</code>객체의 setter 메서드를 열어야 합니다. 일반적으로 Response, Request 객체는 불변 객체를 지향하는 것이 바람직하다고 생각하기 때문에 권장하는 패턴은 아닙니다.</p><h2><span id="projectionsconstructor">Projections.constructor</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberDtoConstructor</span></span>(</span><br><span class="line">    <span class="keyword">val</span> username: String,</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectionTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> em: EntityManager</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> query = JPAQueryFactory(em)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `projection <span class="keyword">constructor</span>`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> members = query</span><br><span class="line">            .select(Projections.<span class="keyword">constructor</span>(</span><br><span class="line">                MemberDtoConstructor::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>,<span class="type"></span></span></span><br><span class="line">                qMember.username,</span><br><span class="line">                qMember.age</span><br><span class="line">            ))</span><br><span class="line">            .from(qMember)</span><br><span class="line">            .fetch()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">            println(member)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Projections.constructor</code>를 사용하면 생성자 기반으로 바인딩 하기 때문에 <code>MemberDtoConstructor</code>객체를 불변으로 가져갈 수 있습니다. <strong>하지만 바인딩 시키는 작업에 문제가 있습니다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.select(Projections.<span class="keyword">constructor</span>(</span><br><span class="line">    MemberDtoConstructor::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>,<span class="type"></span></span></span><br><span class="line">    qMember.username,</span><br><span class="line">    qMember.age</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>위 코드를 보면 <code>MemberDtoConstructor</code>객체 생성자에 바인딩 하는 것이 아니라 <code>Expression&lt;?&gt;... exprs</code> 값을 넘기는 방식으로 진행합니다.</p><p><strong>즉 값을 넘길 때 생성자와 순서를 일치시켜야 합니다.</strong> 위처럼 개수가 몇 개 안될 때는 문제가 되지 않으나 값이 많아지는 경우 실수할 수 있는 문제가 발생할 수 있는 확률이 높습니다. 이러한 문제가 있어 권장하지 않은 패턴입니다.</p><h2><span id="queryprojection">@QueryProjection</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberDtoQueryProjection</span> <span class="meta">@QueryProjection</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">val</span> username: String,</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectionTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> em: EntityManager</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> query = JPAQueryFactory(em)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `projection <span class="keyword">annotation</span>`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> members = query</span><br><span class="line">            .select(QMemberDto(</span><br><span class="line">                qMember.username,</span><br><span class="line">                qMember.age</span><br><span class="line">            ))</span><br><span class="line">            .from(qMember)</span><br><span class="line">            .fetch()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">            println(member)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>@QueryProjection</code>를 이용하면 위에서 발생한 불변 객체 선언, 생성자 그대로 사용을 할 수 있어 권장하는 패턴입니다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.select(QMemberDto( <span class="comment">// QMemberDtoQueryProjection 의 생성자를 이용한다.</span></span><br><span class="line">    qMember.username,</span><br><span class="line">    qMember.age</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>정확히는 <code>MemberDtoQueryProjection</code>의 생성자를 사용하는 것이 아니라. <code>MemberDtoQueryProjection</code> 기반으로 생성된 <code>QMemberDtoQueryProjection</code> 객체의 생성자를 사용하는 것입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Generated</span>(<span class="string">"com.querydsl.codegen.ProjectionSerializer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QMemberDtoQueryProjection</span> <span class="keyword">extends</span> <span class="title">ConstructorExpression</span>&lt;<span class="title">MemberDtoQueryProjection</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">277743863L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QMemberDtoQueryProjection</span><span class="params">(com.querydsl.core.types.Expression&lt;String&gt; username, com.querydsl.core.types.Expression&lt;Integer&gt; age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(MemberDtoQueryProjection.class, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class&#125;, username, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>QMemberDtoQueryProjection</code>생성자는 <code>MemberDtoQueryProjection</code> 생성자의 변수명과 순서와 정확하게 일치합니다.</p><p>그래서 IDE의 자동완성 기능을 이용해서 보다 안전하고 편리하게 생성자에 필요한 값 바인딩을 진행할 수 있습니다. 그래서 가장 권장하는 패턴입니다.</p><p>물론 단점도 있습니다. <code>Dto</code>라는 특성상 해당 객체는 많은 계층에서 사용하게 됩니다. 그렇게 되면 Querydsl의 의존성이 필요 없는 레이어에서도 해당 의존성이 필요하게 됩니다.</p><p>저는 개인적으로 이 정도의 의존관계 때문에 발생하는 의존성 문제 보다 <code>Projections</code>를 안전하게 사용할 수 있는 방법이 더 효율적이라고 생각합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Querydsl를 이용하는 경우 엔티티와 다른 반환 타입인 경우 &lt;code&gt;Projections&lt;/code&gt;를 사용합니다. &lt;code&gt;Projections&lt;/code&gt;을 하는 방법과 선호하는 패턴을 정리해보았습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Pro
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JPA 선호하는 패턴</title>
    <link href="https://cheese10yun.github.io/jpa-preference/"/>
    <id>https://cheese10yun.github.io/jpa-preference/</id>
    <published>2020-02-11T15:00:00.000Z</published>
    <updated>2020-03-01T04:44:28.595Z</updated>
    
    <content type="html"><![CDATA[<p>최근 JPA를 3년 가까이 사용하면서 개인적인으로 선호하는 패턴들을 한 번 정리하려고 한다. 어디까지 개인적으로 선호하는 패턴으로 굳이 이런 가이드를 따르지 않아도 된다.</p><h2><span id="컬럼-에노테이션-사용">컬럼 에노테이션 사용</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"member"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>(</span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"username"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> username: String,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"age"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"email"</span>, nullable = false, unique = true, updatable = false)</span></span><br><span class="line">    <span class="keyword">var</span> email: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>칼럼 에노테이션과 멤버 필명이 동일한 경우 칼럼에노테이션을 생략하는 경우도 있다. 그래서 일치하지 않은 것들만 작성하는 방법도 있지만 <strong>나는 모든 멤버 필드에 칼럼 에노테이션을 작성하는 패턴을 선호한다.</strong></p><p><strong>칼럼 에노테이션을 통해 <code>nullable</code>, <code>unique</code>, <code>updatable</code> 등등 여러 메타 정보를 전달해 줄 수 있다.</strong> 물론 필요한 경우에만 추가하고 기본적으로 작성하지 않아도 되는 패턴을 선택해도 되지만 <strong>개인적으로 이런 예매한 예외를 두는 가이드 보다</strong> 조금 불편하더라도 다 작성하는 패턴이 좋다고 본다.</p><p>그리고 일단 컬럼 에노테이션을 작성하면 한 번더 이 필드에 대해서 생각을 해보고 unique, nullable 여부 등을 한 번 더 생각 보게 돼서 좋다고 생각한다.</p><p>또 멤버 필드 리네임 관련 리팩토링에 과감해질 수 있다. 멤버 필드는 카멜케이스, 데이터베이스는 스네이크 케이스를 사용하는 경우가 흔한데 칼럼명이 긴 경우 가끔 오타 때문에 실수할 수 도 있다. 그러기 때문에 애초에 칼럼 에노테이션으로 다 작성하는 게 리팩토링 할 때도 안전성이 있다. 칼럼 에노테이션을 작성하면 <strong>멤버 필드 rename 관련 리팩토링을 과감하게 할 수 있다.</strong></p><h2><span id="엔티티에-과도한-에노테이션은-작성하지-않는다">엔티티에 과도한 에노테이션은 작성하지 않는다</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(</span></span><br><span class="line"><span class="meta">    name = <span class="meta-string">"member"</span>,</span></span><br><span class="line"><span class="meta">    indexes = [</span></span><br><span class="line"><span class="meta">        Index(columnList = <span class="meta-string">"username"</span>)</span>,</span><br><span class="line">        Index(columnList = <span class="string">"age"</span>)</span><br><span class="line">    ],</span><br><span class="line">    uniqueConstraints = [</span><br><span class="line">        UniqueConstraint(columnNames = [<span class="string">"username"</span>, <span class="string">"age"</span>])</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>(</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br>사실 위 칼럼 에노테이션 사용과는 좀 반대되는 개념이긴 한데 너무 과도한 에노 테이션으로 엔티티 클래스의 비즈니스 코드의 집중도를 떨어트리기 때문에 선호하지 않는다.</p><p>물론 위 작업을 아주 간결하게 표현할 수 있다면 가능하면 작성하는 것도 좋지만, 해당 속성들은 비교적 변경사항이 잦기 때문에 작성하지 않는 것을 선호하는 이유이기도 하다.</p><h2><span id="조인-칼럼을-사용하자">조인 칼럼을 사용하자</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>(</span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY, optional = false)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = <span class="meta-string">"team_id"</span>, nullable = false)</span> <span class="comment">// 생략 가능</span></span><br><span class="line">    <span class="keyword">var</span> team: Team</span><br><span class="line">) : EntityAuditing()</span><br></pre></td></tr></table></figure><p>OneToOne, ManyToOne 정보 같은 경우 연관관계의 주인에서 FK를 갖게 되기 때문에  칼럼 에노테이션을 작성할 수 있다. 연관관계 에노테이션으로 작성하면 기본적으로 PK 기반으로 되기 때문에 생략 가능하다.</p><p>하지만 칼럼 에노테이션을 사용하는 이유와 마찬가지로 조인 칼럼 에노테이션을 작성하는 것을 선호한다. <code>nullable</code>, <code>unique</code>, <code>updatable</code> 등 정보를 많이 표현해 준다.</p><p><strong>무엇보다 nullabel 설정에 따른 조인 전략이 달라질 수 있어 성능상 이점을 얻을 수 있는 부분이 있다.</strong> 이 부분은<br><a href="https://github.com/cheese10yun/spring-jpa-best-practices/blob/master/doc/step-08.md#%EC%A0%9C%EC%95%BD-%EC%A1%B0%EA%B1%B4%EC%9C%BC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EC%95%88%EC%A0%95%EC%84%B1-%EB%B0%8F-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81" rel="external nofollow noopener noreferrer" target="_blank">step-08: OneToOne 관계 설정 팁 : 제약 조건으로 인한 안정성 및 성능 향상</a>에서도 포스팅 한적 있다.</p><p>그리고 익숙하지 않은 프로젝트에서 칼럼명으로 엔티티 클래스를 찾는 경우가 있는데 이런 경우 해당 칼럼명으로 쉽게 검색할 수 있어 약간의 장점이 있다.</p><h2><span id="양방향-보다는-단방향으로-설정하자">양방향 보다는 단방향으로 설정하자</span></h2><p><strong>기본적으로 JPA 연관관계 설정은 단방향으로 설정하는 것을 선호한다.</strong> 사실 이것은 선호하기보다는 가이드 쪽에 가깝다. 우선 양방향 연관관계를 작성하면 생각 보다 고려할 부분이 많다. 양방향 편의 메서드, 디펜던시 사이클 문제가 있기 때문이다.</p><p><strong>무엇보다 OnyToMany, ManyToOne 관계는 설정은 선호하지 않는다.</strong> OneToMany를 관계를 갖게 되면 N+1 문제(물론 OneToMany를 관계에서만 N+1 문제가 발생하지는 않는다.) OneToMany 2개 이상 갖는 경우 카테시안 곱 문제로 <code>MultipleBagFetchException</code> 발생한다. <strong>양방향 메서드를 반드시 지정해야 할 이유가 없다면 단방향 관계를 지향하는 것이 좋다고 생각한다.</strong></p><h2><span id="open-setting-view-false로-두자">Open Setting View false로 두자</span></h2><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/jpa-osiv-2.png" alt=""></p><p>OSVI는 영속성 컨텍스트를 View 레이어까지 열어 둘 수 있다. 영속성 컨텍스트가 살아있으면 엔티티는 영속 상태로 유지된다. 따라서 <strong>뷰에서도 지연 로딩을 사용할 수 있다. 하지만 View에서 트랜잭션을 계속 가지고 있는 것이 좋다고 생각하지 않는다.</strong></p><p>기존 OSVI 문제를 해결하기 위해서 비즈니스 계층에서만 트랜잭션을 유지하는 방식의 OSVI를 스프링에서 지원해주고 있긴 하지만 ModelAndView를 사용하지 않고 <strong>단순하게 API로 JSON 같은 응답을 내려주는 서버로 사용한다면 View false를 false 두는 것이 좋다.(기본이 true이다)</strong></p><h2><span id="객체-그래프-탐색은-어디까지-할것인가-좀-끊자">객체 그래프 탐색은 어디까지 할것인가? 좀 끊자!</span></h2><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/eggregate.png?raw=true" alt=""></p><p>관계형 데이터베이스는 FK를 통해서 연관 탐색을 계속 진행할 수 있다. 마찬가지로 JPA도 객체 그래프 탐색을 통해서 연관 탐색을 계속 진행할 수 있다. <strong>이것은 그래프 탐색의 오용이라고 생각한다.</strong></p><p>DDD를 프로덕션 레벨에서 진행해본 적은 없지만 DDD에서 주장하는 에그리거트 단위, 그 단위가 다르면 객체 탐색을 끓는 것은 매우 동의한다.</p><p>위 처럼 주문, 회원이 있는 경우</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"orders"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>(</span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"amount"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> amount: BigDecimal,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="keyword">var</span> orderer: Orderer</span><br><span class="line"></span><br><span class="line">) : EntityAuditing()</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Orderer</span></span>(</span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"member_id"</span>, nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">var</span> memberId: <span class="built_in">Long</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"email"</span>, nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">var</span> email: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>연관관계를 명확하게 끊는 것이 옳다고 본다. 연관관계를 계속 탐색할 수 있는 것도 문제지만 연관관계를 갖게 되면 주문을 조회한 이후에 회원 정보를 변경할 수도 있다. <strong>Order 객체의 책임과 역할이 어디까지 인가를 봤을 때 이렇게 명확하게 끊는 것이 옳다고 본다.</strong>  만약 조회가 필요한 경우 <code>Orderer</code>객체에 <code>memberId</code>가 있으니 회원정보가 필요시에 조인해서 가져오면된다.</p><p>이것도 가이드 수준으로 생각하고 있지만 아직 DDD를 실무에서 진행해본 적이 없어 막연하게 드는 생각이라 가능하면 에그리거트 기준으로 연관관계를 끊는 것이 좋다고 생각만 하고 있다.</p><h2><span id="쿼리-메서드는-선호하지-않는다">쿼리 메서드는 선호하지 않는다.</span></h2><p><img src="https://github.com/cheese10yun/spring-jpa-best-practices/raw/master/images/AccountRepository.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Account</span>, <span class="title">Long</span>&gt;, <span class="title">AccountCustomRepository</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountCustomRepository</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findRecentlyRegistered</span><span class="params">(<span class="keyword">int</span> limit)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountCustomRepositoryImpl</span> <span class="keyword">extends</span> <span class="title">QuerydslRepositorySupport</span> <span class="keyword">implements</span> <span class="title">AccountCustomRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountCustomRepositoryImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Account.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 최근 가입한 limit 갯수 만큼 유저 리스트를 가져온다</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findRecentlyRegistered</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> QAccount account = QAccount.account;</span><br><span class="line">        <span class="keyword">return</span> from(account)</span><br><span class="line">                .limit(limit)</span><br><span class="line">                .orderBy(account.createdAt.desc())</span><br><span class="line">                .fetch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이건 정말 개인적인 선호도이다. 일단 조건이 까다로운 조회용 코드인 경우 <strong>쿼리 메서드로 표현하면 너무 장황해서 코드 가독성이 좋지 않다고 본다.</strong></p><p>쿼리 메서드를 사용하지 않고 QuerydslRepositorySupport를 이용한 Query DSL 기반으로 모두 작성하는 것을 선호한다. 물론 findByEmail 같은 것들은 쿼리 메서드가 더 편리하고 직관적이다고 생각하지만 위에서도 한 번 언급했지만 예외를 하나를 허용하면 추가적인 예외가 생기게 되기 때문에 <strong>아주 명확한 가이드가 없다면 모두 Query DSL 기반으로 작성하는 것을 선호한다.</strong></p><p>또 엔티티의 멤버 필드 변경 시에도 쿼리 메서드의 변경돼야 하는 것도 문제라고 생각한다. 물론 인텔리 제이에서 멤버 필드 rename 시에 적절하게 변경해주기도 하고, 스프링에서 쿼리 메서드가 문제가 있는 경우 스프링 구동시 예외가 발생하기 때문에 최소한의 안전장치가 있긴 하지만(이것도 없었다면 쿼리 메서드는 사용하지 않는 것을 가이드 했을 거 같다) 이러한 문제 때문에도 쿼리 메서드를 선호하지 않는다.</p><p>물론 Query DSL도 멤버 필드 변경 시에는 문제가 발생한다. 그 문제는 <code>Qxx.class</code>관련 Syntax이기 때문에 더 명확하다는 장점이 있다고 본다.</p><p><strong>그리고 무엇보다 비즈니스 로직의 컨텍스트를 메서드명으로 표현 못 한다.</strong> 활동하지 않은 휴면 회원의 정의를 마지막 로그인, 회원의 등급, 현재 회원의 상태 등등으로 정의하는 경우 이것을 쿼리 메서드로 작성하면 <code>findByLastLoginatAndStatusAndGrade</code> 와 유사하게 작성해야 한다.</p><p><strong>이것은 그냥 쿼리조건문을 뜻할 뿐 활동하지 않은 휴먼회원을 뜻하지 않는다.</strong> 물론 앞뒤 코드를 가지고 어느정도 유추는할 수 있지만 정확하게 전달하는 것은 아니다. 차리리 Querydsl으로 코드를 작성하고 <code>findDormancyMember</code> 으로 메서드를 지정하는 것이 훨씬 더 좋다고 생각한다.</p><p>또 다른 이유는, 지극히 주관적인 생각이지만 쿼리 메서드는 인터페이스 기반으로 작성하기 때문에 테스트 코드를 작성하지 않는 경우도 많다. 반면 Query DSL 세부 클래스를 작성하기 때문에 뭔가 테스트를 더 작성하게 하는 심리적인 이유도 있는 거 같다.</p><p>위 코드처럼 QuerydslRepositorySupport을 이용하면 Repository를 통해서 세부 구현체의 코드를 제공하기 때문에 이런 식의 패턴을 선호한다. 해당 패턴은 <a href="https://github.com/cheese10yun/spring-jpa-best-practices/blob/master/doc/step-15.md" rel="external nofollow noopener noreferrer" target="_blank">step-15: Querydsl를 이용해서 Repository 확장하기 (1)</a>에서 자세하게 다룬 적 이 있다.</p><h2><span id="auditing-상속-구조로-사용하자">Auditing 상속 구조로 사용하자</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EntityListeners(value = [AuditingEntityListener::class])</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityAuditing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreationTimestamp</span></span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"created_at"</span>, nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> createdAt: LocalDateTime</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@UpdateTimestamp</span></span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"updated_at"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> updatedAt: LocalDateTime</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"member"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>(</span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"username"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> username: String,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"age"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY, optional = false)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = <span class="meta-string">"team_id"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> team: Team</span><br><span class="line">) : EntityAuditing()</span><br></pre></td></tr></table></figure><p><code>@MappedSuperclass</code>, <code>@EntityListeners</code>를 사용하면 반복적인 id, createdAt, updatedAt을 코드를 상속받아 해결할 수 있다. 예전에는 이런 식의 상속 구조는 올바르지 않다고 생각해서 이런 패턴에 거부감이 있었다.</p><p>하지만 요즘에는 잘 사용하고 있다. 순수한 객체지향 코드를 유지하는 것도 중요하지만 결국 실리성 있는 부분을 택하는 것도 중요하다고 본다. 특히 코틀린으로 넘어오면서 id, createdAt, updatedAt 등 우리가 직접적으로 핸들링하지 않는 값에 대한 바인딩 방법이 많기 때문에 각각 엔티티에서 처리하면 코드 통일성이 떨어진다. 그래서 이렇게 처리하는 것이 좋다고 생각한다.</p><h2><span id="참고">참고</span></h2><ul><li><a href="http://acornpub.co.kr/book/jpa-programmig" rel="external nofollow noopener noreferrer" target="_blank">자바 ORM 표준 JPA 프로그래밍</a></li><li><a href="http://www.yes24.com/Product/Goods/27750871" rel="external nofollow noopener noreferrer" target="_blank">DDD Start</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;최근 JPA를 3년 가까이 사용하면서 개인적인으로 선호하는 패턴들을 한 번 정리하려고 한다. 어디까지 개인적으로 선호하는 패턴으로 굳이 이런 가이드를 따르지 않아도 된다.&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;컬럼-에노테이션-사용&quot;&gt;컬럼 에노테이션 사
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Flush" scheme="https://cheese10yun.github.io/tags/Flush/"/>
    
  </entry>
  
  <entry>
    <title>RestTemplate Mock 기반 테스트 하기</title>
    <link href="https://cheese10yun.github.io/rest-template-mock-test/"/>
    <id>https://cheese10yun.github.io/rest-template-mock-test/</id>
    <published>2020-01-31T15:00:00.000Z</published>
    <updated>2020-02-01T14:30:30.408Z</updated>
    
    <content type="html"><![CDATA[<p>스프링 프로젝트에서는 외부 API 모듈을 RestTemplate를 이용해서 호출하는 경우가 많습니다, 이런 경우 RestTemplate을 기반으로 Mock 테스트를 보다 쉽게 진행할 수 있습니다.</p><h2><span id="왜-mock-기반-테스트를-진행-해야하나">왜 Mock 기반 테스트를 진행 해야하나 ?</span></h2><p>외부 인프라스트럭처를 테스트 코드를 작성할 때는 mock 기반으로 테스트를 진행해야 합니다. 외부 인프라스트럭처에는 대표적으로 외부 API가 있습니다.</p><p>그런데 왜 Mock 기반으로 테스트해야 할까요? 외부 환경이기 때문에 제어권이 우리 밖에 있습니다. 그래서 우리 코드의 테스트를 위해서 Request, Response가 우리가 주어진 값인 경우 정상 동작하는지 테스트하기 위함입니다. <strong>Mockito 기반으로 데이터베이스의 의존성을 Mock으로 처리하고 실제 비즈니스 코드를 검증하는 거와 같은 결이라고 생각하면 됩니다.</strong></p><p>물론 전체 플로우를 테스트하기 위해서는 통합 테스트를 진행할 수도 있겠지만 이번 포스팅에서는 Mock 기반 단위 테스트하는 방법을 다루겠습니다.</p><h2><span id="코드">코드</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">restTemplate</span><span class="params">(objectMapper: <span class="type">ObjectMapper</span>)</span></span>: RestTemplate &#123;</span><br><span class="line">        <span class="keyword">return</span> RestTemplateBuilder()</span><br><span class="line">            .rootUri(<span class="string">"http://localhost:8080"</span>)</span><br><span class="line">            .setConnectTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">            .additionalMessageConverters()</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/teams"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeamApi</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> query: JPAQueryFactory</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(<span class="meta">@RequestParam(required = false)</span> name: <span class="type">String</span>?)</span></span>: List&lt;Team&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> query.selectFrom(qTeam)</span><br><span class="line">            .from(qTeam)</span><br><span class="line">            .fetch()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiService</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> restTemplate: RestTemplate</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getTeam</span><span class="params">(name: <span class="type">String</span>)</span></span>: List&lt;Team&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"/teams?name=<span class="variable">$name</span>"</span>, Array&lt;Team&gt;::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)!!.<span class="title">toList</span></span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드는 간단합니다. RestTemplate 기반으로 local 서버를 호출하는 코드입니다. 테스트를 위해 Team 정보를 10개를 set up 했습니다.</p><h2><span id="테스트-코드">테스트 코드</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiServiceTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> restTemplate: RestTemplate, <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> apiService: ApiService <span class="comment">// (2)</span></span><br><span class="line"></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> server: MockRestServiceServer <span class="keyword">by</span> notNull()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        server = MockRestServiceServer.createServer(restTemplate) <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `api test`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">val</span> path = <span class="string">"/team-api-response.json"</span></span><br><span class="line">        <span class="keyword">val</span> name = <span class="string">"team"</span></span><br><span class="line">        server</span><br><span class="line">            .expect(</span><br><span class="line">                requestTo(<span class="string">"http://localhost:8080/teams?name=<span class="variable">$name</span>"</span>)</span><br><span class="line">            )<span class="comment">// (4)</span></span><br><span class="line">            .andExpect(method(HttpMethod.GET)) <span class="comment">// (5)</span></span><br><span class="line">            .andRespond(</span><br><span class="line">                withStatus(HttpStatus.OK)</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .body(ClassPathResource(path, javaClass))</span><br><span class="line">            )<span class="comment">// (6)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="comment">// (7)</span></span><br><span class="line">        <span class="keyword">val</span> teams = apiService.getTeam(<span class="string">"team"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        <span class="comment">// (8)</span></span><br><span class="line">        <span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">            println(team)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (9)</span></span><br><span class="line">        then(teams).hasSize(<span class="number">10</span>)</span><br><span class="line">        then(teams).anySatisfy &#123;</span><br><span class="line">            then(it.name).startsWith(<span class="string">"team"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(1) : 해당 서비스에서 사용하는 RestTemplate를 주입받습니다. 실제 실무에서는 RestTemplate를 vendor마다 등록하기 때문에 테스트하고자 하는 RestTeamplte를 주입받습니다.</li><li>(2) : 해당 API 통신하는 서비스를 주입받습니다.</li><li>(3) : 주입받은 RestTemplate 기반으로 MockRestServiceServer 생성합니다. MockRestServiceServer는 클라이언트와 서버 사이의 REST 테스트를 위한 객체입니다. 내부에서 RestTemplate를 바인딩 하여 실제로 통신이 이루어지게끔 구성할 수도 있습니다. 이 코드에서는 목 객체와 같이 실제로 통신이 이루어지지는 않지만 지정한 결로에 예상되는 반환값을 명시합니다.</li><li>(4) : 검증을 시도합니다. 실제 restTeamplte의 Request가 저 URL으로 해당하는지 검증합니다.</li><li>(5) : 실제 Request의 HTTP Method가 GET을 이용하는지 검증합니다.</li><li>(6) : Response에 대한 검증을 시작합니다. HTTP Status Code, Body, MediaType 등을 검증합니다. path 변수에는 해당 API의 예상되는 json 값을 작성해 놓습니다. Givne 절이라고 생각하면 됩니다.</li><li>(7) : 실제 서비스 코드에서 호출하는 코드를 호출합니다.</li><li>(8) : 테스트 동작 여부를 확인하기 위해서 print 하는 코드입니다.</li><li>(9) : 실제 when 절의 코드가 예상하는 것처럼 동작했는지 검증합니다.</li></ul><p>given 절에 있는 <code>/team-api-response.json</code>는 <code>/src/test/resources/</code> 디렉터리에 기본 path로 바라보며 해당 경로에 있는 파일을 찾게 됩니다. JSON 파일은 아래와 같습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"team 1"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"createdAt"</span>: <span class="string">"2020-02-01T16:58:34.377"</span>,</span><br><span class="line">    <span class="attr">"updatedAt"</span>: <span class="string">"2020-02-01T16:58:34.377"</span>,</span><br><span class="line">    <span class="attr">"members"</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"team 10"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">"createdAt"</span>: <span class="string">"2020-02-01T16:58:34.402"</span>,</span><br><span class="line">    <span class="attr">"updatedAt"</span>: <span class="string">"2020-02-01T16:58:34.402"</span>,</span><br><span class="line">    <span class="attr">"members"</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>물론 객체 기반으로 만들고 그것을 시리얼 라이즈 해서 json으로 만들어도 되지만 <a href="https://cheese10yun.github.io/spring-about-test/#json">테스트 코드 작성에 대한 나름의 고찰</a>에서 한 번 다뤘지만 해당 테스트에서 Team 객체가 Response body가 객체가 시리얼 라이즈 되는지까지 책임이 부여되기 때문에 json 파일로 response body를 관리하는 것이 더 효율적이라고 생각합니다.</p><h2><span id="무엇을-테스트할-것인가">무엇을 테스트할 것인가?</span></h2><p>일단 Mock 기반 테스트는 단위 테스트 성격이 높습니다. 그렇다면 무엇을 테스트할 것인지 명확하게 테스트해야 합니다. <strong>해당 테스트에서는 원하는 곳으로 Request가 가는지, 우리가 원하는 Reponse가 예상되었을 경우 우리 로직이 제대로 동작하는지 테스트를 진행하겠습니다.</strong></p><h3><span id="request-테스트">Request 테스트</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> name = <span class="string">"team"</span></span><br><span class="line">    server</span><br><span class="line">        .expect(</span><br><span class="line">            requestTo(<span class="string">"http://localhost:8080/teams?name=<span class="variable">$name</span>"</span>)</span><br><span class="line">        )<span class="comment">// (4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> teams = apiService.getTeam(<span class="string">"kotlin"</span>) <span class="comment">// team -&gt; kotlin 으로 이름 변경</span></span><br></pre></td></tr></table></figure><p>MockRestServiceServer에서는 요청을 <code>teams?=name=team</code>으로 했고 실제 apiService에서는 <code>kotlin</code> 을 넘겼기 때문에 두 요청은 일치하지 않습니다. 이 상태에서 테스트 코드를 실행하면 아래와 같은 오류를 발견합니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/moack-api-fail-1.png" alt=""></p><p>즉 실제 apiService 룰 통한 실제 요청과 mock 기반 요청이 일치하는지 확인을 검증하는 것입니다. 파라미터가 name 하나여서 간단하지 조회용 condition이 상당히 복잡합니다. 이런 것들을 케이스 별로 테스트하는 것이 바람직합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">        .expect(</span><br><span class="line">            requestTo(<span class="string">"http://localhost:8080/teams?name=<span class="variable">$name</span>"</span>)</span><br><span class="line">        )<span class="comment">// (4)</span></span><br><span class="line">        .andExpect(method(HttpMethod.POST)) <span class="comment">// (5) GET -&gt; POST 변경</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/moack-api-fail-2.png" alt=""></p><p>이 테스트도 마찬가지로 mock server의 HTTP Method 다르기 때문에 실패하게 됩니다.</p><h3><span id="response-테스트">Response 테스트</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">        ...    </span><br><span class="line">        .andRespond(</span><br><span class="line">            withStatus(HttpStatus.OK)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .body(ClassPathResource(path, javaClass))</span><br><span class="line">        )<span class="comment">// (6)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> teams = apiService.getTeam(<span class="string">"team"</span>)</span><br></pre></td></tr></table></figure><p>Response를 테스트 진행합니다. Response 테스트에서는 RestTemplate에서 전달받은 Response Body가 객체로 변환되는지 테스트합니다.</p><p>위에서 언급했듯이 <code>.body(ClassPathResource(path, javaClass))</code>는 <code>/src/test/resources/</code> path에 있는 해당 json 파일 기반으로 body를 mock 해서 돌려줍니다.</p><p>역 직렬화를 못하게 name을 null으로 변경해보겠습니다. (team name 객체는 notnull입니다.)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"createdAt"</span>: <span class="string">"2020-02-01T16:58:34.377"</span>,</span><br><span class="line">    <span class="attr">"updatedAt"</span>: <span class="string">"2020-02-01T16:58:34.377"</span>,</span><br><span class="line">    <span class="attr">"members"</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/moack-api-fail-3.png" alt=""></p><p>역 직렬화를 못하기 때문에 테스트가 실패하는 것을 확인할 수 있습니다.</p><h2><span id="결론">결론</span></h2><p>RestTemplate 기반으로 테스트하는 방법을 포스팅하긴 했지만 더 <strong>강조하고 싶은 부분은 외부 디펜던시 어떻게 끊고 어떤 부분을 어떤 관점에서 테스트할지 고민해보고 테스트를 작성하는 것이 좋다는 것입니다.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;스프링 프로젝트에서는 외부 API 모듈을 RestTemplate를 이용해서 호출하는 경우가 많습니다, 이런 경우 RestTemplate을 기반으로 Mock 테스트를 보다 쉽게 진행할 수 있습니다.&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;왜-mock-기반
      
    
    </summary>
    
    
      <category term="Test" scheme="https://cheese10yun.github.io/tags/Test/"/>
    
      <category term="RestTemplate" scheme="https://cheese10yun.github.io/tags/RestTemplate/"/>
    
  </entry>
  
  <entry>
    <title>JPA 벌크 작업 주의점</title>
    <link href="https://cheese10yun.github.io/jpa-bulk/"/>
    <id>https://cheese10yun.github.io/jpa-bulk/</id>
    <published>2020-01-31T15:00:00.000Z</published>
    <updated>2020-02-04T17:14:15.713Z</updated>
    
    <content type="html"><![CDATA[<p>JPA Bulk 작업을 진행할 때 영속성 컨텍스트의 메커니즘을 이해하지 못한 상태라면 예상하지 못한 문제를 만날 수도 있게 됩니다. 어떤 문제가 있고 이 문제가 왜 발생하는지 정리해 보았습니다.</p><h2><span id="코드">코드</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">BulkTest</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> em: EntityManager</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> query = JPAQueryFactory(em)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> teams = listOf(</span><br><span class="line">                Team(<span class="string">"team_1"</span>),</span><br><span class="line">                Team(<span class="string">"team_2"</span>),</span><br><span class="line">                Team(<span class="string">"team_3"</span>),</span><br><span class="line">                Team(<span class="string">"team_4"</span>),</span><br><span class="line">                Team(<span class="string">"team_5"</span>),</span><br><span class="line">                Team(<span class="string">"team_6"</span>),</span><br><span class="line">                Team(<span class="string">"team_7"</span>),</span><br><span class="line">                Team(<span class="string">"team_8"</span>),</span><br><span class="line">                Team(<span class="string">"team_9"</span>),</span><br><span class="line">                Team(<span class="string">"team_10"</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">            em.persist(team)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `bulk test`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// team 전체를 조회한다. team name은 team_x 이다.</span></span><br><span class="line">        <span class="keyword">val</span> teams = query.selectFrom(qTeam).fetch()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">            println(<span class="string">"before update team : <span class="variable">$team</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> ids = teams.map &#123; it.id!! &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// team  name 전체를 none name으로 변경한다. </span></span><br><span class="line">        <span class="keyword">val</span> updateCount = query.update(qTeam)</span><br><span class="line">                .<span class="keyword">set</span>(qTeam.name, <span class="string">"none name"</span>)</span><br><span class="line">                .where(qTeam.id.`<span class="keyword">in</span>`(ids))</span><br><span class="line">                .execute()</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"update count : <span class="variable">$updateCount</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">            println(<span class="string">"after update team : <span class="variable">$team</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> newSelectTeams = query.selectFrom(qTeam).fetch()</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (team <span class="keyword">in</span> newSelectTeams) &#123;</span><br><span class="line">            println(<span class="string">"new select team : <span class="variable">$team</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드는 간단합니다. <code>team_1</code>, <code>team_2</code>…<code>team_10</code>을 저장하고 query dsl update를 이용해서 <code>team name</code>을 <code>none name</code>으로 변경하는 것입니다. 그리고 변경 제대로 변경이 되었는지 확인하는 확인하는 반복문이 있습니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/before-update.png" alt=""></p><p>로그를 보면 <code>team name</code> 1 ~ 10까지 제대로 출력되는 것을 확인할 수 있습니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/update-query.png" alt=""></p><p>update query, update count가 정상적으로 출력됩니다. 이제 업데이트된 <code>team</code>을 확인하는 아래 코드의 로그를 확인해보겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">    println(<span class="string">"after update team : <span class="variable">$team</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/ater-update.png" alt=""><br>예상했던 <code>none name</code>이 아닌 이전 데이터가 출력 되는 것을 획인 할 수 있습니다. 그렇다면 새로 query dsl으로 조회 쿼리를 해보겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newSelectTeams = query.selectFrom(qTeam).fetch()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (team <span class="keyword">in</span> newSelectTeams) &#123;</span><br><span class="line">    println(<span class="string">"new select team : <span class="variable">$team</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/team-2.png" alt=""></p><p>신규로 조회한 데이터에서도 <code>team name</code>이 변경되지 않은 것을 확인할 수 있습니다. 왜 변경되지 않은 것일 까요?</p><h2><span id="team-엔티티가-변경되지-않은-이유">Team 엔티티가 변경되지 않은 이유</span></h2><h3><span id="jpa-벌크성-작업은-영속성-컨텍스트와-무관">JPA 벌크성 작업은 영속성 컨텍스트와 무관</span></h3><p>업데이트 이후 아래 코드가 <code>team name</code> 변경 전 데이터인 이유를 설명드리겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">    println(<span class="string">"after update team : <span class="variable">$team</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="엔티티-수정-메커니즘">엔티티 수정 메커니즘</span></h4><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/jpa-persistent-dirty-checking.png" alt=""></p><p><strong>엔티티의 변경사항을 을 데이터베이스에 반영하는 것을 변경 감지(dirty checking)이라고 합니다.</strong> JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두고. 플러시 시점에서 스냅샷과 엔티티를 비교해서 변경된 엔티티를 데이터베이스에 반영하게 됩니다. 즉 아래와 같은 절차를 진행하게 됩니다.</p><ol><li><strong>트랜잭션을 커밋 하면 엔티티 매니저 내부에서 먼저 플러시가 호출된다.</strong></li><li><strong>엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.</strong></li><li>변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.</li><li>쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다.</li><li><strong>데이터베이스 트랜잭션을 커밋 한다.</strong></li></ol><h4><span id="벌크-수정-메커니즘">벌크 수정 메커니즘</span></h4><p><strong>하지만 벌크성 작업은 영속성 컨텍스트와 무관합니다.</strong> 벌크 연산은 영속성 컨텍스트를 통하지 않고 아래 그림처럼 <strong>데이터베이스에 직접 쿼리를 진행합니다.</strong></p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/jpa-bulk.png?raw=true" alt=""></p><p><strong>즉 영속성 컨텍스트와 무관하니 기존 영속성 컨텍스트에 존재하는 Team의 name들은 변경이 없는 것입니다.</strong></p><h3><span id="영속성-컨텍스트는-1차-캐시된-것이-우선이다">영속성 컨텍스트는 1차 캐시된 것이 우선이다.</span></h3><p><code>after update team</code>를 조회했을 때는 영속성 컨텍스트와 무관했기 때문에 기존 데이터가 나왔지만 <strong>신규 조회를 한 아래 코드 왜 변경 전 name이 출력 되었을까요? 그 이유는 영속성 컨텍스트 저장 메커니즘에 있습니다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newSelectTeams = query.selectFrom(qTeam).fetch()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (team <span class="keyword">in</span> newSelectTeams) &#123;</span><br><span class="line">    println(<span class="string">"new select team : <span class="variable">$team</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="영속성-컨텍스트-저장-메커니즘">영속성 컨텍스트 저장 메커니즘</span></h4><p><a href="https://cheese10yun.github.io/jpa-persistent-context/">영속성 컨텍스트 1차 캐시 저장 메커니즘</a> 관련 포스팅에서 이미 포스팅한 적이 있습니다. 해당 글을</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/query-result-.png" alt=""></p><p>findById() 같은 경우는 영속성 컨텍스트를 먼저 찾고 영속성 컨텍스트에 해당 엔티티가 있으면 그 값을 바로 리턴합니다. 이를 1차 캐시라고 말합니다. <strong>반면 JPQL은 영속성성 컨텍스트를 먼저 조회하지 않고 데이터베이스에 query 하여 결과를 가져옵니다. 그리고 아래와 같은 흐름으로 영속성 컨텍스트를 저장을 시도합니다.</strong></p><ol><li>JPQL을 호출하면 데이터베이스에 우선적으로 조회한다.</li><li>조회한 값을 영속성 컨텍스트에 저장을 시도한다.</li><li>저장을 시도할 때 해당 데이터가 이미 영속성 컨텍스트에 존재하는 경우(영속성 컨텍스트에서는 식별자 값으로 식별) 데이터베이스에서 조회한 신규 데이터를 버린다.</li></ol><p><strong>즉 이미 영속성컨텍스트에 team들이 존재하기 때문에 신규 조회한 영속성 컨텍스트를 버리게 되는 것입니다.</strong> 영속성 컨텍스트에서는 ID를 기반으로 식별작을 합니다.</p><h2><span id="해결-방법">해결 방법</span></h2><p>해결 방법은 간단합니다. <strong>영속성 컨텍스트를 초기화(clear)을 하면 됩니다.</strong> 영속성 컨텍스트가 초기화됐기 때문에 신규 조회한 <code>team</code> 객체들이 모두 영속성 컨텍스트에 그대로 반영되게 됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">em.clear() <span class="comment">// 영속성 컨텍스트를 초기화 한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> newSelectTeams = query.selectFrom(qTeam).fetch()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (team <span class="keyword">in</span> newSelectTeams) &#123;</span><br><span class="line">    println(<span class="string">"new select team : <span class="variable">$team</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/team-name.png" alt=""></p><p>신규 조회한 <code>team name</code> 제대로 변경된 것을 확인할 수 있습니다.</p><h2><span id="참고">참고</span></h2><ul><li><a href="http://acornpub.co.kr/book/jpa-programmig" rel="external nofollow noopener noreferrer" target="_blank">자바 ORM 표준 JPA 프로그래밍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JPA Bulk 작업을 진행할 때 영속성 컨텍스트의 메커니즘을 이해하지 못한 상태라면 예상하지 못한 문제를 만날 수도 있게 됩니다. 어떤 문제가 있고 이 문제가 왜 발생하는지 정리해 보았습니다.&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;코드&quot;&gt;코드&lt;/sp
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Bulk" scheme="https://cheese10yun.github.io/tags/Bulk/"/>
    
  </entry>
  
  <entry>
    <title>JPA 플러시 정리</title>
    <link href="https://cheese10yun.github.io/jpa-flush/"/>
    <id>https://cheese10yun.github.io/jpa-flush/</id>
    <published>2020-01-28T15:00:00.000Z</published>
    <updated>2020-02-11T14:42:25.161Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://acornpub.co.kr/book/jpa-programmig" rel="external nofollow noopener noreferrer" target="_blank">자바 ORM 표준 JPA 프로그래밍</a>을 보고 플러시 관련 내요을 정리한 정리한 내용 입니다.</p></blockquote><h2><span id="플러시-란">플러시 란?</span></h2><p>JPA는 엔티티를 영속성 컨텍스트에서 관리합니다. 영속성 컨텍스트에 있는 내용을 데이터베이스에 반영하는 것을 플러시라고 합니다. 보통 트랜잭션을 커밋하면 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화(등록, 수정, 삭제) 작업을 진행하게 됩니다.</p><h2><span id="엔티티-등록">엔티티 등록</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EntityMaanger em  = emf.createEnttiyManager();</span><br><span class="line">ENtityTranscation transaction = em.getTransaction();</span><br><span class="line"><span class="comment">// 엔티티 매니저는 데이터 변경 시 트랜잭션을 시작해야한다.</span></span><br><span class="line"></span><br><span class="line">transaction.begin();</span><br><span class="line"></span><br><span class="line">em.persist(memberA);</span><br><span class="line">em.persist(memberB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 여기까지 Insert SQL을 데이터베이스에 보내지 않는다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit을 하는 순간 데이터베이스에 Insert SQL을 보낸다</span></span><br><span class="line">transaction.commit();</span><br></pre></td></tr></table></figure><p>엔티티 <strong>매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모아둔다.</strong> 그리고 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내느데 이것을 <strong>트랜잭션을 지원하는 쓰기 지연</strong> 이라 한다.</p><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/jpa-insert-persistent.png" alt=""><br>회원 A를 영속화 했다. 영속성 컨텍스트는 1차 캐시에 회원 엔티티를 저장하면서 동시에 회원 엔티티 정보로 등록 쿼리를 만든다. 그리고 만들어진 등록 쿼리를 쓰기 지연 SQL 저장소에 보관한다.</p><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/jpa-insert-persistent-2.png" alt=""><br>다음으로 회원 B를 영속화했다. 마찬가지로 회원 엔티티 정보로 등록 쿼리를 생성해서 쓰지 지연 SQL 저장소에 보관한다. 현재 쓰기 지연 SQL저장소 에는 등록 쿼리가 2건이 저장되어 있다.</p><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/jpa-insert-persistent-3.png" alt=""></p><p>마지막으로 트랜잭션을 커밋했다. <strong>트랜잭션을 커밋하면 엔티티 매니저는 우선 영속성 컨텍스트를 플러시한다. 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업인데 이때 등록, 수정, 삭제한 엔티티를 데이터베이스에 반영한다.</strong></p><p>즉, 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보낸다. 이렇게 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화한 후에 실제 데이터베이스 트랜잭션을 커밋한다.<br>(flush가 먼저 동작하고 (데이터베이스에 동기화한 후에) 실제 데이터베이스 트랜잭션을 커밋한다.)</p><h3><span id="트랜잭션을-지원하는-쓰기-지연이-가능한-이유">트랜잭션을 지원하는 쓰기 지연이 가능한 이유</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin(); <span class="comment">// 트랜잭션 시작</span></span><br><span class="line"></span><br><span class="line">save(A);</span><br><span class="line">save(B);</span><br><span class="line">save(C);</span><br><span class="line"></span><br><span class="line">commit(); <span class="comment">// 트랜잭션 커밋</span></span><br></pre></td></tr></table></figure><ol><li>데이터를 저장하는 즉시 등록 쿼리를 데이터베이스에 보낸다. 예제에서 save() 메서드를 호출할 때 마다 즉시 데이터베이스에 등록 쿼리를 보낸다. 그리고 마지막에 트랜잭션을 커밋한다.</li><li>데이터를 저장하면 등록 쿼리를 <strong>데이터베이스에 보내지 않고 메모리에 모아 둔다.</strong> 그리고 <strong>트랜잭션을 커밋할 때 모아둔 등록 쿼리를 데이터베이스에 보낸다.</strong></li></ol><h3><span id="트랜잭션을-지원하는-쓰지-지연과-성능-최적화">트랜잭션을 지원하는 쓰지 지연과 성능 최적화</span></h3><h4><span id="트랜잭션을-지원하는-쓰지-이연과-jdbc-배치">트랜잭션을 지원하는 쓰지 이연과 JDBC 배치</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert(member1); <span class="comment">// INSERT INTO ...</span></span><br><span class="line">insert(member2); <span class="comment">// INSERT INTO ...</span></span><br><span class="line">insert(member3); <span class="comment">// INSERT INTO ...</span></span><br><span class="line">insert(member4); <span class="comment">// INSERT INTO ...</span></span><br><span class="line">insert(member5); <span class="comment">// INSERT INTO ...</span></span><br><span class="line"></span><br><span class="line">commit();</span><br></pre></td></tr></table></figure><p><strong>네트워크 호출 한번은 단순한 메소드를 수만 번 호출하는 것보다 더 큰 비용이 든다.</strong> 이 코드는 5번의 INSERT SQL과 1번의 커밋으로 총 6번 데이터 베이스와 통신한다. 이것을 최적화하라면 5번의 INSERT SQL을 모아서 한 번에 데이터베이스로 보내면 된다. <strong>JDBC가 제공하는 SQL 배치 기능을 사용하면 SQL을 모아서 데이터베이스에 한 번에 보낼 수 있다.</strong> 하지만 이 기능을 사용하라면 많은 코드를 수정해야한다. <strong>JPA는 플러시 기능이 있이므로 SQL 배치 기능을 효과적으로 사용할 수 있다.</strong></p><p><strong><code>hibernate.jdbc.batch_size</code> 속성의 값을 50으로 주면 최대 50건씩 모아서 SQL 배치를 실행한다. 하지만 SQL 배치는 같은 SQL일 때만 유효하다. 중간에 다른 처리가 들어가면 SQL 배치를 다시 시작한다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">em.persist(<span class="keyword">new</span> Member()); <span class="comment">// 1</span></span><br><span class="line">em.persist(<span class="keyword">new</span> Member()); <span class="comment">// 2</span></span><br><span class="line">em.persist(<span class="keyword">new</span> Member()); <span class="comment">// 3</span></span><br><span class="line">em.persist(<span class="keyword">new</span> Member()); <span class="comment">// 4</span></span><br><span class="line">em.persist(<span class="keyword">new</span> Orders()); <span class="comment">// 1-1, 다른 SQL이 추가 되었기 때문에  SQL 배치를 다시 시작 해야 한다</span></span><br><span class="line">em.persist(<span class="keyword">new</span> Member()); <span class="comment">// 1</span></span><br><span class="line">em.persist(<span class="keyword">new</span> Member()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>1,2,3,4를 모아서 하나의 SQL 배치를 실행하고 1-1를 한 번 실행하고 1,2을 모아서 실행한다. 따라서 총 3번의 SQL 배치를 실행한다.</p><p>모든 경우에 사용할 수 있는 것은 아니다. 엔티티가 영속 상태가 되려면 식별자가 꼭 필요하다. <strong>그런데 IDENTITY 식별자 생성 전략은 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있으므로 em.persist()를 호출하는 즉시 INSERT SQL이 데이터베이스에 전달된다. 따라서 쓰지 지연을 활용한 성능 최적화를 할 수가 없다.</strong></p><h4><span id="트랜잭션을-지원하는-쓰기-지연과-애플리케이션-확장성">트랜잭션을 지원하는 쓰기 지연과 애플리케이션 확장성</span></h4><p><strong>트랜잭션을 지원하는 쓰기 지연의 가장큰 장점은 데이터베이스 테이블 로우에 락이 걸리는 시간을 최소한다는 것이다. 이 기능은 트랜잭션을 커밋해서 영속성 컨텍스트를 플러시하기 전까지는 데이터베이스에 데이터를 등록, 수정, 삭제 하지 않는다. 따라서 커밋 전까지 데이터베이스 로우에 락을 걸지 않는다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update(memberA); <span class="comment">// UPDATE SQL Member A</span></span><br><span class="line">비즈니스로직A(); <span class="comment">// UPDATE SQL ...</span></span><br><span class="line">비즈니스로직B(); <span class="comment">// UPDATE SQL ...</span></span><br><span class="line">commit();</span><br></pre></td></tr></table></figure><p><strong>JPQL를 사용하지 않고 SQL 직접다루면 update(memberA)를 호출할 때 UPDATE SQL을 실행하면 데이터베이스 테이블 로우에 락을 건다. 이 락은 비즈니스 <code>로직A()</code>, <code>비즈니스 로직B()</code>를 모두 수행하고 <code>commit()</code>을 호출할 때까지 유지된다. 트랜잭션 격리 수준에 따라 다르지만 보통 많이 사용하는 커밋된 읽기 Read Committed 격리 수준이나 그 이상에는 데이터베이스에 현재 수정 중인 데이터(로우)를 수정하려는 다른 트랜잭션은 락이 풀릴 때까지 대기한다.</strong></p><p><strong>JPA는 커밋을 해야 플러시를 호출하고 데이터베이스에 수정 쿼리를 보낸다.</strong> 예제에서 <code>commit()</code>을 호출할 때 UPDATE SQL을 실행하고 바로 데이터베이스 트랜잭션을 커밋한다. 쿼리를 보내고 보내고 바로 트랜잭션을 커밋하므로 결과적으로 데이터베이스에 락이 걸리는 시간을 최소화 한다. <strong>이는 동시에 더 많은 트래잭션을 처리할 수 있다는 장점이 된다.</strong></p><h2><span id="엔티티-수정">엔티티 수정</span></h2><h3><span id="변경-감지">변경 감지</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EntityMaanger em  = emf.createEnttiyManager();</span><br><span class="line">ENtityTranscation transaction = em.getTransaction();</span><br><span class="line">transaction.begin(); // 트랜잭션 시작</span><br><span class="line"></span><br><span class="line">// 영성속 텐티티 조회</span><br><span class="line">Member memberA = em.find(Member.class, &quot;memberA&quot;);</span><br><span class="line"></span><br><span class="line">// 영속성 엔티티 데이터 수정</span><br><span class="line"></span><br><span class="line">memberA.setUsername(&quot;hi&quot;);</span><br><span class="line">memberA.setAge(10);</span><br><span class="line"></span><br><span class="line">//em.update(member) 이런 코드가 있어야하지 않을까?</span><br><span class="line"></span><br><span class="line">transaction.commit(); // 트랜잭션 커밋</span><br></pre></td></tr></table></figure><p><strong>엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지(dirty checking) 이라 한다.</strong><br><img src="https://github.com/cheese10yun/TIL/raw/master/assets/jpa-persistent-dirty-checking.png" alt=""><br>JPA는 엔티티를 영속성 컨텍스트에 보관할 때, <strong>최초 상태를 복사해서 저장해두는데 이것을 스냅샷이리고 한다.</strong> 그리고 플러시 시점에서 스냡샵과 엔티티를 비교해서 변경된 엔티티를 찾는다.</p><ol><li><strong>트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시가 호출된다.</strong></li><li>엔티티와 스냅샵을 비교해서 변경된 엔티티를 찾는다.</li><li><strong>변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.</strong></li><li>쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다.</li><li>데이터베이스 트랜잭션을 커밋한다.</li></ol><h3><span id="읽기-전용-트랜잭션">읽기 전용 트랜잭션</span></h3><p>스프링 프레임워크를 사용하면 트랜잭션을 읽기 전용 모드로 설정할 수 있다. <code>@Transactional(readOnly = true)</code> 옵션을 주면 스프링 프레임워크가 하이버네이트 세션의 플러시 모드를 MANUAL로 설정한다 <strong>그렇게되면 강제로 플러시를 호출하지 않은 한 플러시가 일어나지 않는다.</strong> 따라서 트랜잭션을 커밋해도 영속성 컨텍스트 플러시하지 않는다. 영속성 컨텍스트를 플러시하지 않으니 엔티티의 등록, 수정, 삭제는 당연히 동작하지 않는다. <strong>플러시 할 때 일어나는 스냅샷비교와 같은 무거운 로직을 수행하지 않으므로 성능에 향상된다.</strong></p><p><strong>변경 감지는 영속성 컨텍스타 관리하는 영속 상태의 엔티티에만 적용된다.</strong> 비영속, 준영속처럼 영속성 컨텍스트의 관리를받지 못하는 엔티티는 값을 변경해도 데이터베이스에 반영되지 않는다.</p><h2><span id="엔티티-삭제">엔티티 삭제</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Member meberA = em.find(Member.class, <span class="string">"memberA"</span>); <span class="comment">// 삭제할 대상 엔티티 조회</span></span><br><span class="line">em.remove(memberA); <span class="comment">// 엔티티 삭제</span></span><br></pre></td></tr></table></figure><p><strong>엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야한다.</strong> em.remove()에 삭제 대상 엔티티를 넘겨주면 엔티티를 삭제한다. 물론 엔티티를 즉시 삭제하는 것이 아니라 엔티티 등록과 비슷하게 삭제 쿼리를 쓰기 지연 데이터베이스에 삭제 쿼리를 전달한다.</p><h2><span id="영속성-컨텍스트를-플러시-하는-3-가지-방법">영속성 컨텍스트를 플러시 하는 3 가지 방법</span></h2><p><strong>플러시는 영속성 컨텍스의 변경 내용을 데이터베이스에 반영한다.</strong> 플러시를 실행하면 구체적으로 다음과 같은 일이 일어난다</p><ol><li>변경 감자기 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교 해서 수정된 엔티티를 찾는다. 수정 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 등록한다.</li><li>쓰기 지연 SQL 의 저장소의 쿼리를 데이터베이스에 전송한다. (등록, 수정, 삭제 쿼리)</li></ol><p>영속성 컨텍스트를 플러시 하는 방법은 3가지다.</p><ol><li>em.flush()를 직접 호출한다.</li><li>JPQL 쿼리 실행 시 플러시가 자동 호출된다.</li><li>트랜잭션 커밋 시 플러시가 자동 호출된다.</li></ol><h3><span id="플러시를-직접-호출하는-경우">플러시를 직접 호출하는 경우</span></h3><p>엔티티 매니저의 flush() 메서드를 직접 호출해서 영속성 컨텍스트를 강제로 플러시 한다. <strong>테스트나 다른 프레임워크와 JPA 함께 사용할 때는 제외하고 거의 사용하지 않는다.</strong></p><h3><span id="트랜잭션-커밋-시-플러시가-자동-호출">트랜잭션 커밋 시 플러시가 자동 호출</span></h3><p><strong>데이터베이스에 변경 내용을 SQL로 전달하지 않고 트랜잭션만 커밋하면 어떤 데이터도 데이터베이스에 반영되지 않는다. 따라서 트랜잭션을 커밋하기 전에 꼭 플러시를 호출해서 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영해야 한다.</strong> JPA는 이런 문제를 예방하기 위해서 트랜잭션 커밋할 때 플러시를 자동으로 호출한다.</p><h3><span id="jpql-쿼리-실행시-플러시-자동-호출">JPQL 쿼리 실행시 플러시 자동 호출</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `JPQL 쿼리 실행시 플러시 자동 호출`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> teamA = Team(<span class="string">"teamA"</span>)</span><br><span class="line">    <span class="keyword">val</span> teamB = Team(<span class="string">"teamB"</span>)</span><br><span class="line"></span><br><span class="line">    em.persist(teamA)</span><br><span class="line">    em.persist(teamB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> teams = query.select(qTeam)</span><br><span class="line">            .from(qTeam)</span><br><span class="line">            .fetch()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">        println(<span class="string">"team : <span class="variable">$team</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JPQL이나 QueryDSL 같은 객체지향 <strong>쿼리를 호출할 플러시가 실행된다.</strong></p><ol><li><code>teamA</code>, <code>teamB</code>를 영속성 컨텍스트에 저장한다.</li><li>QueryDSL으로 Team 전체를 조회 한다.</li><li>QueryDSL 쿼리 시점에 <code>teamA</code>, <code>teamB</code> 플러시를 이르켜 데이터베이스에 commit하지 않았다면 QueryDsl으로 조회한 값은 없을 것이다.</li></ol><p>이런 결과가 나오기 때문에 쿼리를 실행하기 직전에 영속성 컨텍스트를 플러시해서 변경 내용을 데이터베이스에 반영해야 한다. JPA는 이런 문제를 예방하기 위해서 JPQL을 실행할 때도 플러시르 자동 호출한다. <strong>참고로 식별자를 기준으로 조회하는 find() 메서드는 호출되지 않는다.</strong></p><h2><span id="참고">참고</span></h2><ul><li><a href="http://acornpub.co.kr/book/jpa-programmig" rel="external nofollow noopener noreferrer" target="_blank">자바 ORM 표준 JPA 프로그래밍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://acornpub.co.kr/book/jpa-programmig&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;자바 ORM 표준 JP
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Flush" scheme="https://cheese10yun.github.io/tags/Flush/"/>
    
  </entry>
  
  <entry>
    <title>JPA 영속성 컨텍스트 주의 점</title>
    <link href="https://cheese10yun.github.io/jpa-persistent-context/"/>
    <id>https://cheese10yun.github.io/jpa-persistent-context/</id>
    <published>2020-01-26T15:00:00.000Z</published>
    <updated>2020-01-28T13:43:23.224Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="엔티티-객체">엔티티 객체</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"member"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>(</span><br><span class="line">        <span class="meta">@Column(name = <span class="meta-string">"username"</span>, nullable = false)</span></span><br><span class="line">        <span class="keyword">var</span> username: String,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Column(name = <span class="meta-string">"age"</span>, nullable = false)</span></span><br><span class="line">        <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ManyToOne(fetch = FetchType.LAZY, optional = false)</span></span><br><span class="line">        <span class="meta">@JoinColumn(name = <span class="meta-string">"team_id"</span>, nullable = false)</span></span><br><span class="line">        <span class="keyword">var</span> team: Team</span><br><span class="line">) : EntityAuditing()</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"team"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span></span>(</span><br><span class="line">        <span class="meta">@Column(name = <span class="meta-string">"name"</span>, nullable = false)</span></span><br><span class="line">        <span class="keyword">var</span> name: String</span><br><span class="line">) : EntityAuditing() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="meta-string">"team"</span>)</span></span><br><span class="line">    <span class="keyword">var</span> members: MutableList&lt;Member&gt; = mutableListOf()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엔티티 관계는 위와 같습니다.</p><h2><span id="테스트-코드">테스트 코드</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.querydsl.domain.QMember.member <span class="keyword">as</span> qMember</span><br><span class="line"><span class="keyword">import</span> com.example.querydsl.domain.QTeam.team <span class="keyword">as</span> qTeam</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersistenceContextTest</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> em: EntityManager</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> query = JPAQueryFactory(em)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `persistence context test`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">val</span> teamA = Team(<span class="string">"teamA"</span>)</span><br><span class="line">        em.persist(teamA)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> member1 = Member(username = <span class="string">"member1"</span>, age = <span class="number">10</span>, team = teamA)</span><br><span class="line">        <span class="keyword">val</span> member2 = Member(username = <span class="string">"member2"</span>, age = <span class="number">20</span>, team = teamA)</span><br><span class="line">        em.persist(member1)</span><br><span class="line">        em.persist(member2)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="keyword">val</span> team = query</span><br><span class="line">                .selectFrom(qTeam)</span><br><span class="line">                .join(qTeam.members, qMember).fetchJoin()</span><br><span class="line">                .where(qTeam.name.eq(<span class="string">"teamA"</span>))</span><br><span class="line">                .fetchOne()!!</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        <span class="keyword">val</span> members = team.members</span><br><span class="line">        then(members).anySatisfy &#123;</span><br><span class="line">            then(it.username).isIn(<span class="string">"member1"</span>, <span class="string">"member2"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>teamA</code>를 영속화 이후, <code>member1</code>, <code>member2</code>를 영속화를 진행합니다. <code>member1</code>, <code>member2</code>는 <code>teamA</code> 소속이 됩니다.</p><p>그리고 <code>fetch join</code>통해서 <code>teamA</code>와 <code>teamA</code>에 속한 <code>member</code>를 조회하고 있습니다. 그리고 <code>then</code>절에서 <code>member1</code>, <code>member2</code>가 <code>teamA</code>에 있는지 검증을 진행합니다.</p><p><strong>이 테스트 코드는 실패합니다.</strong></p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/team-members-result.png" alt=""></p><p>디버깅 모드로 보면 <code>memebers</code> szie가 0인 것을 확인할 수 있습니다. 그렇다면 실제 데이터베이에 <code>member1</code>, <code>member2</code>가 영속화가 안 된 것일 까요?</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/insert-result.png" alt=""></p><p><code>teamA</code> insert, <code>member1</code>, <code>memeber2</code> insert 쿼리를 확인할 수 있습니다. 물론 insert query log를 출력했더라도 실제 데이터베이스에 insert 됐다고는 볼 수 없습니다. <strong>정확하게 테스트하기 위해서는 실제 데이터베이스에 저장됐는지 확인하는 것이 바람직합니다.</strong> 해당 경우는 실제 데이터베이스에 commit까지 되는 경우입니다.</p><p>그렇다면 왜 해당 테스트 코드가 실패할까요? 그 이유를 알기 위해서는 영속성 컨텍스트의 1차 케시의 저장 메커니즘을 이해해야 합니다.</p><h2><span id="영속성-컨텍스트-1차-캐시-저장-메커니즘">영속성 컨텍스트 1차 캐시 저장 메커니즘</span></h2><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/query-result-.png" alt=""></p><p><code>findById()</code> 같은 경우는 영속성 컨텍스트를 먼저 찾고 영속성 컨텍스트에 해당 엔티티가 있으면 그 값을 바로 리턴합니다. 이를 1차 캐시라고 말합니다. <strong>반면 JPQL은 영속성성 컨텍스트를 먼저 조회하지 않고 데이터베이스에 query하여 결과를 가져옵니다.</strong> 그리고 아래와 같은 흐름으로 영속성 컨텍스트를 저장을 시도합니다.</p><ol><li><strong>JPQL을 호출하면 데이터베이스에 우선적으로 조회한다.</strong></li><li>조회한 값을 영속성 컨텍스트에 저장을 시도한다.</li><li><strong>저장을 시도할 때 해당 데이터가 이미 영속성 컨텍스트에 존재하는 경우((영속성 컨텍스트에서는 식별자 값으로 식별)) 데이터베이스에서 조회한 신규 데이터를 버린다.</strong></li></ol><h2><span id="테스트가-실패하는-이유">테스트가 실패하는 이유</span></h2><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/query-result-.png" alt=""></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `persistence context test`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    <span class="keyword">val</span> teamA = Team(<span class="string">"teamA"</span>)</span><br><span class="line">    em.persist(teamA)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> member1 = Member(username = <span class="string">"member1"</span>, age = <span class="number">10</span>, team = teamA)</span><br><span class="line">    <span class="keyword">val</span> member2 = Member(username = <span class="string">"member2"</span>, age = <span class="number">20</span>, team = teamA)</span><br><span class="line">    em.persist(member1)</span><br><span class="line">    em.persist(member2)</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>teamA</code>, <code>member1</code>, <code>member2</code> 영속화를 진행합니다. 이때 위 그림처럼 영속성 컨텍스트에 저장됩니다.</p><p>그리고 아래 코드의 <code>when</code> 절을 보겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//when</span></span><br><span class="line"><span class="keyword">val</span> team = query</span><br><span class="line">        .selectFrom(qTeam)</span><br><span class="line">        .join(qTeam.members, qMember).fetchJoin()</span><br><span class="line">        .where(qTeam.name.eq(<span class="string">"teamA"</span>))</span><br><span class="line">        .fetchOne()!!</span><br></pre></td></tr></table></figure><p>위에서 언급했던 것처럼 JPQL은 영속성 컨텍스트의 데이터를 조회하지 않고 <strong>데이터베이스에 아래의 query를 진행합니다.</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    team0_.id <span class="keyword">as</span> id1_2_0_,</span><br><span class="line">    members1_.id <span class="keyword">as</span> id1_1_1_,</span><br><span class="line">    team0_.created_at <span class="keyword">as</span> created_2_2_0_,</span><br><span class="line">    team0_.updated_at <span class="keyword">as</span> updated_3_2_0_,</span><br><span class="line">    team0_.name <span class="keyword">as</span> name4_2_0_,</span><br><span class="line">    members1_.created_at <span class="keyword">as</span> created_2_1_1_,</span><br><span class="line">    members1_.updated_at <span class="keyword">as</span> updated_3_1_1_,</span><br><span class="line">    members1_.age <span class="keyword">as</span> age4_1_1_,</span><br><span class="line">    members1_.team_id <span class="keyword">as</span> team_id6_1_1_,</span><br><span class="line">    members1_.username <span class="keyword">as</span> username5_1_1_,</span><br><span class="line">    members1_.team_id <span class="keyword">as</span> team_id6_1_0__,</span><br><span class="line">    members1_.id <span class="keyword">as</span> id1_1_0__ </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    team team0_ </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">member</span> members1_ </span><br><span class="line">        <span class="keyword">on</span> team0_.id=members1_.team_id </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    team0_.name=?</span><br></pre></td></tr></table></figure><p><code>fetch join</code>를 사용했기 때문에 <code>team</code>, <code>member</code> 객체를 한번에 가져오게 됩니다. <strong>하지만 <code>teamA</code>가 이미 존재 하므로 해당 쿼리를 통해서 가져온 데이터를 버리게 됩니다.</strong></p><h2><span id="해결-하는-방법">해결 하는 방법</span></h2><h3><span id="team-객체에-member-추가하기">Team 객체에 Member 추가하기</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `persistence context test`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    <span class="keyword">val</span> teamA = Team(<span class="string">"teamA"</span>)</span><br><span class="line">    em.persist(teamA)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> member1 = Member(username = <span class="string">"member1"</span>, age = <span class="number">10</span>, team = teamA)</span><br><span class="line">    <span class="keyword">val</span> member2 = Member(username = <span class="string">"member2"</span>, age = <span class="number">20</span>, team = teamA)</span><br><span class="line">    em.persist(member1)</span><br><span class="line">    em.persist(member2)</span><br><span class="line"></span><br><span class="line">    teamA.members.add(member1) <span class="comment">// teamA에 member1 추가</span></span><br><span class="line">    teamA.members.add(member2) <span class="comment">// teamA에 member2 추가</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>member1</code>, <code>member2</code>영속화 이후 <code>teamA</code> 객체에 영속화된 member 객체를 추가하는 코드를 작성하면 됩니다.</p><p>그렇게 되면 <code>fetch join</code>을 통해서 데이터베이스에 query를 진행하고 해당 데이터가 영속성 컨텍스트에 이미 있으므로 <strong>데이터를 버리게 되더라도 이미 <code>member1</code>, <code>memeber2</code>가 존재하는 상태이기 때문에 문제가 되지 않습니다.</strong></p><p>양방향 연관 관계의 경우 편의 메서드를 작성해서 이런 문제를 미연에 방지하는 것이 좋습니다. 물론 필요에 따라서 양방향 양방향 연관 관계를 작성하는 것은 상관없지만 <strong>가능하면 단방향 연관 관계를 유지하는 것이 좋다고 생각합니다.</strong></p><p>양방향 관계가 되면 생각보다 신경 쓸 것이 많아지게 되어 복잡도가 증가하게 됩니다. 또 <code>OneToMany</code>, <code>ManyToOne</code> 같은 양방향 연관 관계의 경우 N+1 문제도 신경 쓸 것들이 많아지게 됩니다.</p><h3><span id="영속성-컨텍스트-초기화">영속성 컨텍스트 초기화</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `persistence context test`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    <span class="keyword">val</span> teamA = Team(<span class="string">"teamA"</span>)</span><br><span class="line">    em.persist(teamA)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> member1 = Member(username = <span class="string">"member1"</span>, age = <span class="number">10</span>, team = teamA)</span><br><span class="line">    <span class="keyword">val</span> member2 = Member(username = <span class="string">"member2"</span>, age = <span class="number">20</span>, team = teamA)</span><br><span class="line">    em.persist(member1)</span><br><span class="line">    em.persist(member2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//        teamA.members.add(member1)</span></span><br><span class="line"><span class="comment">//        teamA.members.add(member2)</span></span><br><span class="line">    </span><br><span class="line">    em.flush()</span><br><span class="line">    em.clear()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>em.flush()</code>을 통해서 영속성 컨텍스트의 내용을 데이터베이스에 반영하고 <strong><code>em.clear()</code>을 통해서 영속성 컨텍스트를 모두 초기화 합니다.(영속성 컨텍스트의 데이터를 모두 제거)</strong> 영속성 컨텍스츠가 초기화 되었기 때문에 <code>fetch join</code>의 결과가 모두 영속성 컨텍스트의 반영됩니다.</p><h2><span id="결론">결론</span></h2><p>테스트 코드를 작성할 때 이런 점을 조심하자는 것이 중점은 아닙니다. 중점으로 다루고 싶었던 내용은 영속성 컨텍스트의 저장에 대한 메커니즘입니다. 이 부분은 명확하게 알고 있더라도 영속성 컨텍스트는 실제 보이는 영역이 아니기 때문에 실수하기 좋고  이런 실수를 하더라도 이것을 바로 캐치하기가 어렵습니다. 그래서 정리차 포스팅을 진행하게 되었습니다.</p><h2><span id="참고">참고</span></h2><ul><li><a href="http://acornpub.co.kr/book/jpa-programmig" rel="external nofollow noopener noreferrer" target="_blank">자바 ORM 표준 JPA 프로그래밍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;엔티티-객체&quot;&gt;엔티티 객체&lt;/span&gt;&lt;/h2&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>스프링 Application Event</title>
    <link href="https://cheese10yun.github.io/application-event/"/>
    <id>https://cheese10yun.github.io/application-event/</id>
    <published>2019-11-29T15:00:00.000Z</published>
    <updated>2020-02-29T12:57:10.568Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/application-event" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인할 수 있습니다.</p></blockquote><p>스프링에서는 Application Event를 제공해주고 있습니다. <code>Application Event Publisher</code>, <code>Application Event Subscriber</code> 방식으로 결합도를 낮춰 느슨한 결합 관계를 갖을 수 있습니다.</p><h2><span id="시나리오">시나리오</span></h2><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/event-part-1.png?raw=true" alt=""></p><p>주문 단계에 (주문, 결제)가 완료되면 주문 완료 이후 로직들이 동작해야 합니다. 대표적으로</p><ul><li>장바구니 제거 (장바구니에 등록된 상품 주문시)</li><li>제품 재고 변경</li><li>주문 완료 알람 (시스템, 유저 등등)</li></ul><p>주문 완료 이후 매우 다양한 작업들이 있고 해당 로직들이 <code>OrderService</code>에 모두 구현하는 경우 <strong>강한 결합 관계</strong>를 갖게 되고 변경 및 유지보수에 악영향이 발생하게 됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderService</span></span>(</span><br><span class="line">        ... <span class="comment">// 필요한 의존성 주입, 강한 관계를 갖는 경우 필요한 의존성 들이 많아진다.</span></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">order</span><span class="params">()</span></span>: Order &#123;</span><br><span class="line">        orderRepository.save(order) <span class="comment">// 주문 저장</span></span><br><span class="line">        stockService.adjust(order) <span class="comment">// 재고 조정</span></span><br><span class="line">        cartService.remove(order) <span class="comment">// 장바구니 제거 (장바구니 상품중 주문 완료된 상품 제거)</span></span><br><span class="line">        <span class="keyword">return</span> order</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>OrderService</code> 객체에 의존성 주입받아야 하는 항목들이 많아지는 것이 대표적인 외부와 결합관계를 갖게 되는 대표적인 신호입니다. 주문, 주문 완료 이후 로직이 추가될 때마다 <code>OrderService</code>의 변경이 야기됩니다. 이런 문제를 <code>Application Event</code>으로 쉽게 해결 할 수 있습니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/event-part-2.png?raw=true" alt=""></p><p><code>주문-결제</code> 이후 결제 완료 이벤트를 발생시키고 주문 완료 이후 로직들은 <code>Application Event Subscriber</code>에서 구현하게 작성하는 구조를 갖을 수 있습니다. 그렇게 되면 <code>OrderService</code>에 필요 의존성이 줄게 되고 자연스럽게 해당 서비스의 책임이 작아지게 되며 이벤트에 의해 느슨한 결합관계를 갖게 됩니다.</p><h2><span id="구현">구현</span></h2><p>주문 완료 이후 구매한 제품중 장바구니에 있는 제품을 제거 하는 로직을 구현 했습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderService</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> orderRepository: OrderRepository,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> itemRepository: ItemRepository,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> eventPublisher: ApplicationEventPublisher</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">order</span><span class="params">(itemCode: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: Order &#123;</span><br><span class="line">        <span class="keyword">val</span> items = itemRepository.findByCodeIn(itemCode) <span class="comment">// 상품(Item) 조회</span></span><br><span class="line">        <span class="keyword">val</span> orderItems: MutableList&lt;OrderItem&gt; = mutableListOf()</span><br><span class="line">        items.mapTo(orderItems) &#123; OrderItem(it.code, it.price, it.name) &#125;</span><br><span class="line">        <span class="keyword">val</span> order = orderRepository.save(Order(orderItems))</span><br><span class="line">        eventPublisher.publishEvent(OrderCompletedEvent(itemCode)) <span class="comment">// 주문 완료 이벤트 발생, 주문한 아이템 code 전송</span></span><br><span class="line">        <span class="keyword">return</span> order</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>요청 받은 상품(Item)를 주문 하고, 주문 완료 event를 발생시키게 됩니다. 장바구니 제거 관련 코드는 존재하지 않고 주문 완료 이벤트만 발생시킵니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderEventHandler</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> cartRepository: CartRepository</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">orderEventHandler</span><span class="params">(event: <span class="type">OrderCompletedEvent</span>)</span></span> &#123;</span><br><span class="line">        cartRepository.deleteAllByCodes(codes = event.itemCodes)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이벤트 리스너를 담당합니다. 주문 완료 이벤트가 발생하면 해당 리스너가 동작하게 되고 장바구니에서 주문 상품들을 제거하는 코드입니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/application-event&quot; rel=&quot;external nofollow noopener no
      
    
    </summary>
    
    
      <category term="트랜잭션" scheme="https://cheese10yun.github.io/tags/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"/>
    
  </entry>
  
  <entry>
    <title>스프링 트랜잭션 단위</title>
    <link href="https://cheese10yun.github.io/transacion-group/"/>
    <id>https://cheese10yun.github.io/transacion-group/</id>
    <published>2019-11-22T15:00:00.000Z</published>
    <updated>2019-11-30T15:03:24.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/kotlin-junit5" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인할 수 있습니다.</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/sample"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleController</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> aRepository: ARepository,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> bRepository: BRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transaction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        aRepository.save(A(<span class="string">"A"</span>))</span><br><span class="line">        bRepository.save(B(<span class="string">"B"</span>)) <span class="comment">// 여기에서 exception 발생시 위 save는 Rollback 되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bRepository.save(B(&quot;B&quot;))</code> 에서 예외가 발생했을 경우 트랜잭션 단위는 클라스 단위로 지정되기 때문에 <code>aRepository.save(A(&quot;A&quot;))</code> Rollback 되지 않습니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/transacion-proxy.png?raw=true" alt=""></p><p>스프링 부트에서는 기본적으로 CGLIB Proxy 방식으로 트랜잭션을 처리합니다. (이전에는  Dynamic Proxy 패턴) Proxy 패턴을 사용하기 때문에 클래스 단위로 트랜잭션이 시작되고 묶이게 됩니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/transacion-group.png?raw=true" alt=""></p><p>트랜잭션 단위를 보면 위와 같습니다. Proxy 방식이기 때문에 클래스 단위로 묶이게 됩니다. 그렇가면 JPA Repository는 interface인데 어떻게 트랜잭션이 발생하게 되는지 의문을 갖는 분들도 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ARepository</span> : <span class="type">JpaRepository</span>&lt;<span class="type">A, Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/jpa-simple-repository.png?raw=true" alt=""></p><p><code>JpaRepository</code> 인터페이스의 세부 구현체가 <code>SimpleJpaRepository</code>가 있습니다. 세부 코드를 보면 아래와 같습니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/jpa-simple-repository-save.png?raw=true" alt=""></p><p><code>save()</code> 메서드에 <code>@Transactional</code>이 있고 여기에서 트랜잭션이 동작하게 됩니다. 다시 본론으로 돌아와서 아래 그림처럼 트랜잭션 그룹이 다르기 때문에 commit, rollback 기준도 클래스를 기반으로 나뉘게 됩니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/transacion-group.png?raw=true" alt=""></p><p>그렇다면 위 두 개의 트랜잭션을 묶을려면 어떻게 해야할까요? 답은 간단합니다 이 두개를 묶는 트랜잭션을 설정하면 됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/sample"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleController</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> aRepository: ARepository,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> bRepository: BRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// aRepository, bRepository 트랜잭션을 묶는다.</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transaction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        aRepository.save(A(<span class="string">"A"</span>))</span><br><span class="line">        bRepository.save(B(<span class="string">"B"</span>)) <span class="comment">// 여기에서 exception 발생시 위 save는 Rollback 된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Transactional</code>을 추가하게 되면 <code>aRepository, bRepository</code> 트랜잭션이 같이 묶이게 됩니다.(물론 컨트롤러에 추가하는 것보다 별도의 트랜잭션를 담당하는 Service 영역을 추가하는 것이 바람직합니다.)</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/transacion-group-2.png?raw=true" alt=""></p><p>이렇게 되면 두 트랜잭션이 같이 묶이게 되고 <code>bRepository.save(B(&quot;B&quot;))</code> 에서 exception이 발생하게 되면 <code>bRepository.save(B(&quot;B&quot;))</code>, <code>aRepository.save(A(&quot;A&quot;))</code>이 모두 rollback이 진행됩니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/kotlin-junit5&quot; rel=&quot;external nofollow noopener norefe
      
    
    </summary>
    
    
      <category term="트랜잭션" scheme="https://cheese10yun.github.io/tags/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"/>
    
  </entry>
  
  <entry>
    <title>스프링 Immutable으로 Properties 설정하기</title>
    <link href="https://cheese10yun.github.io/immutable-properties/"/>
    <id>https://cheese10yun.github.io/immutable-properties/</id>
    <published>2019-11-19T15:00:00.000Z</published>
    <updated>2019-11-23T12:58:15.029Z</updated>
    
    <content type="html"><![CDATA[<p><strong>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/kotlin-junit5" rel="external nofollow noopener noreferrer" target="_blank">Github</a>에 공개되어 있습니다.</strong></p><p>Spring Boot 2.2 버전에서부터는 Immutable으로 Properties 설정을 할 수 있습니다. 커스텀 하게 설정한 값들은 Properties 객체로 관리하는 것이 좋습니다. 해당 내용은 <a href="https://github.com/cheese10yun/spring-jpa-best-practices/blob/master/doc/step-10.md" rel="external nofollow noopener noreferrer" target="_blank">Properties 설정값 가져오기</a>를 참조하시면 됩니다. 기존 Properties의 단점은 Mutable이라는 점입니다. 아래 예제 코드에서 설명드리겠습니다.</p><h2><span id="기존-mutable-properties-방법">기존 Mutable Properties 방법</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleProperties</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> auth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter, setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>기존 방식은 위처럼 setter 기반으로 바인딩 되기 때문에 해당 Properties 설정은 언제든지 변경될 가능성이 있습니다.</strong> 이런 단점을 스프링 부트 2.2에서는 생성자 바인딩을 지원해서 해결했습니다.</p><h2><span id="immutable-properties-방법">Immutable Properties 방법</span></h2><p>해당 예제는 Kotlin <code>data class</code> 기준으로 작성했습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = <span class="meta-string">"user"</span>)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProperties</span></span>(</span><br><span class="line">        <span class="meta">@field:Email</span></span><br><span class="line">        <span class="keyword">val</span> email: String,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@field:NotEmpty</span></span><br><span class="line">        <span class="keyword">val</span> nickname: String,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@field:Min</span>(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">val</span> age: <span class="built_in">Int</span>,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@field:NotNull</span></span><br><span class="line">        <span class="keyword">val</span> auth: <span class="built_in">Boolean</span>,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@field:Min</span>(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">val</span> amount: <span class="built_in">Double</span>,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@DateTimeFormat(pattern = <span class="meta-string">"yyyy-MM-dd"</span>)</span></span><br><span class="line">        <span class="meta">@field:NotNull</span></span><br><span class="line">        <span class="keyword">val</span> date: LocalDate</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>사용법은 간단합니다. <code>@ConstructorBinding</code>을 추가하고 <code>data class</code>으로 넘겨받을 값을 생성자로 지정합니다. 위처럼 작성하면 객체는 Immutable 상태가 됩니다. <strong>스프링 부트 2.2.1 버전부터는 <code>@ConfigurationProperties</code> scanning 방식이 disabled 되면서 <code>@EnableConfigurationProperties</code>을 따로 지정해야 합니다. 자세한 내용은 <a href="https://github.com/spring-projects/spring-boot/issues/18674" rel="external nofollow noopener noreferrer" target="_blank">여기</a>를 참고하세요.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(UserProperties::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinJunit5Application</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;KotlinJunit5Application&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2.1 버전 부터는 <code>@EnableConfigurationProperties</code>으로 클래스를 지정해야합니다. <code>@Validated</code> 어노테이션으로 properteis에 대한 검증도 가능합니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">  email:</span> <span class="string">"yuntest.com"</span></span><br><span class="line"><span class="attr">  nickname:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">  auth:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  amount:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  date:</span> <span class="string">"2019-10-10"</span></span><br></pre></td></tr></table></figure><p>위 처럼 유효하지 않은 값들에 대해서 아래 화면처럼 검증할 수 있습니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/kotlin-junit5//img/error-img.png" alt=""></p><p>스프링 부트가 구동될 때 해당 값에 대한 유효성 검사를 어노테이션 기반으로 쉽게 검증할 수 있습니다. <strong>해당 값이 유효하지 않은 경우 스프링이 구동되지 않기 때문에 장점이 있습니다.</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">  email:</span> <span class="string">"yun@test.com"</span></span><br><span class="line"><span class="attr">  nickname:</span> <span class="string">"yun"</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">28</span></span><br><span class="line"><span class="attr">  auth:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  amount:</span> <span class="number">101</span></span><br><span class="line"><span class="attr">  date:</span> <span class="string">"2019-10-10"</span></span><br></pre></td></tr></table></figure><p>위 <code>yml</code> 처럼 유효한 값을 입력하면 정상적으로 동작하는 것을 확인할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppRunner</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> userProperties: UserProperties) :ApplicationRunner&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">(args: <span class="type">ApplicationArguments</span>?)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"====================="</span>)</span><br><span class="line">        println(userProperties.toString())</span><br><span class="line">        println(<span class="string">"====================="</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/kotlin-junit5//img/properteis-result.png" alt=""><br>값들이 유요한 경우 객체에 바인딩 되는 것을 학인할 수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/kotlin-junit5&quot; rel=&quot;external nofollow noopener noreferrer&quot;
      
    
    </summary>
    
    
      <category term="properties" scheme="https://cheese10yun.github.io/tags/properties/"/>
    
  </entry>
  
  <entry>
    <title>Junit5 with Spring boot</title>
    <link href="https://cheese10yun.github.io/junit5-in-spring/"/>
    <id>https://cheese10yun.github.io/junit5-in-spring/</id>
    <published>2019-11-03T09:11:20.000Z</published>
    <updated>2019-11-04T12:56:30.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/kotlin-junit5" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인해주세요.</p></blockquote><p>Spring boot 2.2 버전부터는 Junit5 디펜던시를 기본으로 포함하고 있습니다. Junit5 주요 테스트 어노테이션과 Spring boot에서 활용법을 정리해보았습니다.</p><h2><span id="valuesource">@ValueSource</span></h2><p><code>@ValueSource</code>어노테이션을 사용하면 배열을 값을 테스트 메서드로 손쉽게 전달할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(strings = [<span class="meta-string">""</span>, <span class="meta-string">" "</span>])</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `isBlank `<span class="params">(value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    print(<span class="string">"value: <span class="variable">$value</span> "</span>) <span class="comment">// value:  value:</span></span><br><span class="line">    assertThat(value.isBlank()).isTrue()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = [1, 2, 3, 4])</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `ints values`<span class="params">(value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    print(<span class="string">"value: <span class="variable">$value</span> "</span>) <span class="comment">// value: 1 value: 2 value: 3 value: 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Int, String 이 이외에도 기본형 데이터 타입을 지원하고 있습니다.</p><h2><span id="enumsource">EnumSource</span></h2><p><code>@EnumSource</code> 어노테이션을 통해서 Enum을 효율적으로 테스트 할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Quarter</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>, <span class="keyword">val</span> description: String) &#123;</span><br><span class="line">    Q1(<span class="number">1</span>, <span class="string">"1분기"</span>),</span><br><span class="line">    Q2(<span class="number">2</span>, <span class="string">"2분기"</span>),</span><br><span class="line">    Q3(<span class="number">3</span>, <span class="string">"3분기"</span>),</span><br><span class="line">    Q4(<span class="number">4</span>, <span class="string">"4분기"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 분기를 뜻하는 Enum을 위와 같이 정리했습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@EnumSource(Quarter::class)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `분기의  value 값은 1 ~ 4 값이다`<span class="params">(quarter: <span class="type">Quarter</span>)</span></span> &#123;</span><br><span class="line">    println(quarter.name) <span class="comment">// quarter: Q1 quarter: Q2 quarter: Q3 quarter: Q4</span></span><br><span class="line">    assertThat(quarter.value <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span>).isTrue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enum에 정의된 모든 값들을 출력하는 것을 확인할 수 있습니다. <code>@EnumSource</code>을 사용하면 모든 enum을 iterator 하기 편리합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@EnumSource(value = Quarter::class, names = [<span class="meta-string">"Q1"</span>, <span class="meta-string">"Q2"</span>])</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `names을 통해서 특정 <span class="keyword">enum</span> 값만 가져올 수 있다`<span class="params">(quarter: <span class="type">Quarter</span>)</span></span> &#123;</span><br><span class="line">    print(<span class="string">"<span class="subst">$&#123;quarter.name&#125;</span> "</span>) <span class="comment">// quarter: Q1 quarter: Q2</span></span><br><span class="line">    assertThat(quarter.value <span class="keyword">in</span> <span class="number">1.</span><span class="number">.2</span>).isTrue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>특정 enum을 지정해서 가져오고 싶은 경우 <code>names = [&quot;Q1&quot;, &quot;Q2&quot;]</code>을 사용하면 됩니다.</p><h2><span id="csvsource">@CsvSource</span></h2><p><code>@CsvSource</code> 어노테이션을 통해서 CSV 포멧으로 테스팅을 편리하게 진행 할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"010-1234-1234,01012341234"</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"010-2333-2333,01023332333"</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"02-223-1232,022231232"</span></span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `전화번호는 '-'를 제거한다`<span class="params">(value: <span class="type">String</span>, expected: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> valueReplace = value.replace(<span class="string">"-"</span>, <span class="string">""</span>)</span><br><span class="line">    assertThat(valueReplace).isEqualTo(expected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>,</code> 단위로 테스트 메서드의 매개변수로 값을 넘길 수 있습니다.</p><h2><span id="methodsource">@MethodSource</span></h2><p><code>@MethodSource</code> 어노테이션을 통해서 복잡한 객체를 보다 쉽게 생성하고 테스트할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Amount</span></span>(</span><br><span class="line">        <span class="keyword">val</span> price: <span class="built_in">Int</span>,</span><br><span class="line">        <span class="keyword">val</span> ea: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> totalPrice: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = price * ea</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>가격과 수량을 입력하면 totalPrice 계산하는 단순한 객체 입니다. 해당 객체를 <code>@MethodSource</code>를 통해서 테스트를 진행해 보겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource(<span class="meta-string">"providerAmount"</span>)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `amount total price 테스트 `<span class="params">(amount: <span class="type">Amount</span>, expectedTotalPrice: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    assertThat(amount.totalPrice).isEqualTo(expectedTotalPrice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerAmount</span><span class="params">()</span></span> = listOf(</span><br><span class="line">            Arguments.of(Amount(<span class="number">1000</span>, <span class="number">2</span>), <span class="number">2000</span>),</span><br><span class="line">            Arguments.of(Amount(<span class="number">2000</span>, <span class="number">5</span>), <span class="number">10000</span>),</span><br><span class="line">            Arguments.of(Amount(<span class="number">4000</span>, <span class="number">5</span>), <span class="number">20000</span>),</span><br><span class="line">            Arguments.of(Amount(<span class="number">5000</span>, <span class="number">3</span>), <span class="number">15000</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@MethodSource()</code>에 입력하는 문자열과,  값을 지정하는 static 메서드명과 일치해야 합니다. 테스트 하고자 하는 객체와, 예상되는 값을 넘겨받아 다양한 객체의 경우를 쉽게 테스트할 수 있습니다.</p><h2><span id="spring-boot">Spring Boot</span></h2><p>Junit5 관련된 내용은 아니지만 Junit5와 Spring Boot 관련 테스트할때 좋은 패턴을 정리했습니다.</p><h3><span id="생성자-주입">생성자 주입</span></h3><p><code>@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</code> 어노테이션을 통해서 테스트 코드에서도 생성자 주입이 가능해 졌습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(<span class="meta-string">"test"</span>)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberRepositoryTest</span></span>(<span class="keyword">val</span> memberRepository: MemberRepository) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `members 조회 테스트`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">val</span> email = <span class="string">"asd@asd.com"</span></span><br><span class="line">        <span class="keyword">val</span> name = <span class="string">"name"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="keyword">val</span> member = memberRepository.save(Member(email, name))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        assertThat(member.email).isEqualTo(email)</span><br><span class="line">        assertThat(member.name).isEqualTo(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="dsl-지원">DSL 지원</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(<span class="meta-string">"test"</span>)</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberApiTest</span></span>(</span><br><span class="line">        <span class="keyword">val</span> memberRepository: MemberRepository,</span><br><span class="line">        <span class="keyword">val</span> mockMvc: MockMvc</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `test`<span class="params">()</span></span> &#123;</span><br><span class="line">        memberRepository.saveAll(listOf(</span><br><span class="line">                Member(<span class="string">"email1@asd.com"</span>, <span class="string">"jin"</span>),</span><br><span class="line">                Member(<span class="string">"email2@asd.com"</span>, <span class="string">"yun"</span>),</span><br><span class="line">                Member(<span class="string">"email3@asd.com"</span>, <span class="string">"wan"</span>),</span><br><span class="line">                Member(<span class="string">"email4@asd.com"</span>, <span class="string">"kong"</span>),</span><br><span class="line">                Member(<span class="string">"email5@asd.com"</span>, <span class="string">"joo"</span>)</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        mockMvc.<span class="keyword">get</span>(<span class="string">"/members"</span>) &#123;</span><br><span class="line">            accept = MediaType.APPLICATION_JSON</span><br><span class="line">        &#125;.andExpect &#123;</span><br><span class="line">            content &#123; contentType(MediaType.APPLICATION_JSON) &#125;</span><br><span class="line">            jsonPath(<span class="string">"$[0].name"</span>) &#123; value(<span class="string">"jin"</span>) &#125;</span><br><span class="line">            jsonPath(<span class="string">"$[1].name"</span>) &#123; value(<span class="string">"yun"</span>) &#125;</span><br><span class="line">            jsonPath(<span class="string">"$[2].name"</span>) &#123; value(<span class="string">"wan"</span>) &#125;</span><br><span class="line">            jsonPath(<span class="string">"$[3].name"</span>) &#123; value(<span class="string">"kong"</span>) &#125;</span><br><span class="line">            jsonPath(<span class="string">"$[4].name"</span>) &#123; value(<span class="string">"joo"</span>) &#125;</span><br><span class="line">        &#125;.andDo &#123;</span><br><span class="line">            print()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebMvc에서도 DSL 사용을 할 수 있습니다. Web 관련 테스트 코드를 작성하기 더욱 편리해졌습니다.</p><h3><span id="sql-손쉽게-data-set-up">@Sql 손쉽게 Data Set up</span></h3><p><code>*.sql</code> 파일로 손쉽게 데이터를 Set up할 수 있습니다. JPA를 사용중이라면 Given절로 JPA를 만들기가 어렵고 불편한 경우 사용하면 좋을거 같습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># member-data-setup.sql</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">member</span> (<span class="string">`email`</span>, <span class="string">`name`</span>, <span class="string">`created_at`</span>, <span class="string">`updated_at`</span>)</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">(<span class="string">'sample1@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>()),</span><br><span class="line">(<span class="string">'sample2@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>()),</span><br><span class="line">(<span class="string">'sample3@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>()),</span><br><span class="line">(<span class="string">'sample4@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>()),</span><br><span class="line">(<span class="string">'sample5@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>()),</span><br><span class="line">(<span class="string">'sample6@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>()),</span><br><span class="line">(<span class="string">'sample15@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── test</span><br><span class="line">    ├── kotlin</span><br><span class="line">    │   └── com</span><br><span class="line">    └── resources</span><br><span class="line">        └── member-data-setup.sql</span><br></pre></td></tr></table></figure><p>위에서 작성한  <code>*.sql</code> 파일을 <code>test/resources</code> 디렉토리에 위치시킵니다</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Sql(<span class="meta-string">"/member-data-setup.sql"</span>)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">name</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAll()</span><br><span class="line"></span><br><span class="line">    then(members).anySatisfy &#123;</span><br><span class="line">        then(it.name).isEqualTo(<span class="string">"name"</span>)</span><br><span class="line">        then(it.email).contains(<span class="string">"@"</span>)</span><br><span class="line">                .startsWith(<span class="string">"sample"</span>)</span><br><span class="line">                .endsWith(<span class="string">"com"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Sql</code> 어노테이션을 통헤서 해당 디렉터리의 위치와 파일 이름을 작성합니다. 기본적인 디렉터리를 <code>test/resources</code>을 바라보기 때문에 위와 같은 경우 파일명만 작성합니다.</p><h2><span id="assertj">AssertJ</span></h2><p>Junit5의 관련된 내용은 아니지만 이번 Spring Boot 2.2 Release에서 AssertJ 관련된 내용이 있어 AssertJ의 사용과 간략한 팁을 정리했습니다.</p><p><code>AssertJ</code>는 개인적으로 선호하는 Test Matcher입니다. static 메서드로 동작하기 때문에 자동 완성으로 Matcher 기능들을 손쉽게 사용할 수 있고, Matcher에서 지원해주는 기능도 막강합니다. AssertJ에서는 BDD 스타일의 BDDAssertion을 제공해주고 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `member save test`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    <span class="keyword">val</span> email = <span class="string">"asd@asd.com"</span></span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"name"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    <span class="keyword">val</span> member = memberRepository.save(Member(email, name))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//then</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 기존 사용법 assertThat </span></span><br><span class="line">    assertThat(member.email).isEqualTo(email)</span><br><span class="line">    assertThat(member.name).isEqualTo(name)</span><br><span class="line">    assertThat(member.createdAt).isBeforeOrEqualTo(LocalDateTime.now())</span><br><span class="line">    assertThat(member.updatedAt).isBeforeOrEqualTo(LocalDateTime.now())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BDD 사용법</span></span><br><span class="line">    then(member.email).isEqualTo(email)</span><br><span class="line">    then(member.name).isEqualTo(name)</span><br><span class="line">    then(member.createdAt).isBeforeOrEqualTo(LocalDateTime.now())</span><br><span class="line">    then(member.updatedAt).isBeforeOrEqualTo(LocalDateTime.now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>assertThat</code> -&gt; <code>then</code> 으로 대체되었습니다. 코드도 적어지고 더 직관적으로 되어서 좋아졌습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `문장 검사`<span class="params">()</span></span> &#123;</span><br><span class="line">    then(<span class="string">"AssertJ is best matcher"</span>).isNotNull()</span><br><span class="line">            .startsWith(<span class="string">"AssertJ"</span>)</span><br><span class="line">            .contains(<span class="string">" "</span>)</span><br><span class="line">            .endsWith(<span class="string">"matcher"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 형식으로 코드를 연결해서 테스트할 수도 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `findByName test`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    memberRepository.saveAll(listOf(</span><br><span class="line">            Member(<span class="string">"email1@asd.com"</span>, <span class="string">"kim"</span>),</span><br><span class="line">            Member(<span class="string">"email2@asd.com"</span>, <span class="string">"kim"</span>),</span><br><span class="line">            Member(<span class="string">"email3@asd.com"</span>, <span class="string">"kim"</span>),</span><br><span class="line">            Member(<span class="string">"email4@asd.com"</span>, <span class="string">"name"</span>),</span><br><span class="line">            Member(<span class="string">"email5@asd.com"</span>, <span class="string">"name"</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findByName(<span class="string">"kim"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//then</span></span><br><span class="line">    then(members).anySatisfy &#123;</span><br><span class="line">        then(it.name).isEqualTo(<span class="string">"kim"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>anySatisfy</code> 람다 표현식으로 members를 iterator 돌리면서 해당 <code>kim</code>과 일치하는지 편리하게 확인할 수 있습니다. 이 밖에도 다양한 것들을 제공하고 있고 계속 발전하고 있는 AssertJ를 추천드립니다.</p><h3><span id="thenthrownby">thenThrownBy</span></h3><p>thenThrownBy을 통해서 Exception 테스트를 쉽게 진행할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validateBeforeSave</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fieldName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"<span class="variable">$id</span> empty <span class="variable">$fieldName</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        validate(email, <span class="string">"email"</span>)</span><br><span class="line">        validate(name, <span class="string">"name"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>빈 문자열인 경우 <code>IllegalArgumentException</code> 예외를 발생시키는 로직을 아래 처럼 테스트할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `member 실패`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> member = Member(<span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">    thenThrownBy &#123; member.validateBeforeSave() &#125;</span><br><span class="line">            .isExactlyInstanceOf(IllegalArgumentException::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">            .hasMessageContaining(<span class="string">"empty"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>특정 예외가 발생하는지, 예외 메시지의 특정한 값이 존재하는지 간단하게 확인할 수 있습니다.</p><h2><span id="참고">참고</span></h2><ul><li><a href="https://www.baeldung.com/parameterized-tests-junit-5" rel="external nofollow noopener noreferrer" target="_blank">Guide to JUnit 5 Parameterized Tests</a></li><li><a href="http://wonwoo.ml/index.php/post/category/kotlin" rel="external nofollow noopener noreferrer" target="_blank">머루의개발블로그 : Spring 5.2 와 Spring boot 2.2 추가된 Test 기능들</a></li><li><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.2-Release-Notes" rel="external nofollow noopener noreferrer" target="_blank">Spring Boot 2.2 Release Notes</a></li><li><a href="https://www.baeldung.com/parameterized-tests-junit-5" rel="external nofollow noopener noreferrer" target="_blank">Baeldung : Guide to JUnit 5 Parameterized Tests</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/kotlin-junit5&quot; rel=&quot;external nofollow noopener norefe
      
    
    </summary>
    
    
      <category term="Junit5" scheme="https://cheese10yun.github.io/tags/Junit5/"/>
    
      <category term="Test" scheme="https://cheese10yun.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>JPA N+1 발생원인과 해결방법</title>
    <link href="https://cheese10yun.github.io/jpa-nplus-1/"/>
    <id>https://cheese10yun.github.io/jpa-nplus-1/</id>
    <published>2019-10-27T09:16:27.000Z</published>
    <updated>2019-11-28T16:09:50.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/jpa-n-plus-1" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인할 수 있습니다.</p></blockquote><p>JPA를 사용하다면 보면 N+1문제를 많이 만나게 됩니다. 그에 따른 발생 원인과 해결법을 정리해보았습니다</p><h2><span id="erd">ERD</span></h2><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-erd.png" alt=""></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"member"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="meta-string">"member"</span>, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">var</span> orders: Set&lt;Order&gt; = emptySet()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"orders"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = <span class="meta-string">"member_id"</span>, nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> member: Member</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br></pre></td></tr></table></figure><p>위 엔티티 처럼 멤버 &lt;-&gt; 주문 관계를 기준으로 살명드리겠습니다.</p><h2><span id="발생-케이스">발생 케이스</span></h2><h3><span id="즉시로딩-n1">즉시로딩 N+1</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `지연 로딩 n+1`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// fetch = FetchType.EAGER 의 경우</span></span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-lazy-3.png" alt=""></p><p><strong><code>fetch = FetchType.EAGER</code> 전략을 즉시 로딩으로 가져가면 N+1 문제가 발생합니다.</strong></p><h3><span id="지연로딩과-n1">지연로딩과 N+1</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `지연 로딩 n+1`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// fetch = FetchType.LAZY 의 경우</span></span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-lay-1.png" alt=""></p><p><code>fetch = FetchType.LAZY</code> 설정으로 LAZY 로딩을 하면 N+1 문제는 발생하지 않습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `지연로딩인 n+1`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAll()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 회원 한명에 대한 조회는 문제가 없다</span></span><br><span class="line">    <span class="keyword">val</span> firstMember = members[<span class="number">0</span>]</span><br><span class="line">    println(firstMember.orders.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-lazy-2.png" alt=""></p><p>위처럼 한 명의 member를 조회했기 때문에 해당 memeber의 order를 위 와 같은 SQL로 조회합니다. <strong>하지만 아래 코드처럼 모은 Member에 대해서 주문을 조회하는 경우 N+1문제가 발생합니다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `지연로딩인 n+1`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAll()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 회원 한명에 대한 조회는 문제가 없다</span></span><br><span class="line">    <span class="keyword">val</span> firstMember = members[<span class="number">0</span>]</span><br><span class="line">    println(<span class="string">"order size : <span class="subst">$&#123;firstMember.orders.size&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 조회한 모든 회원에 대해서 조회하는 경우 문제 발생</span></span><br><span class="line">    <span class="keyword">for</span>(member <span class="keyword">in</span> members)&#123;</span><br><span class="line">        println(<span class="string">"order size: <span class="subst">$&#123;member.orders.size&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-lazy-3.png" alt=""></p><p><strong>결국 지연 로딩에서도 N+1 문제는 발생합니다.</strong></p><h2><span id="원인">원인</span></h2><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/jpa-n+1.png?raw=true" alt=""></p><p>JPQL 특징이 있습니다. <code>findById()</code> 같은 경우에는 엔티티를 영속성 컨텍스트에서 먼저 찾고 영속성 컨텍스트에 없는 경우에 데이터베이스에 찾는 <strong>반면 JPQL은 항상 데이터베이스에 SQL을 실행해서 결과를 조회합니다.</strong> 그리고 아래와 같은 작업을 진행하게 됩니다.</p><ol><li><strong>JPQL을 호출하면 데이터베이스에 우선 적으로 조회한다.</strong></li><li>조회한 값을 영속성 컨텍스트에 저장한다.</li><li>영속성 컨텍스트에 조회할 <strong>때 이미 존재하는 데이터가 있다면(같은 영속성 컨텍스트에서 이미 조회한 유저가 있는 경우) 데이터를 버린다.</strong></li></ol><p><strong>JPQL의 동작 순서는 위와 같고 그렇다면 왜 N+1이 발생하는 것일까요? JPQL을 실행하면 JPA는 이것을 분석해서 SQL을 생성합니다. JPQL 입장에서는 즉시 로딩, 지연 로딩과 같은 글로벌 패치 전략을 무시하고 JPQL만 사용해서 SQL을 생성합니다.</strong></p><h3><span id="즉시-로딩인-경우">즉시 로딩인 경우</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> members = memberRepository.findAll()</span><br></pre></td></tr></table></figure><p>JPQL에서 동작한 쿼리를 통해서 members에 데이터가 바인딩 됩니다. <strong>그 이후 JPA에서는 글로벌 패치 전략(즉시 로딩)을 받아들여 해당 member의 연관관계인 order에대해서 추가적인 레이지 로딩이 진행되어 N+1을 발생시킵니다.</strong></p><h3><span id="지연-로딩인-경우">지연 로딩인 경우</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> members = memberRepository.findAll()</span><br></pre></td></tr></table></figure><p>JPQL에서 동작한 쿼리를 통해서 members에 데이터가 바인딩 됩니다. <strong>JPA가 글로벌 패치 전략을 받아들이지만 지연 로딩이기 때문에 추가적인 SQL을 발생시키지 않습니다.</strong> 하지만 위에서 본 예제처럼 레이지로 딩으로 추가적인 작업을 진행하게되면 결국 N+1 문제가 발생하게 됩니다.</p><h2><span id="해결-방법">해결 방법</span></h2><h3><span id="batch-szie">Batch Szie</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"member"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BatchSize(size = 5)</span> <span class="comment">// Batch size를 지정한다</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="meta-string">"member"</span>, fetch = FetchType.EAGER)</span> <span class="comment">// 즉시 로딩으로 설정</span></span><br><span class="line">    <span class="keyword">var</span> orders: List&lt;Order&gt; = emptyList()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-batch-size.png" alt=""></p><p><code>@BatchSize(size = 5)</code> 에노테이션을 통해서 설정한 size 만큼 데이터를 미리 로딩 한다. 즉 연관된 엔티티를 조회할때 size 만큼 <code>where in</code> 쿼리를 통해서 조회하게되고 size를 넘어가게 되면 추가로 <code>where in</code> 쿼리를 진행합니다. 하지만 <strong>글로벌 패치전략을 변경해야 하며, 정해진 Batch size 만큼 조회되는 것도 고정되기 때문에 권장 드리는 방법은 아닙니다.</strong></p><h3><span id="페치-조인-사용">페치 조인 사용</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> : <span class="type">JpaRepository</span>&lt;<span class="type">Member, Long</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query(</span></span><br><span class="line"><span class="meta">            <span class="meta-string">"select m from Member m left join fetch m.orders"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findAllWithFetch</span><span class="params">()</span></span>: List&lt;Member&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `페치 조인 사용`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAllWithFetch()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 조회한 모든 회원에 대해서 조회하는 경우에도 N+1 문제가 발생하지 않음</span></span><br><span class="line">    <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">        println(<span class="string">"order size: <span class="subst">$&#123;member.orders.size&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>가장 많이 사용하는 방법인 <code>fetch</code>을 통해서 조인 쿼리를 진행하는 것입니다. <code>fetch</code> 키워드를 사용하게 되면 연관된 엔티티나 컬렉션을 한 번에 같이 조회할 수 있습니다. <strong>즉 페치 조인을 사용하게 되면 연관된 엔티티는 프록시가 아닌 실제 엔티티를 조회하게 되므로 연관관계 객체까지 한 번의 쿼리로 가져올 수 있습니다.</strong></p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-fetch-join.png" alt=""></p><p>위 로그를 보면 SQL을 통해서 한 번에 데이터를 가져 온다. <strong><code>Order Size: 10</code>을 보면 N+1이 발생하지 않고 있다.</strong> 그렇다면 <code>fetch</code> 키워드를 제거하면 어떻게 될까요?</p><h4><span id="페치-조인과-일반-조인-차이">페치 조인과 일반 조인 차이</span></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> : <span class="type">JpaRepository</span>&lt;<span class="type">Member, Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(</span></span><br><span class="line"><span class="meta">            <span class="meta-string">"select m from Member m join m.orders"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findAllWithFetch</span><span class="params">()</span></span>: List&lt;Member&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `페치 조인 키워드 제거`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAllWithFetch() <span class="comment">// 패치 타입 Lazy 경우</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 패치 조인하지 않은 상태에서는 N+1 문제 발생</span></span><br><span class="line">    <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">        println(<span class="string">"order size: <span class="subst">$&#123;member.orders.size&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-fetch-join-2.png" alt=""></p><p>출력되는 SQL을 보면 조인을 통해서 연관관계 컬렉션까지 함께 조회되는 것으로 생각할 수 있습니다. <strong>하지만 JPQL은 결과를 반환할 때 연관관계까지 고려하지 않고 select 절에 지정한 엔티티만 조회하게 됩니다.</strong> 따라서 컬렉션은 초기화하지 않은 컬렉션 레퍼를 반환하게 되고 컬렉션이 없기 때문에 Lazy 로딩이 발생하게 되고 <strong>결과적으로 N+1 문제가 발생하게 됩니다.</strong></p><h2><span id="페치-조인의-한계">페치 조인의 한계</span></h2><p>그렇다면 Fetch 조인이 만능일까요? 아쉽지만 Fetch 조인은 몇가지의 한계가 있습니다.</p><h3><span id="컬렉션을-페치-조인하면-페이징-api를-사용할-수-없다">컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> : <span class="type">JpaRepository</span>&lt;<span class="type">Member, Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Query(</span></span><br><span class="line"><span class="meta">            value = <span class="meta-string">"select m from Member m left join fetch m.orders"</span>,</span></span><br><span class="line"><span class="meta">            countQuery = <span class="meta-string">"select count(m) from Member m"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findAllWithFetchPaging</span><span class="params">(pageable: <span class="type">Pageable</span>)</span></span>: Page&lt;Member&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> page = PageRequest.of(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAllWithFetchPaging(page)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 조회한 모든 회원에 대해서 조회하는 경우에도 N+1 문제가 발생하지 않음</span></span><br><span class="line">    <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">        println(<span class="string">"order size: <span class="subst">$&#123;member.orders.size&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-paging.png" alt=""></p><p>이전에 <a href="https://github.com/cheese10yun/blog-sample/tree/master/jpa-fetch-join" rel="external nofollow noopener noreferrer" target="_blank">Paging 처리 Fetch Join 적용 시 limit 동작하지 않는 이슈</a>에서도 다룬 적있습니다. 해당 쿼리에서는 limit offset 관련된 쿼리문이 없습니다. <strong>하이버네이트에서 컬렉션을 페치 조인하고 페지이 API를 사용하면 메모리에서 페이징 처리를 진행합니다.</strong> 즉 데이터베이스에서는 FULL Scan 한 이후 모든 데이터를 메모리에 올린 이후 limit에 맞게 데이터를 만들게 됩니다. 우선 데이터베이스에 Full Sacn 하는 것도 문제지만 그것을 메모리에 올리기 때문에 메모리를 심하게 잡아먹게 됩니다. <strong>컬렉션이 아닌 단일 값 연관 필드의 경우에는 패치 조인을 사용해도 페이징 API를 사용할 수 있습니다.</strong></p><h3><span id="둘-이상-컬렉션을-페치할-수-없다">둘 이상 컬렉션을 페치할 수 없다.</span></h3><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-erd2.png" alt=""></p><p>위 ERD 처럼 member가 orders, copons를 갖는 테이블 구조인</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"member"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="meta-string">"member"</span>, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">var</span> orders: List&lt;Order&gt; = emptyList()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="meta-string">"member"</span>, fetch = FetchType.LAZY)</span> <span class="comment">// 새로운 컬렉션 쿠폰 추가</span></span><br><span class="line">    <span class="keyword">var</span> coupons: List&lt;Coupon&gt; = emptyList()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(</span></span><br><span class="line"><span class="meta">        value = <span class="meta-string">"select m from Member m left join fetch m.orders left join fetch m.coupons"</span>,</span></span><br><span class="line"><span class="meta">        countQuery = <span class="meta-string">"select count(m) from Member m"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findAllWithFetchPaging2</span><span class="params">(pageable: <span class="type">Pageable</span>)</span></span>: Page&lt;Member&gt;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `둘 이상 컬렉션을 페치할 수 없다`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> page = PageRequest.of(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAllWithFetchPaging2(page)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 조회한 모든 회원에 대해서 조회하는 경우에도 N+1 문제가 발생하지 않음</span></span><br><span class="line">    <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">        println(<span class="string">"order size: <span class="subst">$&#123;member.orders.size&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-fetch-muliple.png" alt=""></p><p>컬렉션의 카테시안 곱이 만들어지므로 하이버네이트는 주의해야 합니다. 하이버네이트는 <code>annot simultaneously fetch multiple bag</code> 예외가 발생하게 됩니다. 가장 쉬운 해결 방법으로는 자료형을 List -&gt; Set으로 변경하는 것입니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"member"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="meta-string">"member"</span>, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">var</span> orders: Set&lt;Order&gt; = emptySet()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="meta-string">"member"</span>, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">var</span> coupons: Set&lt;Coupon&gt; = emptySet()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래 코드처럼 변경하고 테스트 코드를 다시 실행하면 아래와 같은 결과를 확인할 수 있습니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-fetch-muliple-2.png" alt=""></p><p><strong>하지만 이 방법도 권장 드리지 않습니다. 특정 에러를 해결하기 위해서 자료형을 바꾸는 것 자체가 좋은 해결법이 아니며 도메인 레이어는 아주 중요한 레이어이기 때문에 더 권장 드리지 않습니다.</strong></p><h2><span id="참고">참고</span></h2><ul><li><a href="http://www.acornpub.co.kr/book/jpa-programmig" rel="external nofollow noopener noreferrer" target="_blank">자바 ORM 표준 JPA 프로그래밍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/jpa-n-plus-1&quot; rel=&quot;external nofollow noopener norefer
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="N+1" scheme="https://cheese10yun.github.io/tags/N-1/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ Execute Gradle task로 Gradle를 쉽게 사용하자</title>
    <link href="https://cheese10yun.github.io/intellij-execute-gradle-task/"/>
    <id>https://cheese10yun.github.io/intellij-execute-gradle-task/</id>
    <published>2019-10-16T15:16:46.000Z</published>
    <updated>2019-10-16T15:16:06.322Z</updated>
    
    <content type="html"><![CDATA[<p>IntellIj를 이용하면 Gradle Task의 명령어 assistant 해주는 기능을 통해서 보다 쉽게 Gradle을 사용할 수 있습니다.</p><h2><span id="설정-방법">설정 방법</span></h2><p><img src="https://github.com/cheese10yun/IntelliJ/raw/master/assets/execute-gradle-task.png" alt=""></p><p>Find Action에서 <code>Execute Gradle Task</code>을 열어 볼 수 있습니다.</p><p><img src="https://github.com/cheese10yun/IntelliJ/raw/master/assets/gradle-tasks-hot-key.png" alt=""></p><p>단축키를 지정해서 사용하는 것을 권장드립니다. <code>Keymap</code> -&gt; <code>Execute Gradle Task</code> -&gt; <code>Hot Key</code> 지정<br>저같은 경우에는 <code>CMD + 0</code>으로 지정해서 사용하고 있습니다.</p><h2><span id="사용법">사용법</span></h2><p><img src="https://github.com/cheese10yun/IntelliJ/raw/master/assets/gradle-task-run-1.gif" alt=""></p><p><code>Execute Gradle Task</code>를 실행하면 위 화면 처럼 해당 Gradle 명령어를 assistant 해줍니다.</p><p><img src="https://github.com/cheese10yun/IntelliJ/raw/master/assets/costom-build.png" alt=""></p><p><img src="https://github.com/cheese10yun/IntelliJ/raw/master/assets/gradle-task-run-2.gif" alt=""><br>위 그림처럼 커스텀하게 등록한 task도 assistant 해줍니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IntellIj를 이용하면 Gradle Task의 명령어 assistant 해주는 기능을 통해서 보다 쉽게 Gradle을 사용할 수 있습니다.&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;설정-방법&quot;&gt;설정 방법&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;h
      
    
    </summary>
    
    
      <category term="Gradle" scheme="https://cheese10yun.github.io/tags/Gradle/"/>
    
      <category term="IntelliJ" scheme="https://cheese10yun.github.io/tags/IntelliJ/"/>
    
  </entry>
  
  <entry>
    <title>Mysql Explain</title>
    <link href="https://cheese10yun.github.io/mysql-explian/"/>
    <id>https://cheese10yun.github.io/mysql-explian/</id>
    <published>2019-10-13T04:55:28.000Z</published>
    <updated>2020-02-16T15:46:32.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 글은 <a href="http://www.yes24.com/Product/Goods/72270172?" rel="external nofollow noopener noreferrer" target="_blank">MySQL 5.7 완벽 분석</a>을 정리한 내용입니다.</p></blockquote><h2><span id="mysql-옵티마이저-구조">MySQL 옵티마이저 구조</span></h2><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/mysql-sql-executor-flow.png" alt=""></p><p>MySQL 옵티마이저는 비용 기반으로 어떤 실행 계획으로 쿼리를 실행했을 때 비용이 얼마나 발생하는지를 계산해하여 비용이 가장 적은 것을 택하게 됩니다. 어디까지나 추정 값이므로 정확한 비용은 실행 전까지 정확하게는 알 수 없습니다.</p><h2><span id="explain">EXPLAIN</span></h2><p>EXPLAIN은 MySQL 서버가 어떠한 쿼리를 실행할 것인가, <strong>즉 실행 계획이 무엇인지 알고 싶을 때 사용하는 기본적인 명령어이다.</strong> 5.6 부터는 JSON 형식의 출력도할 수 있게 되었다. MySQL Workbench와의 결합으로 시각화할 수도 있습니다. 이 부분은 아래에서 다루겠습니다.</p><h2><span id="테이블-구조">테이블 구조</span></h2><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/smaple-erd.png?raw=true" alt=""></p><p><code>EXPLAIN</code>을 살펴 보기 이전 ERD를 살펴보겠습니다. member는 회원 정보이고, orders는 주문 목록, transaction은 해당 주문의 거래 정보입니다.</p><h2><span id="explain-결과">EXPLAIN 결과</span></h2><p>EXPLAIN은 MySQL 서버가 어떠한 쿼리를 실행할 것인가, 즉 실행 계획이 무엇인지 알고 싶을 때 사용하는 기본적인 명령어이다. 5.6 부터는 JSON 형식의 출력도할 수 있게 되었다</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span></span><br><span class="line"><span class="keyword">select</span> m.*, o.*, t.* <span class="keyword">from</span> <span class="keyword">member</span>  m</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> orders o <span class="keyword">on</span> m.id = o.member_id</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">transaction</span> t <span class="keyword">on</span> o.transaction_id = t.id</span><br><span class="line"><span class="keyword">where</span> m.id <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">33</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>‘1’</td><td>‘SIMPLE’</td><td>‘m’</td><td>NULL</td><td>‘range’</td><td>‘PRIMARY’</td><td>‘PRIMARY’</td><td>‘8’</td><td>NULL</td><td>‘3’</td><td>‘100.00’</td><td>‘Using where’</td></tr><tr><td>‘1’</td><td>‘SIMPLE’</td><td>‘o’</td><td>NULL</td><td>‘ref’</td><td>‘FKpktxw…’</td><td>‘FKpktxw…’</td><td>‘8’</td><td>‘<a href="http://sample.m.id" rel="external nofollow noopener noreferrer" target="_blank">sample.m.id</a>’</td><td>‘90’</td><td>‘100.00’</td><td>NULL</td></tr><tr><td>‘1’</td><td>‘SIMPLE’</td><td>‘t’</td><td>NULL</td><td>‘eq_ref’</td><td>‘PRIMARY’</td><td>‘PRIMARY’</td><td>‘8’</td><td>‘sample.o.transaction_id’</td><td>‘1’</td><td>‘100.00’</td><td>NULL</td></tr></tbody></table><h3><span id="table">table</span></h3><p>어떤 테이블에 대한 접근을 표시하고 있는지는 table 필드에 표시되어있다.</p><h3><span id="id">id</span></h3><p>id는 SELECT에 붙은 번호를 말한다. MySQL은 조인을 하나의 단위로 실행하기 때문에 id는 그 쿼리에 실행 단위를 식별하는 것이다. 따라서 조인만 수행하는 쿼리에서는 id는 항상 1이 된다.</p><h3><span id="select_type">select_type</span></h3><p>select_type은 항상 SIMPLE 이된다. 복잡한 조인을 해도 SIMPLE이 된다. 서브쿼리나 UNION이 있으면 id와 select_type이 변한다.</p><h3><span id="partitions">partitions</span></h3><p>partitions는 파티셔닝이 되어 있는 경우에 사용되는 필드이다. 이 쿼리에서 사용된 테이블을 모두 파티셔닝이 되어 있지 않기 때문에 이 필드가 모두 NULL로 출력되았다. 파티셔닝 되어 있는 경우는 반드시 이 필드를 확인하자</p><h3><span id="type">type</span></h3><p>type은 접근 방식을 표시하는 필드다. 접근 방식은 테이블에서 어떻게 행데이터를 가져올것인가를 가리킨다. 위 EXPLAIN에서는 ALL, eq_ref, ref가 있는데 ALL, eq_ref는 조인시 기본 키나 고유키를 사용하여 하나의 값으로 접근(최대 1행만을 정확하게 패치), ref는 여러 개의 행을 패치할 가능성이 있는 접근을 의미한다. <strong>접근 방식은 대상 테이블로의 접근이 효율적일지 여부를 판단하는 데 아주 중요한 항목이다.</strong></p><p>이들 접근 방식 가운데도 주의가 필요한 것은 ALL, index, ref_or_null이다. <strong>ALL, index 두 가지는 테이블 또는 특정 인덱스가 전체 행에 접근하기 때문에 테이블 크기가 크면 효율이 떨어진다. ref_or_null의 경우 NUL이 들어있는 행은 인덱스의 맨 앞에 모아서 저장하지만 그 건수가 많으면 MySQL 서버의 작업량이 방대해진다. 다시 말해서 ALL 이외의 접근 방식은 모두 인덱스를 사용한다.</strong></p><p>접근 방식이 ALL 또는 index인 경우는 그 쿼리로 사용할 수 있는 적절한 인덱스가 없다는 의미일 수도 있다. 위 쿼리에서 Country 테이블에 대한 접근은 ALL이지만 이는 WHERE 구의 조건을 지정하지 않았기 때문이다. 그러한 쿼리에서 드라이빙 테이블에 접근한다면 전체 행을 스캔 할수 밖에 없다.</p><table><thead><tr><th>접근 방식</th><th>설명</th></tr></thead><tbody><tr><td>const</td><td>기본 키 또는 고유키에 의한 loockup(등가비교), 조인이 아닌 가장 외부의 테이블에 접근 하는 방식, 결과는 항상 1행이다. 단 기본 키, 고유 키를 사용하고 있으므로 범위 검색으로 지정하는 경우 const가 되지 않는다</td></tr><tr><td>system</td><td>테이블에 1행밖에 없는 경우의 특수한 접근 방식</td></tr><tr><td>ALL</td><td>전체 행 스캔, 테이블의 데이터 전체에 잡근한다.</td></tr><tr><td>index</td><td>인덱스 스캔, 테이블의 특정 인덱스의 전체 엔트리에 접근한다.</td></tr><tr><td>eq_ref</td><td>조인이 내부 테이블로 접근할 때 기본키 또는 공유 키에 의한 lookup이 일어난다. const와 비슷하지만 조인의 내부 테이블에 접근한다는 점이 다르다</td></tr><tr><td>ref</td><td>고유 키가아닌 인덱스에 대한 등가비교, 여러 개 행에 접근할 가능성이 있다.</td></tr><tr><td>ref_or_null</td><td>ref와 마찬가지로 인덱스 접근 시 맨 앞에 저장되어 있는 NULL의 엔트리를 검색한다.</td></tr><tr><td>range</td><td>인덱스 특정 범위의 행에 접근한다</td></tr><tr><td>fulltext</td><td>fulltext 인덱스를 사용한 검색</td></tr><tr><td>index_merge</td><td>여러 개인스턴스를 사용해 행을 가져오고 그 결과를 통합한다.</td></tr><tr><td>unique_subquery</td><td>IN 서브쿼리 접근에서 기본 키 또는 고유 키를 사용한다. 이 방식은 쓸데 없는 오버헤드를 줄여 상당히 빠르다.</td></tr><tr><td>index_subquery</td><td>unique_sunquery와 거의 비슷하지만 고유한 인덱스를 사용하지 않는 점이 다르다. 이 접근 방식도 상당히 빠르다</td></tr></tbody></table><h3><span id="possible_keys">possible_keys</span></h3><p>possible_keys 필드는 이용 가능성있는 인덱스의 목록이다.</p><h3><span id="key">key</span></h3><p>possible_keys 필드는 이용 가능성있는 인덱스의 목록 중에서 실제로 옵티마이저가 선택한 인덱스가 key가 된다. 위 EXPLAN 에서는 County 테이블(첫 번째 행)의 <strong>Key는 NULL 인데 이는 행 데이터를 가져오기 위해 인덱스를 사용할 수 없다는 의미이다.</strong></p><h3><span id="key_len">key_len</span></h3><p>key_len 필드는 선택된 인덱스의 길이를 의미한다. 중요한 필드는 아니지만 인덱스가 너무 긴 것도 비효율적이므로 기억해두자.</p><h3><span id="rows">rows</span></h3><p>rows는 이 접근 방식을 사용해 몇 행을 가져왔는가를 표시한다. 최초에 접근하는 테이블에 대해서 쿼리 전체에 의해 접근하는 행 수, 그 이후에 테이블에 대해서는 1행의 조인으로 평균 몇 행에 접근했는가를 표시한다. 단 어디까지나 통계 값으로 계산한 값이므로 실제 행 수와 반드시 일치하지 않는다.</p><h3><span id="filtered">filtered</span></h3><p>filtered는 행 데이터를 가져와 거이에서 WHERE 구의 검색 조건이 적용되면 몇행이 남는지를 표시한다. 이 값도 통계 값 바탕으로 계산한 값이므로 현실의 값과 반드시 일치하지 않는다.</p><h3><span id="extra">extra</span></h3><p>Extra 필드는 옵티마이저가 동작하는데 대해서 우리에게 알려주는 힌트다. 이 필드는 EXPLAN을 사용해 옵티마이저의 행동을 파악할때 아주 중요하다.</p><h2><span id="json-형식-explain">JSON 형식 EXPLAIN</span></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">format</span> = <span class="keyword">json</span></span><br><span class="line"><span class="keyword">select</span> m.*, o.*, t.* <span class="keyword">from</span> <span class="keyword">member</span>  m</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> orders o <span class="keyword">on</span> m.id = o.member_id</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">transaction</span> t <span class="keyword">on</span> o.transaction_id = t.id</span><br><span class="line"><span class="keyword">where</span> m.id <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">33</span>)</span><br></pre></td></tr></table></figure><p>JSON 형식의 EXPLAIN은 기존의 표 형식 보다 출력되는 정보가 많다. 5.7 부터는 비용에 관한 정보를 부여주어서 표 형식에 비해 편리하다. JOSN 형식의 EXPLAIN에는 Extra 필드에서 Using WHERE 라고만 출력되는 것이 attached_condition로 나와서 구체적으러 어떤 조건이 적용되는지 알 수 있다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query_block"</span>: &#123;</span><br><span class="line">    <span class="attr">"select_id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"cost_info"</span>: &#123;</span><br><span class="line">      <span class="attr">"query_cost"</span>: <span class="string">"449.03"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"nested_loop"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"table"</span>: &#123;</span><br><span class="line">          <span class="attr">"table_name"</span>: <span class="string">"m"</span>,</span><br><span class="line">          <span class="attr">"access_type"</span>: <span class="string">"range"</span>,</span><br><span class="line">          <span class="attr">"possible_keys"</span>: [</span><br><span class="line">            <span class="string">"PRIMARY"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"PRIMARY"</span>,</span><br><span class="line">          <span class="attr">"used_key_parts"</span>: [</span><br><span class="line">            <span class="string">"id"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"key_length"</span>: <span class="string">"8"</span>,</span><br><span class="line">          <span class="attr">"rows_examined_per_scan"</span>: <span class="number">3</span>,</span><br><span class="line">          <span class="attr">"rows_produced_per_join"</span>: <span class="number">3</span>,</span><br><span class="line">          <span class="attr">"filtered"</span>: <span class="string">"100.00"</span>,</span><br><span class="line">          <span class="attr">"cost_info"</span>: &#123;</span><br><span class="line">            <span class="attr">"read_cost"</span>: <span class="string">"3.61"</span>,</span><br><span class="line">            <span class="attr">"eval_cost"</span>: <span class="string">"0.60"</span>,</span><br><span class="line">            <span class="attr">"prefix_cost"</span>: <span class="string">"4.21"</span>,</span><br><span class="line">            <span class="attr">"data_read_per_join"</span>: <span class="string">"6K"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"used_columns"</span>: [</span><br><span class="line">            <span class="string">"id"</span>,</span><br><span class="line">            <span class="string">"email"</span>,</span><br><span class="line">            <span class="string">"name"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"attached_condition"</span>: <span class="string">"(`sample`.`m`.`id` in (1,2,33))"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"table"</span>: &#123;</span><br><span class="line">          <span class="attr">"table_name"</span>: <span class="string">"o"</span>,</span><br><span class="line">          <span class="attr">"access_type"</span>: <span class="string">"ref"</span>,</span><br><span class="line">          <span class="attr">"possible_keys"</span>: [</span><br><span class="line">            <span class="string">"FKpktxwhj3x9m4gth5ff6bkqgeb"</span>,</span><br><span class="line">            <span class="string">"FKrylnffj7sn97iepyqadlfnsg0"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"FKpktxwhj3x9m4gth5ff6bkqgeb"</span>,</span><br><span class="line">          <span class="attr">"used_key_parts"</span>: [</span><br><span class="line">            <span class="string">"member_id"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"key_length"</span>: <span class="string">"8"</span>,</span><br><span class="line">          <span class="attr">"ref"</span>: [</span><br><span class="line">            <span class="string">"sample.m.id"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"rows_examined_per_scan"</span>: <span class="number">90</span>,</span><br><span class="line">          <span class="attr">"rows_produced_per_join"</span>: <span class="number">272</span>,</span><br><span class="line">          <span class="attr">"filtered"</span>: <span class="string">"100.00"</span>,</span><br><span class="line">          <span class="attr">"cost_info"</span>: &#123;</span><br><span class="line">            <span class="attr">"read_cost"</span>: <span class="string">"63.00"</span>,</span><br><span class="line">            <span class="attr">"eval_cost"</span>: <span class="string">"54.55"</span>,</span><br><span class="line">            <span class="attr">"prefix_cost"</span>: <span class="string">"121.76"</span>,</span><br><span class="line">            <span class="attr">"data_read_per_join"</span>: <span class="string">"279K"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"used_columns"</span>: [</span><br><span class="line">            <span class="string">"id"</span>,</span><br><span class="line">            <span class="string">"order_number"</span>,</span><br><span class="line">            <span class="string">"member_id"</span>,</span><br><span class="line">            <span class="string">"transaction_id"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"table"</span>: &#123;</span><br><span class="line">          <span class="attr">"table_name"</span>: <span class="string">"t"</span>,</span><br><span class="line">          <span class="attr">"access_type"</span>: <span class="string">"eq_ref"</span>,</span><br><span class="line">          <span class="attr">"possible_keys"</span>: [</span><br><span class="line">            <span class="string">"PRIMARY"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"key"</span>: <span class="string">"PRIMARY"</span>,</span><br><span class="line">          <span class="attr">"used_key_parts"</span>: [</span><br><span class="line">            <span class="string">"id"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"key_length"</span>: <span class="string">"8"</span>,</span><br><span class="line">          <span class="attr">"ref"</span>: [</span><br><span class="line">            <span class="string">"sample.o.transaction_id"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"rows_examined_per_scan"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">"rows_produced_per_join"</span>: <span class="number">272</span>,</span><br><span class="line">          <span class="attr">"filtered"</span>: <span class="string">"100.00"</span>,</span><br><span class="line">          <span class="attr">"cost_info"</span>: &#123;</span><br><span class="line">            <span class="attr">"read_cost"</span>: <span class="string">"272.73"</span>,</span><br><span class="line">            <span class="attr">"eval_cost"</span>: <span class="string">"54.55"</span>,</span><br><span class="line">            <span class="attr">"prefix_cost"</span>: <span class="string">"449.03"</span>,</span><br><span class="line">            <span class="attr">"data_read_per_join"</span>: <span class="string">"820K"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"used_columns"</span>: [</span><br><span class="line">            <span class="string">"id"</span>,</span><br><span class="line">            <span class="string">"code"</span>,</span><br><span class="line">            <span class="string">"partner_transaction_id"</span>,</span><br><span class="line">            <span class="string">"payment_method_type"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="visual-explain">Visual Explain</span></h2><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/mysql-visual-explain.gif?raw=true" alt=""></p><p>MySQL Workbench을 사용하면 Visual Explain를 활용할 수 있습니다. 가장 직관적으로 Explain을 확인할 수 있습니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/mysql-explain.png?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 글은 &lt;a href=&quot;http://www.yes24.com/Product/Goods/72270172?&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;MyS
      
    
    </summary>
    
    
      <category term="explain" scheme="https://cheese10yun.github.io/tags/explain/"/>
    
  </entry>
  
  <entry>
    <title>ConstraintValidator을 이용해서 효과적인 검증</title>
    <link href="https://cheese10yun.github.io/ConstraintValidator/"/>
    <id>https://cheese10yun.github.io/ConstraintValidator/</id>
    <published>2019-09-21T15:00:00.000Z</published>
    <updated>2019-11-19T17:05:36.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/cheese10yun/blog-sample/tree/master/custom-validation" rel="external nofollow noopener noreferrer" target="_blank">코드는 Github</a>에 공개 되어있습니다.</p></blockquote><p>스프링에서는 JSR 303 기반 어노테이션 기반으로 일관성 있는 Validation을 진행할 수 있습니다. 하지만 <code>@NotNull</code>, <code>@NotEmpty</code>, <code>@Email</code>과 같은 검증은 가능하지만 비즈니스적에 맞는 Validation은 별도로 진행해야 합니다.</p><p>예를 들어 주문에 대한 결제 정보를 받는 경우 카드 결제 시에는 카드 정보, 무통장 결제에는 계좌 정보를 입력받아야 합니다. 해당 요청을 JSON으로 표현하면 아래와 같습니다.</p><h2><span id="무통장-결제">무통장 결제</span></h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"price"</span>: <span class="number">100.00</span>,</span><br><span class="line">  <span class="attr">"payment"</span>: &#123;</span><br><span class="line">    <span class="attr">"paymentMethod"</span>: <span class="string">"BANK_TRANSFER"</span>,</span><br><span class="line">    <span class="attr">"account"</span>: &#123;</span><br><span class="line">      <span class="attr">"number"</span>: <span class="string">"110-202034-2234"</span>,</span><br><span class="line">      <span class="attr">"bankCode"</span>: <span class="string">"2003"</span>,</span><br><span class="line">      <span class="attr">"holder"</span> : <span class="string">"홍길동"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"address"</span>: &#123;</span><br><span class="line">    <span class="attr">"city"</span>: <span class="string">"NOWON-GU"</span>,</span><br><span class="line">    <span class="attr">"state"</span>: <span class="string">"SEOUL"</span>,</span><br><span class="line">    <span class="attr">"zipCode"</span>: <span class="string">"09876?"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="카드-결제">카드 결제</span></h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"price"</span>: <span class="number">100.00</span>,</span><br><span class="line">  <span class="attr">"payment"</span>: &#123;</span><br><span class="line">    <span class="attr">"paymentMethod"</span>: <span class="string">"CARD"</span>,</span><br><span class="line">    <span class="attr">"card"</span>: &#123;</span><br><span class="line">      <span class="attr">"number"</span>: <span class="string">"25523-22394"</span>,</span><br><span class="line">      <span class="attr">"brand"</span>: <span class="string">"323"</span>,</span><br><span class="line">      <span class="attr">"csv"</span> : <span class="string">"삼성카드"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"address"</span>: &#123;</span><br><span class="line">    <span class="attr">"city"</span>: <span class="string">"NOWON-GU"</span>,</span><br><span class="line">    <span class="attr">"state"</span>: <span class="string">"SEOUL"</span>,</span><br><span class="line">    <span class="attr">"zipCode"</span>: <span class="string">"09876?"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 JSON 같이 <code>account</code>, <code>card</code> 값은 <code>paymentMethod</code>에 따라 선택적으로 필수 값이 변경되니 단순하게 <code>@NotNull</code>, <code>@NotEmpty</code> 어노테이션으로 검증하기가 어렵습니다. 이러한 경우 ConstraintValidator을 직접 구현해야 합니다.</p><h2><span id="constraintvalidator의-장점">ConstraintValidator의 장점</span></h2><p>ConstraintValidator을 직접 구현하지 않고도 다양한 방법으로 해당 Validation을 진행할 수 있지만 ConstraintValidator 기반으로 검증하는 게 다음과 같은 장점이 있다고 생각합니다.</p><h3><span id="일관성-있는-validation-처리-방법">일관성 있는 Validation 처리 방법</span></h3><p>검증을 진행하는 방법과 시점이 매우 다양하다 보니 많은 개발자들이 만들어가는 프로젝트인 경우에 전체적인 코드의 통일성이 떨어지게 됩니다. Validation을 사용하면 검증 방법과, 검증 시점(어느 레이어에서 진행되는지)을 통일성 있게 가져갈 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderSheetRequest <span class="title">order</span><span class="params">(@RequestBody @Valid <span class="keyword">final</span> OrderSheetRequest dto)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dto.getPayment().getPaymentMethod() == PaymentMethod.BANK_TRANSFER)) &#123;</span><br><span class="line">            <span class="comment">// 계좌정보가 제대로 넘어 왔는지 검증</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((dto.getPayment().getPaymentMethod() == PaymentMethod.CARD))&#123;</span><br><span class="line">            <span class="comment">// 카드 정보 제대로 넘어 왔는지 검증</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dto;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>위와 같은 식으로 Controller 코드에서 검증을 진행하는 것도 방법이지만 이렇게 되면 다른 컨트롤러에서 위와 같은 중복 코드가 발생할 수 있고 이러한 중복 코드로 코드의 응집력이 떨어지게 되면 변경이 발생했을 때 해당 코드를 찾아가서 직접 수정해야 합니다. 직접 수정하는 것이 큰 리소스가 들지 않더라도 이는 실수하기 좋은 환경입니다.</p><p>이러한 컨트롤러에서의 중복 코드를 제거하기 위해서는 <strong>컨트롤러 진입 직전 Interceptor에서 검증하는 것이 바람직합니다.</strong> <code>ConstraintValidator</code> 기반으로 유효성 검증을 진행하면 검증 시점의(Interceptor에서 진행) 통일성을 갖습니다.</p><h3><span id="일관성-있는-errorresponse">일관성 있는 ErrorResponse</span></h3><p><a href="https://github.com/cheese10yun/spring-guide/blob/master/docs/exception-guide.md#%ED%86%B5%EC%9D%BC%EB%90%9C-error-response-%EA%B0%9D%EC%B2%B4" rel="external nofollow noopener noreferrer" target="_blank">스프링 가이드 - 통일된 Error Response 객체</a>에서 이야기했듯이 ErrorReponse는 항상 동일한 포맷으로 응답해야 합니다. <code>ConstraintValidator</code>을 사용해서 <code>@Valid</code>을 기반으로 검증을 하면 <code>MethodArgumentNotValidException</code>이 발생하고 이 예외를 <a href="https://github.com/cheese10yun/spring-guide/blob/master/docs/exception-guide.md#controlleradvice%EB%A1%9C-%EB%AA%A8%EB%93%A0-%EC%98%88%EC%99%B8%EB%A5%BC-%ED%95%B8%EB%93%A4%EB%A7%81" rel="external nofollow noopener noreferrer" target="_blank">@ControllerAdvice로 모든 예외를 핸들링</a>에서 정리한 것처럼 통일성 있는 ErrorResponse 포맷으로 처리할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/order</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;price&quot;: 100.00,</span><br><span class="line">  &quot;payment&quot;: &#123;</span><br><span class="line">    &quot;paymentMethod&quot;: &quot;BANK_TRANSFER&quot;,</span><br><span class="line">    &quot;account&quot;: &#123;</span><br><span class="line">      &quot;holder&quot;: &quot;&quot;,</span><br><span class="line">      &quot;number&quot;: &quot;&quot;,</span><br><span class="line">      &quot;bankCode&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;address&quot;: &#123;</span><br><span class="line">    &quot;city&quot;: &quot;NOWON-GU&quot;,</span><br><span class="line">    &quot;state&quot;: &quot;SEOUL&quot;,</span><br><span class="line">    &quot;zipCode&quot;: &quot;09876?&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 요청을 보냈을 경우 아래처럼 Error Response를 갖습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"입력값이 올바르지 않습니다."</span>,</span><br><span class="line">  <span class="attr">"status"</span>: <span class="number">400</span>,</span><br><span class="line">  <span class="attr">"errors"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"field"</span>: <span class="string">"payment.account.bankCode"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"reason"</span>: <span class="string">"은행코드는 필수입니다."</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"field"</span>: <span class="string">"payment.account.number"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"reason"</span>: <span class="string">"계좌번호는 필수값입니다."</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"field"</span>: <span class="string">"payment.account.holder"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"reason"</span>: <span class="string">"계좌주는 값은 필수 입니다."</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"code"</span>: <span class="string">"C001"</span>,</span><br><span class="line">  <span class="attr">"timestamp"</span>: <span class="string">"2019-09-21T23:21:26.006"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConstraintValidator</code>를 통해서 errors 배열로 올바르지 않은 필드에 대해서 리스트로 내려줌으로써 더 구체적인 에러를 응답하게할 수 있습니다.</p><h2><span id="constraintvalidator-사용법">ConstraintValidator 사용법</span></h2><h3><span id="annotation-생성">Annotation 생성</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = OrderSheetFormValidator.class)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OrderSheetForm &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "Order sheet form is invalid"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="검증-로직이-있는-ordersheetformvalidator-생성">검증 로직이 있는 OrderSheetFormValidator 생성</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSheetFormValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">OrderSheetForm</span>, <span class="title">OrderSheetRequest</span>&gt; </span>&#123; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(OrderSheetForm constraintAnnotation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(OrderSheetRequest value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> invalidCount = <span class="number">0</span>; <span class="comment">// (2)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value.getPayment().hasPaymentInfo()) &#123;</span><br><span class="line">            addConstraintViolation(context, <span class="string">"카드 정보 혹은 계좌정보는 필수입니다."</span>, <span class="string">"payment"</span>); <span class="comment">// (3)</span></span><br><span class="line">            invalidCount += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value.getPayment().getPaymentMethod() == PaymentMethod.CARD) &#123;</span><br><span class="line">            <span class="keyword">final</span> Card card = value.getPayment().getCard();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (card == <span class="keyword">null</span>) &#123;</span><br><span class="line">                addConstraintViolation(context, <span class="string">"카드 필수입니다."</span>, <span class="string">"payment"</span>, <span class="string">"card"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(card.getBrand())) &#123;</span><br><span class="line">                    addConstraintViolation(context, <span class="string">"카드 브렌드는 필수입니다."</span>, <span class="string">"payment"</span>, <span class="string">"card"</span>, <span class="string">"brand"</span>);</span><br><span class="line">                    invalidCount += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(card.getCsv())) &#123;</span><br><span class="line">                    addConstraintViolation(context, <span class="string">"CSV 값은 필수 입니다."</span>, <span class="string">"payment"</span>, <span class="string">"card"</span>, <span class="string">"csv"</span>);</span><br><span class="line">                    invalidCount += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(card.getNumber())) &#123;</span><br><span class="line">                    addConstraintViolation(context, <span class="string">"카드 번호는 필수 입니다."</span>, <span class="string">"payment"</span>, <span class="string">"card"</span>, <span class="string">"number"</span>);</span><br><span class="line">                    invalidCount += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> invalidCount == <span class="number">0</span>; <span class="comment">// (6)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addConstraintViolation</span><span class="params">(ConstraintValidatorContext context, String errorMessage,</span></span></span><br><span class="line"><span class="function"><span class="params">        String firstNode, String secondNode, String thirdNode)</span> </span>&#123;</span><br><span class="line">        context.disableDefaultConstraintViolation(); <span class="comment">// (4)</span></span><br><span class="line">        context.buildConstraintViolationWithTemplate(errorMessage) <span class="comment">// (5)</span></span><br><span class="line">            .addPropertyNode(firstNode)</span><br><span class="line">            .addPropertyNode(secondNode)</span><br><span class="line">            .addPropertyNode(thirdNode)</span><br><span class="line">            .addConstraintViolation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(1) ConstraintValidator&lt;OrderSheetForm, OrderSheetRequest&gt;를 상속받습니다. <code>OrderSheetForm</code> 작성한 위에서 생성한 어노테이션, <code>OrderSheetRequest</code>는 <code>@RequestBody</code>으로 받는 객체입니다.</li><li>(2) <code>invalidCount</code>는 검증이 실패할 때마다 증가할 카운트 변수입니다.</li><li>(3) <code>addConstraintViolation</code> 메서드를 통해서 에러 메시지와 검증한 node key 값을 넘겨줍니다. 해당 node는 ErrorResponse의 <code>errors[].field</code>에 바인딩 됩니다.</li><li>(4) 해당 메서드로 <code>@OrderSheetForm</code>의 <code>default &quot;Order sheet form is invalid&quot;;</code> 값을 disable 시킵니다.</li><li>(5) 해당 메서드로 검증에 대한 Violation 을 추가합니다.</li><li>(6) <code>invalidCount == 0</code> 아닌 경우에는 <code>false</code></li></ul><h3><span id="ordersheetrequest">OrderSheetRequest</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@OrderSheetForm</span> <span class="comment">// (1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSheetRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Valid</span> <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">private</span> Payment payment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@ToString</span> <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="keyword">private</span> PaymentMethod paymentMethod;</span><br><span class="line">        <span class="keyword">private</span> Account account;</span><br><span class="line">        <span class="keyword">private</span> Card card;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@JsonIgnore</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPaymentInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> account != <span class="keyword">null</span> &amp;&amp; card != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(1) <code>@OrderSheetForm</code>을 추가해서 <code>OrderSheetFormValidator</code>가 동작하게 합니다.</li><li>(2) <code>@Valid</code>을 추가해서 각 클래스의 <code>JSR-303</code> 기반 어노테이션이 동작하게 합니다. <code>@Valid</code>이 없는 경우 payment.PaymentMethod의 <code>@NotNull</code> 동작하지 않습니다.</li><li>(3) Error[].value 값이 객체인 경우에 해당 객체의 정보를 출력하기 위해서 <code>@ToString</code>을 추가합니다.</li></ul><h3><span id="contoller">Contoller</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/order"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderSheetRequest <span class="title">order</span><span class="params">(@RequestBody @Valid <span class="keyword">final</span> OrderSheetRequest dto)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Valid</code> 어노테이션으로 검증을 진행합니다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/custom-validation&quot; rel=&quot;external nofollow noopener noreferre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Utterances 적용하기</title>
    <link href="https://cheese10yun.github.io/utterances/"/>
    <id>https://cheese10yun.github.io/utterances/</id>
    <published>2019-08-30T15:00:00.000Z</published>
    <updated>2019-08-31T15:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="utterances-소개">Utterances 소개</span></h2><p><a href="https://utteranc.es" rel="external nofollow noopener noreferrer" target="_blank">Utterances</a>는 GitHub Issue 기반으로 Comment를 작성할 수 있게 해줍니다.</p><p>Utterances의 장점</p><ul><li>GitHub Issue 기반이기 때문에 블로그 플랫폼을 이전해도 기존 Comment을 그대로 가져갈 수 있음</li><li>개발 블로그 라면 Github 계정으로 댓글을 작성할 수 있기 때문에 사용성이 용이함</li><li><strong>뭔가 있어 보임, 유명한 블로그는 이거 쓰는 거 같음</strong></li></ul><h2><span id="utterances-적용하기">Utterances 적용하기</span></h2><p><a href="https://utteranc.es" rel="external nofollow noopener noreferrer" target="_blank">Utterances</a>는 정말 간단하게 적용할 수 있습니다. <a href="https://utteranc.es" rel="external nofollow noopener noreferrer" target="_blank">(https://utteranc.es)</a> 으로 이동합니다.</p><p><img src="https://github.com/cheese10yun/cheese10yun.github.io/blob/master/utterances/utterances-repo.png?raw=true" alt=""><br>위 문서대로 진행하면 됩니다.</p><p><code>repo</code> 설정은 <code>owner/repo</code> 형식 그대로  <code>cheese10yun/blog-comment</code> 처럼 사용하면 됩니다.</p><p><code>Blog Post ↔️ Issue Mapping</code> 설정은 자신의 블로그 플랫폼에 맞게 설정합니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/cheese10yun.github.io/master/utterances/utterances-copy-button.png" alt=""></p><p>최종적으로 <code>Copy</code>을 누르면</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://utteranc.es/client.js"</span></span><br><span class="line">        repo=<span class="string">"cheese10yun/blog-comment"</span></span><br><span class="line">        issue-term=<span class="string">"pathname"</span></span><br><span class="line">        theme=<span class="string">"github-light"</span></span><br><span class="line">        crossorigin=<span class="string">"anonymous"</span></span><br><span class="line">        <span class="keyword">async</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>위 같은 코드가 복사되는 것을 확인할 수 있습니다. 이제 사용 중인 블로그 플랫폼에 해당 코드를 적용하면 됩니다. 저는 Hexo Blog을 사용하고 있어 Hexo 기준으로 설명드리겠습니다.</p><h2><span id="hexo에-utterances-적용">Hexo에 Utterances 적용</span></h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">utterances:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">cheese10yun/blog-comment</span></span><br><span class="line"><span class="attr">  issue_term:</span> <span class="string">title</span></span><br><span class="line"><span class="attr">  theme:</span> <span class="string">github-light</span></span><br></pre></td></tr></table></figure><p>위에서 생성된 코드의 값들을 설정 파일로 분리 시켰습니다. 이제 설정값 기반으로 컴포넌트를 만들면 됩니다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># /themes/beantech/layout/comment.ejs</span><br><span class="line">&lt;!--  utteranc comment --&gt;</span><br><span class="line">&lt;% if (config.utterances.enable == true) &#123; %&gt;</span><br><span class="line">&lt;script src=&quot;https://utteranc.es/client.js&quot;</span><br><span class="line">        repo=&quot;&lt;%= config.utterances.repo %&gt;&quot;</span><br><span class="line">        issue-term=&quot;&lt;%= config.utterances.issue_term %&gt;&quot;</span><br><span class="line">        label=&quot;Comment&quot;</span><br><span class="line">        theme=&quot;&lt;%= config.utterances.theme %&gt;&quot;</span><br><span class="line">        crossorigin=&quot;anonymous&quot;</span><br><span class="line">        async&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>Comment 컴포넌트를 만들었으면 Post Layout에 Comment 컴포넌트를 추가하겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># /themes/beantech/layout/post.ejs</span><br><span class="line">...</span><br><span class="line">&lt;!-- Comment --&gt;</span><br><span class="line">&lt;%- partial(&apos;comment&apos;) %&gt;</span><br></pre></td></tr></table></figure><p><code>post.ejs</code>에 위의 코드를 입력합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server --watch --draft</span><br></pre></td></tr></table></figure><p>hexo를 실행하면</p><p><img src="https://raw.githubusercontent.com/cheese10yun/cheese10yun.github.io/master/utterances/utterances-view.png" alt=""><br>적용된것을 확인 확인할 수있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;utterances-소개&quot;&gt;Utterances 소개&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://utteranc.es&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;
      
    
    </summary>
    
    
      <category term="Utterances" scheme="https://cheese10yun.github.io/tags/Utterances/"/>
    
  </entry>
  
  <entry>
    <title>생산성 향상 - 비기는 없다</title>
    <link href="https://cheese10yun.github.io/productivity/"/>
    <id>https://cheese10yun.github.io/productivity/</id>
    <published>2019-07-21T08:40:00.000Z</published>
    <updated>2019-10-27T14:36:51.710Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="들어가기-앞서">들어가기 앞서</span></h2><p>생산성에 대해서 더 정확히는 생산성을 위해서 많은 것들을 도입하는데 왜 다 실패하는 것인지에 대해서 이야기해보고 싶다. 나는 2016.05 년부터 사회에 나와서 이제 3년 2개월 정도 프로그래밍 경험이 있다. 이런 짧은 경험으로 생산성과 프로세스에 대해서 논하는 게 조금은 부끄럽지만 내 생각을 한번 글로 정리해보고 싶어 이렇게 포스팅을 하려고 한다. 이 글의 전반적인 내용은 나의 실패의 연대기다. 그래서 지극히 주관적이고 개발자 입장에서 생각한 내용이니 충분히 비판적인 시각으로 글을 읽어줬으면 한다. 뻔한 문구겠지만 그래도 이런 실패를 통해서 나는 프로그래밍 능력은 많이 향상되었다. 거짓말 조금 보태서 한 달 단위로 성장하는 느낌을 받았다. <s>지난 일들은 추억 보정이 되기 때문인지도 모르겠다.</s></p><h2><span id="나의-연대기">나의 연대기</span></h2><p>3년 2개월 경력 치고는 5번의 이직의 경험이 있다. 작은 스타트업에서부터 조금 큰 규모의 스타트업 등 다양하다. 작은 스타트업을 다닐 때 그때 그 당시의 나에게도 해당 기업의 프로세스는 납득하기 힘들었다. 물론 스타트업 초기에서 제대로 된 프로세스를 갖기는 힘들다고 하지만 그래도 프로세스는 납득하기 어려웠다. 그래서 내가 속한 개발팀부터라도 조금씩 프로세스를 가지려 많이 노력을 했었다. 세상에는 코드 리뷰, 테스 코드 도입, 객체지향 프로그래밍, 도메인 주도 개발, 애자일 등등 세상에는 많은 비기가 있었다.</p><h2><span id="비기는-없다">비기는 없다</span></h2><p><strong>하지만 비기는 없었다.</strong> 물론 내 개인적인 경험에 국한되는 이야기지만 나에게는 비기는 없었고 여러분에게도 높은 확률로 비기는 없을 것이다. <strong>일단 냉정하게 비기가 왜 필요한지부터 점검해야 한다. 비기가 필요한 시점부터 무언가가 크게 잘못되었다는 것이다.</strong> 그것은 대부분 종합적인 문제일 것이다. 프로세스, 개개인의 역량, 해당 분야의 전문성, 커뮤니케이션 등등 이런 것을 다 무시한 체 이 어려운 문제를 구원해줄 구원자를 찾는 것이다. <strong>구원을 찾는 거 자체가 이미 구원자(비기) 말고는 답이 없다는 현 상황을 반증하는 것이다.</strong></p><h3><span id="그게-싫은-것이다">그게 싫은 것이다.</span></h3><p>냉정하게 지금 우리 팀, 우리 회사에 문제점을 정말 냉철하게 봐야 한다. <strong>하지만 그것은 어렵다.</strong> 누군가를 비난해야 할 때도 있고, 누군가가 실력적으로 형편이 없어 프로젝트 딜레이가 되는 문제일 수도 있다. 구성원들 간의 커뮤니케이션이 문제일 수도 있다. 이런 것들은 불편하고 어렵다 보니 냉정하게 진단하기 싫은 것이다. 이런 모든 문제를 일단 가리고 <strong>외부에서 구원을 찾는다. 그 비기가 우리의 모든 문제를 해결해 줄 것이라 믿고</strong> 이렇게 되면 이런 비기의 유혹은 뿌리치기 힘들다. 그리고 같은 실수를 반복한다.</p><h3><span id="냉정">냉정</span></h3><p>냉정해져야 한다. 지금 프로젝트가 엉망인 것은 단순히 프로세스만의 문제가 아니다. <strong>무슨 문제가 있다. 그것을 프로세스 문제로 퉁치고 다른 비기를 찾으려 하면 안 된다. 냉정하게 현상태를 분석하고 판단해야 한다.</strong></p><p>예를 들어보자 자바 서블릿을 직접 구현해서 웹 프로젝트를 진행하고 있는 팀은 스프링 부트라는 프레임워크를 알게 되었고 이것을 이용하면 웹 프로그래밍이 더 효율적으로 할 수 있다고 판단해서 스프링 부트를 도입했다. 이것은 맞는 말이다 누가 봐도 자바라는 언어 기반으로 웹 프로젝트를 한다면 스프링 기반으로 프로젝트를 안 할 이유가 없다. 하지만 저 팀이 프로젝트를 성공적으로 마칠 수 있을까? <strong>도입하려는 것이 그렇게 좋은 것이라면 왜 우리는 그동안 그것을 도입하지 않았는지를 점검해봐야 한다.</strong></p><h3><span id="결국엔-비기는-없다">결국엔 비기는 없다.</span></h3><p>저 팀에서는 스프링이라는 것이 비기로 느껴질 것이다. 실제로 스프링은 정말 좋은 프레임워크다. 하지만 단순히 스프링 도입으로 이 문제는 해결되지 않는다. 우선 그들은 서블릿을 직접 구현할 정도로 현지 이 생태계를 이해하지 못한다. 절대적인 실력 부족이다. 이게 이 팀의 냉정한 현주소다.(물론 이게 문제가 아니라 다른 것이 문제일 수도 있다 그만큼 본질적인 문제를 찾기는 힘들다.) <strong>이것을 보려 하지 않고 단순하게 비기(스프링)을 도입하려 해서 이 문제를 해결하겠다는 것 자체가 문제이다. 자신과 현재 자신의 팀의 현주소를 냉정하게 판단해보라</strong> 이런 상황에서 스프링을 도입해도 결과는 달라지지 않을 것이다. 스프링이란 것 외에 다른 것들을 대입해봐도 마찬가지다. Jira를 통한 이슈 트래킹, Confluence를 통한 문서화, 코드 리뷰를 통한 코드 품질 향상, 데일리 미팅을 통한 업무 공유, 세부 기획을 통한 일감 상세화 등등 이런 것들을 도입하려고 할 때 왜 그동안에 그것을 도입하지 않았나에 대한 회고부터 해야 한다. 그리고 이런 프로세스의 도입 하나로 현재의 문제를 하려는 태도 자체가 지나치게 비양심적인 것이다.</p><h3><span id="정답은-이거야">정답은 이거야</span></h3><p>그동안 어렴풋이 느껴왔던 문제들을 어렵게 수면 위로 올리고 <strong>정답은 이거야</strong>를 외치고 특정 프로세스를 도입하는 경우가 많다. 나 또한 이 실수를 수없이 반복했다. 어렵게 수면 위로 올려진 문제들을 프로세스 도입 하나로 모두 해결될 것이라는 행복 회로를 돌리기 시작한다. <strong>이 이슈들은 Back Log에 남지도 않고 이미 완료됐다고 Done 처리하듯이 우리의 사고 속에서 없어지고 다시 수면 아래로 잠든다.</strong> 새로운 무언가의 도입으로 우리들의 문제는 해결되지 않는다. 그저 다시 수면 아래로 내려갈 뿐이다.</p><h2><span id="패배감">패배감…</span></h2><p>자꾸 진실을 마주하지 않고 비기를 찾고 비기를 연습해서 도입해보고 그것이 또 실패로 찾아오면 개인은 너무 힘들다… 나 또한 많은 것을 노력했지만 진실을 마주하지 않고 비기만을 찾았고 그 결과 수많은 패배를 했다. <strong>개인의 경험은 개인에게는 절대적이다.</strong> 이런 패배감을 반복적으로 느끼면 개인은 더 이상 노력하기 힘들다. <strong>이런 패배감 때문에 프로젝트에서 떠나고 싶어진다.</strong></p><h2><span id="그럼에도-불과하고">그럼에도 불과하고…</span></h2><p><strong>그럼에도 불과하고 개인은 성장해야 한다.</strong> 위 같은 상황일지라도 스프링을 도입하고 패배감을 맛보고 성장해야 한다. 어쩔 수 없다. 포기할 수는 없지 않은가. <strong>해당 조직에 있을 때 최대한 많은 노력을 하고 그것으로 발판 삼아 성장해야 한다.</strong> 아이러니하게도 이렇게 패배를 통해서 성장했던 것이 내 프로그래밍 실력을 단기간 안에 많은 것을 향상시키기도 했다.</p><p>그대가 속한 조직이 패배감을 느끼고 계속 도전할 가치가 있다면, 함께 일하는 동료와 해당 서비스가 매력적이라면, 그래도 조금씩이라도 성장하고 쟁취한다는 피드백이 있다면 <strong>그럼에도 불과하고 개인은 기꺼이 비기에 도전한다. 그리고 쟁취할 수 있다고 믿는다.</strong></p><h2><span id="이직-고려">이직 고려</span></h2><p>그대가 주니어라면 조직을 바꾸는 것은 어렵도 힘든 일이다. 하지만 어렵고 힘들 일이니 하지 도전하지 말라는 소리는 절대 아니다. <strong>냉정하게 내가 그 어려운 도전을 할만한 가치 있는 매력적인 회사, 팀, 동료, 서비스 인가 판단해보라.</strong> 그것이 아니라면 이직하는 게 맞는다고 본다.</p><h2><span id="맺는말">맺는말</span></h2><p>이 글을 쓰기 조심스러운 이유 중 하나는 내가 속했던 회사 중에 위에서 언급한 부분에 해당되지 않은 회사도 있었고 그곳까지 비판하는 거 같아 조심스럽다.</p><p>또 다른 하나는 외부에서 나는 무언가를 깨달은 것처럼 통찰력 있는 사람, 혹은 그런 척하는 사람으로 느껴지는 것들이 부담스럽다. <strong>나는 평범한 주니어 개발자고 지금도 똑같은 문제로 고민하고 좌절한다.</strong><br>그래도 성장한 게 있다면 <strong>비기는 없고 구원이라는 것은 외부에서 찾지 말고 내부에서 찾아야 한다.</strong> 라는 것이다.</p><p>그리고 또 내가 도입하려는 것이 대부분 옳은 것이고 그것을 받아들이지 못한 회사, 팀의 문제인 것처럼 보이는 것도 부담스럽다. <strong>확실히 이야기 하지만 나도 무턱대고 비기를 도입하려 했었고 그래서 실패한 것이다. 일차적으로 내 역량의 문제인 것이다.</strong></p><p>반복해서 이야기하는 것이지만 중요한 것은 <strong>내가 이런 역경과 고난을 해쳐갈만한 가치 있는</strong> 회사, 팀, 서비스 인지가 중요하다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;생산성에 대해서 더 정확히는 생산성을 위해서 많은 것들을 도입하는데 왜 다 실패하는 것인지에 대해서 이야기해보고 싶다. 나는 2016.05 년부터 사회에 나와서 이제 3
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>테스트 코드 작성에 대한 나름의 고찰</title>
    <link href="https://cheese10yun.github.io/spring-about-test/"/>
    <id>https://cheese10yun.github.io/spring-about-test/</id>
    <published>2019-07-21T05:00:01.000Z</published>
    <updated>2019-07-22T18:32:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/test-code" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인해주세요.</p></blockquote><p>스프링 기반으로 많은 테스트 코드를 작성하면서 느꼈던 나름의 고찰과 어려움을 정리하는 포스팅입니다. 사실은 테스트 코드 작성 시 효율적인 방법을 소개하는 포스팅을 진행하려 했으나 이런저런 고민들 때문에 명확한 결론이 나지 않아서 이런 고민들을 정리한 포스팅입니다.</p><h2><span id="pojo-테스트는-언제나-옳다">POJO 테스트는 언제나 옳다</span></h2><p>이전에 포스팅한 <a href="https://github.com/cheese10yun/spring-guide/blob/master/docs/test-guide.md" rel="external nofollow noopener noreferrer" target="_blank">Test 전략 가이드</a>, <a href="https://github.com/cheese10yun/spring-guide/blob/master/docs/test-guide.md" rel="external nofollow noopener noreferrer" target="_blank">Spring Boot 테스트 종류</a> 등 스프링에서는 매우 다양한 테스트 방법을 제공해주고 있습니다. 이런 Slice 테스트 지원으로 테스트 하고자 하는 레이어를 부분적으로 빠르게 테스트할 수 있습니다.</p><p><strong>이런 강력한 기능들 때문에 POJO에 대한 테스팅은 상대적으로 관심도가 낮다 보니 POJO에 대한 테스트 코드 작성에도 관심이 부족한 거 같습니다.</strong></p><p>POJO 테스트의 장점</p><ul><li>POJO 객체를 테스트하는 것이라서 빠르다.</li><li>디펜더시가 상대적으로 적어서 테스트 코드 작성이 편하다.</li><li>단위 테스트하기 가장 이상적이다.</li></ul><p>POJO 테스트의 대표적인 항목들은 Util 객체, Domain 객체 등이 있습니다. <strong>특히 ORM을 사용하고 있다면 도메인 객체들의 테스트 코드는 해당 프로젝트의 도메인 지식을 설명해주는 아주 좋은 문서 역할을 해줍니다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>(expected = CouponExpireException.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 만료일이지난_쿠폰_사용_불가() &#123;</span><br><span class="line">        <span class="keyword">final</span> Coupon coupon = CouponBuilder.build(LocalDate.now().minusDays(<span class="number">1</span>));</span><br><span class="line">        coupon.use();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>(expected = CouponAlreadyUseException.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 이미_사용한_쿠폰은_쿠폰_사용_불가() &#123;</span><br><span class="line">        <span class="keyword">final</span> Coupon coupon = CouponBuilder.build(LocalDate.now().plusDays(<span class="number">3</span>));</span><br><span class="line">        coupon.use();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 이미 사용한 쿠폰을 다시 한번 사용했을 다시 사용</span></span><br><span class="line">        coupon.use();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 사용가능_쿠폰_사용시_used_is_true() &#123;</span><br><span class="line">        <span class="keyword">final</span> Coupon coupon = CouponBuilder.build(LocalDate.now().plusDays(<span class="number">1</span>));</span><br><span class="line">        coupon.use();</span><br><span class="line">        assertThat(coupon.isUsed()).isTrue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>쿠폰 테스트 코드를 통해서 쿠폰 도메인의 비즈니스 요구 사항 나타내는 도큐먼트로 볼 수 있습니다.</p><h2><span id="matchers는-assertj가-좋다">Matchers는 AssertJ가 좋다.</span></h2><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/test-code/images/CoreMatchers.png" alt=""></p><p>위 그림은 assertThat은 <code>import static org.junit.Assert.assertThat;</code>에서 가져온 assertThat입니다. 해당 Matchers는 자동완성 기능을 제공해주지 않아 무슨 메서드가 있는지 일단 외우고 있어야 합니다. 다른 Matchers들도 어느 정도 추천 자동 완성 기능을 제공해주고 있지만 매개변수로 넘기는 방식입니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/test-code/images/AssertJ.png" alt=""><br>반면 <code>AssertJ</code>는 사용법은 매개변수를 넘기는 방식이 아닙니다. <code>assertThat(coupon.isUsed())</code> 코드 뒤에 <code>.</code>을 붙여 사용하는 방식이라서 해당 함수가 무엇이 있는지 명확하게 알려줍니다. 그리고 AssertJ는 다른 Matchers에 비해 테스트하기 편리한 메서드들을 제공해줍니다. <strong>JUnit을 사용하고 있다면 Matchers는 AssertJ를 적극 추천합니다.</strong></p><h2><span id="테스트만을-위한-코드">테스트만을 위한 코드</span></h2><p>테스트 코드를 작성하기 위해서 테스트 코드에서 사용하는 코드를 작성할 때가 있습니다. 테스트에만 사용하는 코드는 객체 간의 협력관계에는 참여하지 않지만 코드로만 존재하기 때문에 그 존자 자체가 저는 부정적으로 생각합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MemberRepository memberRepository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Member <span class="title">create</span><span class="params">(@RequestBody MemberSingUpRequest dto)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> memberRepository.save(<span class="keyword">new</span> Member(dto.getEmail(), dto.getName()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberSingUpRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NotEmpty</span> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Email</span> <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 API가 있을 경우 아래처럼 테스트 코드를 작성할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberApiTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">protected</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> 회원가입테스트() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    <span class="keyword">final</span> MemberSingUpRequest dto = <span class="keyword">new</span> MemberSingUpRequest(<span class="string">"yun"</span>, <span class="string">"yun@asd.com"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    <span class="keyword">final</span> ResultActions resultActions = mvc.perform(post(<span class="string">"/members"</span>)</span><br><span class="line">        .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">        .content(objectMapper.writeValueAsString(dto)))</span><br><span class="line">        .andDo(print());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//then</span></span><br><span class="line">    resultActions</span><br><span class="line">        .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 중요한 것은 Given 절에서 Request Body가 받을 DTO를 만들어야 하는 점인데. 실제 값 바인딩은 리플렉션 기반으로 처리되니 별다른 생성자를 만들 필요가 없습니다. 하지만 테스트 코드에서는 json 값을 넘겨줘야 하기 때문에 테스 코드 작성을 위 헤서 아래와 같은 생성자를 만들어야 합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MemberSingUpRequest</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> String email)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.email = email;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Validation을 어노테이션들이 동작하지 않습니다. 내가 의도하지 않은 객체 생성이 이루어지는 가능성이 있고 무엇보다 해당 코드는 테스트 코드에서만 사용되는 코드인 점입니다.</p><h3><span id="json-기반으로-테스트">JSON 기반으로 테스트</span></h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"yun"</span>,</span><br><span class="line">  <span class="attr">"email"</span>: <span class="string">"yun@asd.com"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberApiTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> json_파일로테스트() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    <span class="keyword">final</span> String requestBody = readJson(<span class="string">"classpath:member-singup.json"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    <span class="keyword">final</span> ResultActions resultActions = mvc.perform(post(<span class="string">"/members"</span>)</span><br><span class="line">        .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">        .content(requestBody))</span><br><span class="line">        .andDo(print());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//then</span></span><br><span class="line">    resultActions</span><br><span class="line">        .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>json 파일을 읽어 들여 String으로 값을 전달하게 되면 위에서 작성한 생성자 코드를 사용하지 않아도 됩니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"orderer"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"yun"</span>,</span><br><span class="line">    <span class="attr">"email"</span>: <span class="string">"yun@asd.com"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"product"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"양말"</span>,</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">123233</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"바자"</span>,</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">1000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"치마"</span>,</span><br><span class="line">      <span class="attr">"price"</span>: <span class="number">1120</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"coupon"</span>: &#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"xx2sd292kd"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"address"</span>: &#123;</span><br><span class="line">    <span class="attr">"address1"</span>: <span class="string">"서울블라브라..."</span></span><br><span class="line">    <span class="string">"address2"</span>: <span class="string">"어디 동..."</span>,</span><br><span class="line">    <span class="attr">"zip"</span>: <span class="string">"123-2332"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>특히 위처럼 json이 복잡한 경우에는 객체 기반으로 생성하는 것이 많이 번거롭습니다. 이런 경우에는 json으로 관리하는 것이 효율적일 수 있습니다.</p><p>단점도 있습니다. 유효성 검사 등 다양한 값을 넣기 위해서는 그만큼 json 파일을 만들어야 하는 단점도 있습니다. 객체 생성으로 만들면 파라미터를 통해서 값만 변경할 수 있지만 json 파일로 만들게 되는 경우는 여러 json 만들어서 테스트해야 합니다.</p><h3><span id="default-접근-제어-지시자를-통한-객체-생성">Default 접근 제어 지시자를 통한 객체 생성</span></h3><p>Default 접근 제어 지시자를 사용하면 동일 패키지 내에서는 접근할 수가 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberSingUpRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NotEmpty</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Email</span></span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">  MemberSingUpRequest(<span class="keyword">final</span> String name, <span class="keyword">final</span> String email) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.email = email;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 해당 클래스는 test 디렉토리에 위치합니다.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberSignUpRequestBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MemberSingUpRequest <span class="title">build</span><span class="params">(String name, String email)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MemberSingUpRequest(name, email);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/test-code/images/default-access.png" alt=""></p><p><code>test</code> 디렉터리에 경로가 동일하다면 <code>Default</code> 접근 제어 지시자로 되있는 생성자로 접근이 가능합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> default_접근지시자_를이용한_테스트() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line">  <span class="keyword">final</span> MemberSingUpRequest dto = MemberSignUpRequestBuilder.build(<span class="string">"yun"</span>, <span class="string">"yun@asd.com"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line">  <span class="keyword">final</span> ResultActions resultActions = mvc.perform(post(<span class="string">"/members"</span>)</span><br><span class="line">      .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">      .content(objectMapper.writeValueAsString(dto)))</span><br><span class="line">      .andDo(print());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  resultActions</span><br><span class="line">      .andExpect(status().isOk());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 식으로 테스트를 진행하면 동일 패키지에서 밖에 접근하지 못하는 코드이므로 테스트 코드만을 위한 코드이지만 영향을 최소한으로 할 수 있습니다.</p><p>주의해야 할 점은 생성자가 추가됐기 때문에 반드시 기본 생성자를 하나 만들어야 합니다. 이때 접근 제어 지시자는 <code>private</code> 접근 지시자를 통해서 최소한으로 만들어 줍니다. <strong>항상 접근 제어 지시자는 되도록 낮은 것을 사용하는 습관을 갖는 것이 좋습니다.</strong></p><p>Setter를 추가하는 방법도 있겠지만 Setter는 Request, Response 객체 같은 경우에는 최대한 지양하는 것이 좋습니다. 이런 방식은 코드 양이 많기도 하고 애초에 default 생성자라도 있는 것이기 때문에 <strong>현재는 RequestBody 객체가 복잡하면 JSON 기반 테스트를 진행하고 그렇지 않은 경우에는 그냥 public 생서자 or Builder를 이용해서 Given 절을 작성하고 있습니다.</strong></p><h2><span id="setter의-유혹">Setter의 유혹</span></h2><p><a href="https://github.com/cheese10yun/spring-jpa-best-practices/blob/master/doc/step-06.md" rel="external nofollow noopener noreferrer" target="_blank">step-06: Setter 사용하지 않기</a> 및 많은 포스팅에서 Setter 메서드를 지양해야 한다고 말해왔습니다. 하지만 테스트 코드 작성 시 Setter 메서드는 너무 달콤한 유욕이 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OrderStep &#123;</span><br><span class="line">  AWAITING_DEPOSITED, <span class="comment">//  결지 미완료</span></span><br><span class="line">  PAID, <span class="comment">// 지불 완료</span></span><br><span class="line">  REAMDY, <span class="comment">// 배송 준비</span></span><br><span class="line">  SHIPPING, <span class="comment">// 배송중</span></span><br><span class="line">  COMPLETED <span class="comment">// 완료</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeStepToCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.step != OrderStep.SHIPPING) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.step = OrderStep.COMPLETED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>주문의 상태가 있고 배송 완료로 변경하기 위해서는 현재 Step이 SHIPPING 이어야 한다는 로직입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> setter_메서드의_유혹() &#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;Product&gt; products = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  products.add(<span class="keyword">new</span> Product(<span class="string">"양말"</span>));</span><br><span class="line">  products.add(<span class="keyword">new</span> Product(<span class="string">"모자"</span>));</span><br><span class="line">  products.add(<span class="keyword">new</span> Product(<span class="string">"바지"</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Order order = Order.order(<span class="string">"yun"</span>, products);</span><br><span class="line">  <span class="comment">// order.setStep(OrderStep.SHIPPING); Setter 메서드가 간절하다.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line">  order.changeStepToCompleted();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  assertThat(order.getStep()).isEqualTo(OrderStep.COMPLETED);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Order 객체를 테스트하기 위해서는 Order 객체를 만들어야 합니다. 그리고 Order 객체는 시간에 따라서 데이터들이 달라집니다. 주문 신청부터 주문 완료까지 Order 객체는 계속해서 변경됩니다.</p><p>적절하게 단위 테스트하기 위해서는 데이터를 특정 시점처럼 만들어야 합니다. 위 테스트도 주문 완료를 테스트하기 위해서 주문 생성 -&gt; 주문 배송 중으로 변경해야 합니다. 이럴 경우 Setter를 쓰면 모든 비니지스 로직을 무시하고 데이터를 특정 시점으로 변경시킬 수 있습니다.</p><p>위 도메인은 상당히 간단한 편이지만 주문, 환불, 주문 부분 취소, 주문 전체 취소 등 다양한 도메인들을 테스트하기 위해서는 특정 시점으로 변경하기 어렵습니다. 위처럼 방어적 로직이 있어 모든 조건이 만족할 때만 데이터를 변경하도록 하기 때문입니다.</p><p>그래서 나름의 <strong>결론은 @Setter를 사용하고 test 코드 작성 시에만 Setter를 사용한다 정도입니다.</strong> 객체지향 관점에서 아무 로직 없는 Setter는 객체 간의 협력관계에서 객체의 자율성을 심하게 훼손시킵니다. 테스트 코드 이외에는 Setter를 사용하지 않아야 한다는 것이 지금의 결론입니다.</p><p><strong>그래도 명확한 가이드가 없는 건 사실입니다. test 디렉터리에서만 Setter 메서드를 사용하지 않는다</strong>라는 팀 차원의 공유만 있을 뿐 그것을 강제할 방법은 없습니다.</p><h2><span id="통합-테스트의-어려움">통합 테스트의 어려움</span></h2><p>통합 테스트에서 어려운 점들이 Given 작성하는 것입니다. 페이징 및 필터 관련된 API를 테스트한다고 했을 경우 데이터를 Set up 해주기가 어렵습니다.</p><p>만약 주문 생성 API를 테스트하기 위해서는</p><ul><li>회원</li><li>상품</li><li>상품 카테고리</li><li>해당 상품의 입점사 정보</li><li>쿠폰 (만약 쿠폰을 사용했을 때 필요)</li></ul><p>아무리 간단하게 생각해도 최소한 이 정도의 데이터를 Set up 해야 합니다. 실제 오픈 커머스 같은 경우에는 주문 한 번을 하기 위해서 수십 개의 테이블들을 Set up 해야 합니다.<br>테스트를 위해서 객체를 만들고 JPA로 데이터를 Set up 한다면 차라리 저는 테스트를 포기하겠습니다.</p><h3><span id="import를-이용한-데이터-set-up">Import를 이용한 데이터 Set up</span></h3><p>스프링이 로드될 때 <code>data.sql</code>을 읽어 들여 Given을 만드는 방식입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># data.sql</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span></span><br><span class="line">    <span class="string">`member`</span> (<span class="string">`id`</span>, <span class="string">`email`</span>, <span class="string">`name`</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">'yun@asd.com'</span>, <span class="string">'yun'</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">'wan@asd.com'</span>, <span class="string">'wan'</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">'jin@asd.com'</span>, <span class="string">'jin'</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">'ck@asd.com'</span>, <span class="string">'ck'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">member_page_test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line">  <span class="keyword">final</span> ResultActions resultActions = mvc.perform(get(<span class="string">"/members"</span>)</span><br><span class="line">      .contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class="line">      .andDo(print());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  resultActions</span><br><span class="line">      .andExpect(status().isOk())</span><br><span class="line">      .andExpect(jsonPath(<span class="string">"content"</span>).exists())</span><br><span class="line">      .andExpect(jsonPath(<span class="string">"pageable"</span>).exists())</span><br><span class="line">      .andExpect(jsonPath(<span class="string">"pageable"</span>).exists())</span><br><span class="line">      .andExpect(jsonPath(<span class="string">"numberOfElements"</span>).value(<span class="string">"4"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SQL</code>로 given을 구성하게 되면 테스트하고자 하는 부분의 when, then 구절은 어렵지 않게 작성할 수 있습니다. 또 비즈니스 로직과 상관없이 데이터를 특정 시점으로 만들 수 있습니다.</p><p>하지만 단점도 있습니다. 칼럼의 변경 및 확장 시 테스트 코드의 지속적인 관리가 어렵다는 점이 있습니다. 또 누군가의 <code>member</code> insert를 추가적으로 하면 <code>.andExpect(jsonPath(&quot;numberOfElements&quot;).value(&quot;4&quot;))</code> 테스트 코드는 실패하게 됩니다. <strong>모든 작업자들이 <code>data.sql</code>을 추가 및 변경하다 보면 문제가 계속 생기게 됩니다.</strong></p><h3><span id="나름의-해결-방법">나름의 해결 방법</span></h3><p>위에서도 말했듯이 <code>data.sql</code>을 모든 작업자가 공동으로 사용하게 되니 문제가 발생한다면 테스트 단위로 <code>data-{xxx-test}.sql</code>을 관리하면 좋을 거 같습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">member_page_test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line">  dataSetUp(<span class="string">"classpath:member_page_test.sql"</span>); <span class="comment">// 로직은 구현하지 않았습니다.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line">  <span class="keyword">final</span> ResultActions resultActions = mvc.perform(get(<span class="string">"/members"</span>)</span><br><span class="line">      .contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class="line">      .andDo(print());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  resultActions</span><br><span class="line">      .andExpect(status().isOk())</span><br><span class="line">      .andExpect(jsonPath(<span class="string">"content"</span>).exists())</span><br><span class="line">      .andExpect(jsonPath(<span class="string">"pageable"</span>).exists())</span><br><span class="line">      .andExpect(jsonPath(<span class="string">"pageable"</span>).exists())</span><br><span class="line">      .andExpect(jsonPath(<span class="string">"numberOfElements"</span>).value(<span class="string">"4"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON 기반으로 테스트처럼 객체로 생성하기 어려운 Given을 JSON에서는 json 파일로 했고 여기에서는 SQL 파일로 진행합니다. 이 방식으로는 실제 실무에서 사용해본 경험은 없어 다른 문제들이 발생할지는 모르겠습니다.</p><h2><span id="결론">결론</span></h2><p>결론이라고 말하기는 어렵지만 테스트 코드를 작성할 때 Given을 만들기 위해서 많은 어려운 점이 있습니다. 지금의 제 결론은 Given을 최대한 편리하게 작성하는 방법과 의존도를 낮게 코딩해서 최대한 단위 테스트를 하기 쉽게 의도적으로 설계하고 코딩하는 편이 좋다고 생각합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/test-code&quot; rel=&quot;external nofollow noopener noreferrer
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="Test" scheme="https://cheese10yun.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>JPA Fetch Join 적용시 limit 동작하지 않는 이슈</title>
    <link href="https://cheese10yun.github.io/jpa-fetch-paging/"/>
    <id>https://cheese10yun.github.io/jpa-fetch-paging/</id>
    <published>2019-07-08T15:00:00.000Z</published>
    <updated>2019-07-08T17:11:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>결론부터 말씀드리면 Pagealge + Fetct Join을 이용해서 페이징 처리 시 특정 조건의 경우 limit이 발생하지 않아 <strong>테이블 FULL Scan 진행해서 애플리케이션 단에서 limit을 조정하는 경우가 있습니다.</strong> 성능에 막대한 영향을 주기 때문에 조심해야 합니다.</p><h2><span id="조건">조건</span></h2><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-fetch-join/images/table.png" alt=""></p><p>주문 1 : 제품 N OneToMany 관계에 대해서 Pageagle 객체를 이용한 fetch join 사용 시 문제가 발생합니다. 아래는 연관관계의 코드입니다.</p><h2><span id="limit-확인">limit 확인</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"orders"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Column</span>(name = <span class="string">"orderer"</span>, nullable = <span class="keyword">false</span>)</span><br><span class="line">  <span class="keyword">private</span> String orderer;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"order"</span>, cascade = CascadeType.ALL)</span><br><span class="line">  <span class="keyword">private</span> List&lt;Product&gt; products = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Column</span>(name = <span class="string">"name"</span>, nullable = <span class="keyword">false</span>)</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="meta">@JoinColumn</span>(name = <span class="string">"order_id"</span>, nullable = <span class="keyword">false</span>)</span><br><span class="line">  <span class="keyword">private</span> Order order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pageable 객체를 이용한 fetch join 쿼리 입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Order</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query</span>(</span><br><span class="line">      value = <span class="string">"select  o from Order o "</span></span><br><span class="line">          + <span class="string">"inner join fetch o.products "</span>,</span><br><span class="line">      countQuery = <span class="string">"select count(o) from Order o"</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function">Page&lt;Order&gt; <span class="title">findByPageWithProducts</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findByPageWithProducts 메서드에 대한 SQL입니다.<br><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-fetch-join/images/fetch-join-sql.png" alt=""></p><p><strong>limit 키워드가 없는 것을 확인할 수 있습니다. 그렇기 때문에 orde 전체를 Full Scan 한 이후에 Pageable size 만큼 애플리케이션 단에서 조절하는 것으로 보입니다.</strong></p><p>그렇다면 JpaRepository에서 제공해주는 findAll + Pageable을 이용한 방식에서는 어떻게 동작하는지 확인해 보겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Order&gt; <span class="title">getOrderAll</span><span class="params">(Pageable pageable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orderRepository.findAll(pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-fetch-join/images/limit-query.png" alt=""></p><p>limit이 정상적으로 동작하는 것을 확인할 수 있습니다. 하지만 N + 1 fetch join 이 제거해서 n +1 문제가 발생하는 합니다.</p><p>fetch join을 제거한 쿼리도 limit이 동작하는지 확인해 보겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(</span><br><span class="line">    value = <span class="string">"select  o from Order o "</span>,</span><br><span class="line">    countQuery = <span class="string">"select count(o) from Order o"</span></span><br><span class="line">)</span><br><span class="line"><span class="function">Page&lt;Order&gt; <span class="title">findByPageWithProducts</span><span class="params">(Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-fetch-join/images/limt2.png" alt=""></p><p>JpaRepository에서 제공해주는 이외의 메서드에서도 limit이 제대로 동작합니다.</p><h2><span id="limit이-결정되는-시점">limit이 결정되는 시점</span></h2><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-fetch-join/images/limit-point.png" alt=""></p><p>PagedExecution에서 doExecute 메서드 동작시 orders select 쿼리가 출력되는 것을 보아 저 시점에서 limit 여부가 결정되는 포인트인 거 같습니다. N + 1 문제를 해결하면서 limit이 동작하게 하는 방법은 아직 못 찾았습니다.</p><h2><span id="결론">결론</span></h2><p>Full Scan 해서 애플리케이션 레벨에서 해당 작업을 진행하는 것보다 N + 1 문제가 발생하더라도 fetch join을 제거하는 것이 현재로서는 그나마 적당한 방법인 거 같습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;결론부터 말씀드리면 Pagealge + Fetct Join을 이용해서 페이징 처리 시 특정 조건의 경우 limit이 발생하지 않아 &lt;strong&gt;테이블 FULL Scan 진행해서 애플리케이션 단에서 limit을 조정하는 경우가 있습니다.&lt;/str
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Fetch Join" scheme="https://cheese10yun.github.io/tags/Fetch-Join/"/>
    
  </entry>
  
</feed>
