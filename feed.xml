<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yun Blog</title>
  <icon>https://www.gravatar.com/avatar/d313a2c442931458ed624a3999d75011</icon>
  <subtitle>기술 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://cheese10yun.github.io/"/>
  <updated>2020-08-12T13:59:22.747Z</updated>
  <id>https://cheese10yun.github.io/</id>
  
  <author>
    <name>Yun</name>
    <email>cheese10yun@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>동일한 Bean(Class)에서 @Transactional 동작 방식</title>
    <link href="https://cheese10yun.github.io/spring-transacion-same-bean/"/>
    <id>https://cheese10yun.github.io/spring-transacion-same-bean/</id>
    <published>2020-08-11T15:00:00.000Z</published>
    <updated>2020-08-12T13:59:22.747Z</updated>
    
    <content type="html"><![CDATA[<p>동일한 Bean 내에서 <code>@Transactional</code>을 사용하는 경우 예상했던 것과 다르게 동작할 수 있습니다. 발생 원인과 해결 방법에 대해서 정리한 포스팅입니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CouponService</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> couponRepository: CouponRepository</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">something</span><span class="params">(i: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"something CurrentTransactionName: <span class="subst">$&#123;TransactionSynchronizationManager.getCurrentTransactionName()&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">this</span>.save(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">save</span><span class="params">(i: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"save CurrentTransactionName: <span class="subst">$&#123;TransactionSynchronizationManager.getCurrentTransactionName()&#125;</span>"</span>)</span><br><span class="line">        (<span class="number">1.</span>.i).map &#123;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">"<span class="variable">$i</span> ...."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            couponRepository.save(Coupon(it.toBigDecimal()))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/transaction"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransactionApi</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> couponService: CouponService</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transactional</span><span class="params">(<span class="meta">@RequestParam</span> i: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        couponService.something(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 <code>Controller</code>에서 <code>something()</code> -&gt; <code>save()</code>을 차례대로 호출하는 코드입니다. <code>save()</code> 메서드에서는 특정 경우 <code>RuntimeException</code>을 발생시키고 있습니다.</p><p>해당 코드의 트랜잭션 흐름은 <code>save()</code> 메서드에 <code>@Transactional</code> 때문에 해당 반복문 전체에 트랜잭션이 묶이게 되고 예외가 발생하면 전체가 Rollback될 것이라고 예상됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request GET &apos;http://localhost:8080/transaction?i=40&apos;</span><br></pre></td></tr></table></figure><p>위 와 같이 해당 컨트롤러를 호출하고 결과를 조회하면 아래와 같습니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/result-1.png" alt=""></p><p>결과는 전체를 롤백 되지 않고 19개가 commit 된 것을 확인할 수 있습니다. 그렇다는 것은 트랜잭션이 묶이지 않고 <code>SimpleJpaRepository</code>의 아래 <code>save()</code> 메서드를 통해서 단일 트랜잭션으로 진행된 것입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">implements</span> <span class="title">JpaRepositoryImplementation</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entityInformation.isNew(entity)) &#123;</span><br><span class="line">em.persist(entity);</span><br><span class="line"><span class="keyword">return</span> entity;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> em.merge(entity);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>즉, 위와 같은 경우에는 동일한 Bean(Class)에서 Spring AOP CGLIB이 동작하지 않습니다.</strong></p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/result-2.png" alt=""></p><p><code>TransactionSynchronizationManager.getCurrentTransactionName()</code> 메서드를 통해서 현재 트랜잭션을 확인해 보면 두 메서드 모두 <code>null</code>이라는 것을 확인할 수 있습니다. 그렇다는 건 <code>this.save()</code> 메서드에 있는 <code>@Transactional</code>이 동작하지 않았다는 것입니다.</p><h2><span id="원인">원인</span></h2><blockquote><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative-annotations" rel="external nofollow noopener noreferrer" target="_blank">Spring Document</a><br>In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation (in effect, a method within the target object calling another method of the target object) does not lead to an actual transaction at runtime even if the invoked method is marked with @Transactional. Also, the proxy must be fully initialized to provide the expected behavior, so you should not rely on this feature in your initialization code (that is, @PostConstruct).</p></blockquote><p>스프링 문서에 따르면 Proxy Default Mode(스프링에서 사용하는 기본 Proxy를 의미하는 거 같음)는 외부 메서드 (외부 Bean, 즉 동일하지 않은 Bean)에서 호출하는 경우에만 프록시를 타고 Self(<code>this.xxx()</code>)를 호출하는 경우 런타임에 <code>@Transactional</code>가 동작하지 않습니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/result-3.png" alt=""></p><p>즉, 위 그림처럼 CGBLIB Proxy를 통해서 <code>save()</code> 메서드가 Proxy 기반으로 <code>@Transactional</code>이 추가가 될 것을 기대했지만 호출하는 곳이 외부 Bean이 아닌 경우에는 Proxy가 인터셉트가 되지 않기 때문에 <code>@Transactional</code>이 동작하지 않게 되는 것입니다.</p><h2><span id="해결-방법">해결 방법</span></h2><p><code>Self Injection</code>, Spring AOP 대신 <code>AspectJ</code> 사용 등 몇 가지 방법을 검색을 통해서 확인했지만 개인적 견해로는 이 방법은 권장하고 싶지는 않습니다. AOP 라이브러리를 변경하는 것은 리스크가 너무 커 보였고, <code>Self Injection</code> 또한 직관적이지 않으며 <code>@Autowired</code>를 사용하는 것이 마음에 들지 않았습니다.</p><p>가장 간단한 해결 방법은 <code>Service</code> 클래스를 나누고 외부 Bean 호출을 통해서 Proxy가 올바르게 동작하게 하는 것입니다. 코드는 다음과 같습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CouponService</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> saveService: SaveService</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">something</span><span class="params">(i: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"something CurrentTransactionName: <span class="subst">$&#123;TransactionSynchronizationManager.getCurrentTransactionName()&#125;</span>"</span>)</span><br><span class="line">        saveService.save(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveService</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> couponRepository: CouponRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">save</span><span class="params">(i: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"save CurrentTransactionName: <span class="subst">$&#123;TransactionSynchronizationManager.getCurrentTransactionName()&#125;</span>"</span>)</span><br><span class="line">        (<span class="number">1.</span>.i).map &#123;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">"<span class="variable">$i</span> ...."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            couponRepository.save(Coupon(it.toBigDecimal()))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당 코드를 다시 호출하면 아래와 같은 결과를 확인할 수 있습니다.<br><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/result-4.png" alt=""></p><p><code>save()</code> 메서드에서 트랜잭션이 생겼으며 해당 아래의 작업은 동일한 트랜잭션을 묶이게 됩니다. 즉 Proxy 기반으로 <code>@Transactional</code>이 동작했으며 예외가 발생하면 모두 Rollback을 진행하게 됩니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;동일한 Bean 내에서 &lt;code&gt;@Transactional&lt;/code&gt;을 사용하는 경우 예상했던 것과 다르게 동작할 수 있습니다. 발생 원인과 해결 방법에 대해서 정리한 포스팅입니다.&lt;/p&gt;
&lt;figure class=&quot;highlight kotl
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="Transactional" scheme="https://cheese10yun.github.io/tags/Transactional/"/>
    
      <category term="CGLIB" scheme="https://cheese10yun.github.io/tags/CGLIB/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 살펴보기</title>
    <link href="https://cheese10yun.github.io/spring-cloud/"/>
    <id>https://cheese10yun.github.io/spring-cloud/</id>
    <published>2020-07-31T15:00:00.000Z</published>
    <updated>2020-08-01T09:36:49.476Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="spring-cloud-config">Spring Cloud Config</span></h1><p>스프링 클라우드 컨피그는 중앙 집중식 마이크로서비스 구성을 지원한다. 여기서 두 가지 중요한 구성 요소의 조합이다.</p><ul><li>스프링 클라우드 컨피그 서버 : 버전 관리 리포지토리로 백업된 중앙 집중식 구성 노출을 지원한다.</li><li>스프링 클라우드 컨피그 클라이언트 : 애플리케이션이 스프링 클라우드 컨피그 서버에 연결하도록 지원한다.</li></ul><h2><span id="github-repository-연결">GitHub Repository 연결</span></h2><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/github-img.png" alt=""></p><p>GitHub Repository에</p><ul><li>micoroservice-a-default.yml</li><li>micoroservice-a-dev.yml</li></ul><p>아래 처럼 작성합니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">  message:</span> <span class="string">"Message From &#123;ENV&#125; Local Git Repository"</span></span><br></pre></td></tr></table></figure><p><code>{ENV}</code>에 ddefault, dev 환경에 맞는 값을 작성합니다.</p><h2><span id="config-server">Config Server</span></h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'org.springframework.cloud:spring-cloud-config-server'</span></span><br><span class="line">implementation <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br></pre></td></tr></table></figure><p>config server 의존 성을 추가합니다. actuator도 편의를 위해서 추가합니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"config-server"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="string">"https://github.com/cheese10yun/msa-study-sample"</span></span><br></pre></td></tr></table></figure><p>config server는 8888 port를 사용하는 관례가 있어 port를 8888로 지정합니다. Github Repository URI 주소를 입력합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@EnableConfigServer</code> 어노테이션을 추가만 하면 별다른 설정없이 Config Server가 설정됩니다.</p><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/intellj-actuator.png" alt=""><br>actuator 의존성이 있으면 IntellJ Endpoints -&gt; Mappings에서 현재 서버의 API mapping 정보를 쉽게 확인할 수 있습니다.</p><p>마우스 왼쪽 클릭을 한 이후에 Open In Http Request…를 클릭하면 쉽게 HTTP 콜을 할 수 있습니다.</p><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/http-call.png" alt=""></p><p>URL 형식은 /{appliation-name}/{profile}/{label}입니다. 위에서 등록한 <code>micoroservice-a-default.yml</code>을 확인해보기 위해서 <code>http://localhost:8888/microservice-a/default</code>을 호출합니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"microservice-a"</span>,</span><br><span class="line">  <span class="attr">"profiles"</span>: [</span><br><span class="line">    <span class="string">"default"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"label"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"c03eecc5d8eabefc4b2a8f085789f42bd5317366"</span>,</span><br><span class="line">  <span class="attr">"state"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">"propertySources"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"https://github.com/cheese10yun/msa-study-sample/microservice-a-default.yml"</span>,</span><br><span class="line">      <span class="attr">"source"</span>: &#123;</span><br><span class="line">        <span class="attr">"application.message"</span>: <span class="string">"Message From Default Local Git Repository"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>응답 값을 보면 해당 properties를 잘 읽어 오는 것을 확인할 수 있습니다.</p><p><code>http://localhost:8888/microservice-a/dev</code>을 호출하면 <code>micoroservice-a-dev.yml</code>의 값을 제대로 읽어 오는지 확인할 수 있습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"microservice-a"</span>,</span><br><span class="line">  <span class="attr">"profiles"</span>: [</span><br><span class="line">    <span class="string">"dev"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"label"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"c03eecc5d8eabefc4b2a8f085789f42bd5317366"</span>,</span><br><span class="line">  <span class="attr">"state"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">"propertySources"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"https://github.com/cheese10yun/msa-study-sample/microservice-a-dev.yml"</span>,</span><br><span class="line">      <span class="attr">"source"</span>: &#123;</span><br><span class="line">        <span class="attr">"application.message"</span>: <span class="string">"Message From Default Dev Git Repository"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="client">Client</span></h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.cloud:spring-cloud-config-client'</span></span><br><span class="line">    implementation <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>필요한 의존성을 추가합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"application"</span>)</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>프로퍼티를 읽을 ConfigurationProperties 객체를 만듭니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ApplicationConfiguration applicationConfiguration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/message"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">welcome</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"message"</span>, applicationConfiguration.getMessage());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당 메시지를 확인할 수 있는 컨트롤러를 만듭니다. <code>getMessage()</code> 메시지는 각 환경마다 다른 메시지를 출력합니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">&#123;ENV&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      uri:</span> <span class="attr">http://localhost:8888</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">microservice-a</span></span><br></pre></td></tr></table></figure><p>파일명은 <code>bootstrap.yml</code>으로 지정합니다. <code>active</code>는 각 환경마다 지정합니다. dev으로 지정하고 <code>http://127.0.0.1:8080/message</code> API를 호출해보겠습니다.</p><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/message-call.png" alt=""></p><p>이것도 인텔리제이를 이용해서 호출하면 간편합니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"Message From Default Dev Git Repository"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Dev</code> 메시지가 출력되는 것을 확인 할 수 있습니다. <code>profiles</code>을 <code>default</code> 으로 지정하면 메시지에는 local 이라는 문자가 출력됩니다.</p><h2><span id="refresh">Refresh</span></h2><p>마이크로서비스 A의 properties의 변경이 생겼을 경우 Refresh API를 호출해서 설정을 변경할 수 있다.</p><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/json-1.png" alt=""></p><p>message API를 호출하면 기존 메시지가 그대로 출력된다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># microservice-a-default.yml</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">  message:</span> <span class="string">"Message From Default Local Git Repository (Properties update...)"</span></span><br></pre></td></tr></table></figure><p><code>microservice-a-default.yml</code> 메시지를 위와 같이 변경한 이후에</p><p>POST <a href="http://127.0.0.1:8080/actuator/refresh%EC%9D%84" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:8080/actuator/refresh을</a> 호출하면</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;config.client.version&quot;,</span><br><span class="line">  &quot;application.message&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Response으로 application.message의 변경을 알려준다. 이후 message api를 호출하면 아래 그림처럼 변경된 Response를 확인 할 수 있다.</p><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/json-2.png" alt=""></p><h2><span id="정리">정리</span></h2><p>Github Repository와 같은 버전 관리 리포지토리로 백업된 중앙 집중 구성으로 properties를 제공해줍니다. 또 Properties 설정 및 단순한 설정으로 클라이언트 애플리케이션이 스프링 클라우드 컨피그 서버에 쉽게 연결되도록 지원해줍니다.</p><h1><span id="spring-cloud-bus">Spring Cloud Bus</span></h1><p>프로덕션 환경에서 실행중인 마이크로서비스 A의 인스턴스가 N대가 있을 경우에는 설정을 변경하기 위해서는 <code>POST http://127.0.0.1:8080/actuator/refresh</code> 요청을 N대의 인스턴스 서버에 N번의 refresh API를 호출 해야한다. 이는 번거러울 뿐만 아니라 실수를 유발하기 쉬운 구조이다.</p><h2><span id="스프링-클라우드-버스를-시용한-변경-전파">스프링 클라우드 버스를 시용한 변경 전파</span></h2><p>스프링 클라우 버스를 사용해서 Rabbit MQ 같은 메시지 브로커를 통해 변경 사항을 여러 인스턴스에 전달할 수 있다.</p><p>각 마이크로서비스의 인스턴스는 애플리케이션 구동시에 스프링 클라우드 버스에 등록한다. 마이크로서비스의 인스턴스 중 하나에 refresh가 호출되면 스프링 클라우드 버스는 모든 마이크로서비스 인스턴스에 변경 이벤트를 전달하게 된다.</p><h2><span id="rabbit-mq-설치">Rabbit MQ 설치</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── config-server</span><br><span class="line">├── docker-compose.yaml</span><br><span class="line">├── microservice-a</span><br><span class="line">├── microservice-a-default.yml</span><br><span class="line">├── microservice-a-dev.yml</span><br><span class="line">├── service-consumer</span><br><span class="line">├── static</span><br><span class="line">└── volumes</span><br></pre></td></tr></table></figure><p>프로젝트 루트 디렉토리에 volumes 디렉토리를 만들고, gitginore를 추가 해줍니다. 해당 디렉토리에 docker rabbmit mq가 저장됩니다.</p><p><code>docker-compose.yaml</code>  파일은 아래와 같이 준비 해줍니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">bus.rabbitmq</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">rabbitmq:3.7-management</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"5672:5672"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"15672:15672"</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">RABBITMQ_DEFAULT_USER</span> <span class="string">=</span> <span class="string">user</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">RABBITMQ_DEFAULT_PASS</span> <span class="string">=</span> <span class="string">user</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">bus</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./volumes/bus-rabbitmq:/var/lib/rabbitmq</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd 프로젝트 루트 디렉토리</span><br><span class="line">$ docker-compose -up -d</span><br></pre></td></tr></table></figure><h2><span id="client">Client</span></h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-bus-amqp'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>필요한 의존성을 추가합니다.</p><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/bus-log.png" alt=""><br>서버가 시작될때 스프링 클라우드 버스에 등록되고, 클라우드 버스의 이벤트를 수신하게 됩니다. Rabbmit MQ 컨넥션은 자동으로 연결됩니다. (스프링 너란 자식…)</p><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/intellj-port-2.png" alt=""></p><p>포트를 8080, 8081을 설정해서 2대의 서버를 구동 시킵니다.</p><h2><span id="bus-refresh">Bus Refresh</span></h2><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/bus-mapping.png" alt=""></p><p><code>microservice-a-default.yml</code>을 아래처럼 변경합니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">  message:</span> <span class="string">"Message From Default Local Git Repository (Spring Cloud Bus)"</span></span><br></pre></td></tr></table></figure><p><code>/bus/refresh</code> API가 추가되 었습니다. 해당 API를 호출합니다. (8081을 호출해도 됩니다.)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:8080/bus/refresh</span><br></pre></td></tr></table></figure><p>refresh 호출 이후에 message를 호출합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET http://localhost:8081/message</span><br></pre></td></tr></table></figure><p>8080 refresh를 호출하더라도 다른 8081 서버도 반영되는 것을 확인할 수 있습니다.</p><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/8081-result.png" alt=""></p><h1><span id="eureka">Eureka</span></h1><h2><span id="네임-서버">네임 서버</span></h2><p>마이크로서비스 아키텍처는 서로 상호 작용하는 더 작은 마이크로서비스가 필요 하다. 이 밖에도 각 마이크로서비스의 인스턴스가 여러 개 있을 수 있다. 마이크로서비스의 새로운 인스턴스가 동적으로 생성되고 파괴되면 외부 서비스의 연결 및 구성을 수동으로 유지하는 것이 어려울 수 있다. <strong>네임 서버는 서비스 등록 및 서비스 검색 기능을 제공한다.</strong> 네임 서버는 마이크서비스가 이들 자신을 등록할 수 있게 하고, 상호 작용하고자 하는 다른 마이크러서비스에 대한 URL을 찾을 수 있게 도와준다.</p><h2><span id="url-하드-코딩의-한계">URL 하드 코딩의 한계</span></h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">microservice-a:</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    listOfServers:</span> <span class="attr">http://localhost:8080,http://localhost:8081</span></span><br></pre></td></tr></table></figure><ul><li>마이크로서비스 A의 새 인스턴스가 생성된다.</li><li>마이크로서비스 A의 기존 인스턴스는 더 이상 사용할 수 없다.</li><li>마이크로서비스 A가 다른 서버로 이동됐다.</li></ul><p>이런 모든 경우에 구성을 업데이트해야 하며, 변경 사항을 적용하기 위해서는 마이크로서비스가 새로 고쳐져야 한다.</p><h2><span id="네임-서버-작동">네임 서버 작동</span></h2><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/name-server.png" alt=""></p><ul><li><strong>모든 마이크로서비스는 각 마이크로서비스가 시작될때 네임 서버에 등록한다.</strong></li><li>서비스 소비자가 특정 마이크로 서비스의 위치를 얻으려면 네임 서버를 요청해야한다.</li><li>고유한 마이크로서비스 ID가 각 마이크로서비스에 지정된다. 이것을 등록 요청 및 검색 요청에서 키로 사용된다.</li><li>마이크로서비스는 자동으로 등록 및 등록 취소할 수 있다.</li><li>서비스 소비자가 마이크로서비스ID로 네임 서버를 찾을 때마다 해당 특정 마이크로서비스의 인스턴스 목록을 가져온다.</li></ul><h2><span id="구현">구현</span></h2><h3><span id="유레카-서버-설정">유레카 서버 설정</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>필요한 디펜던시를 추가합니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3><span id="유레카-마이크로-서비스-등록">유레카 마이크로 서비스 등록</span></h3><p>기존에 서비스들을 유레카 서버에게 접속할 수있도록 서비스 등록 작업을 진행합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroserviceAApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(MicroserviceAApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>의존성 추가 및 <code>@EnableDiscoveryClient</code> 어노테이션 추가합니다.</p><h3><span id="유레카와-마이크로-서비스-연결">유레카와 마이크로 서비스 연결</span></h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#microservice-a:</span></span><br><span class="line"><span class="comment">#  ribbon:</span></span><br><span class="line"><span class="comment">#    listOfServers: http://localhost:8080,http://localhost:8081</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>(<span class="string">"com.cloud.serviceconsumer"</span>) <span class="comment">// 어노테이션 추가</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ServiceConsumerApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마이크로서비스A의 URL을 하드 코딩했을 경우 추가적인 서버 증성작업이 어렵다. 서비스 소비자 마이크로서비스가 유레카 서비스로부터 URL을 알아낼 수 있어야한다. 하드코딩된 URL정보를 주석처리 하고 아래의 어노테이션을 추가하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"microservice-a"</span>)</span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"microservice-a"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomServiceProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/random"</span>)</span><br><span class="line">  <span class="function">List&lt;Integer&gt; <span class="title">getRandomNumbers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="동작-순서">동작 순서</span></h3><ol><li>마이크로서비스 A의 각 인스턴스가 시작되면 유레카 네임 서버에 등록한다.</li><li>서비스 소비자 마이크로서비스는 마이크로서비스 A의 인스턴스ㅔ 대해 유레카 네임 서버를 요청한다.</li><li>서비스 소비자 마이크로서비스는 립본 클라이언트-클라이언트 로드 밸런서를 사용해 소출할 마이크로서비스 A의 특정 인스턴스를 결정한다.</li><li>서비스 소비자 마이크로서비스는 마이크로서비스 A의 특정 인스턴스를 호출한다.</li></ol><p>유레카의 가장 큰 장점은 서비스 소비자 마이크로서비스가 마이크로서비스 A와 분리된다는 것이다. 서비스 소비자 마이크로서비스는 마이크로서비스 A의 새로운 인스턴스가 나타나거나 기존 인스턴스가 디운될 때마다 재구성할 필요가 없다.</p><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/eureka-dashboard.png" alt=""><br>유레카 데시보드에서 여러 마이크로서비스를 확인 할 수 있다.</p><h1><span id="ribbon">Ribbon</span></h1><h2><span id="로드-밸런싱">로드 밸런싱</span></h2><p>마이크로서비스는 클라우드-네이티브 아키텍처의 가장 중요한 빌딩 블록이다. 마이크로서비스 인스턴스는 특정 마이크로서비스의 로드에 따라 확대 및 축소된다. 부하가 마이크로서비스의 다른 인스턴스 간에 똑같이 분산되도록 하려면 로드밸런싱의 기술피 필수이다. 로드 밸런싱은 로드가 마이크로서비스의 다른 인스턴스간에 균등하게 분배하도록 도와준다.</p><h2><span id="ribbon-구성">Ribbon 구성</span></h2><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/ribbon.png" alt=""></p><p>스프링 클라우드 넷플릭스 립본은 마이크로서비스의 다른 인스턴스 간에 라운드 로빈 실행을 사용해 <strong>클라이언트-사이드 로드 밸런싱을 제공한다.</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-netflix-ribbon'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>필요한 의존성을 추가 합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"microservice-a"</span>)</span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"microservice-a"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomServiceProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/random"</span>)</span><br><span class="line">  <span class="function">List&lt;Integer&gt; <span class="title">getRandomNumbers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기존에 작성했던 RandomServiceProxy 인터페이스를 위와 같이 작성합니다. <code>FeignClient</code>도 서비스 네임만 기술합니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">microservice-a:</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    listOfServers:</span> <span class="attr">http://localhost:8080,http://localhost:8081</span></span><br></pre></td></tr></table></figure><p><code>microservice-a</code>의 서비스 url을 입력합니다.</p><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/ribbon-result.png" alt=""></p><p>GET <a href="http://127.0.0.1:8100/add%EC%9D%84" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:8100/add을</a> 호추랗면 아래와 같은 결과값을 응답 받습니다.</p><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/ribbon-result2.png" alt=""></p><p>라운드 로빈 방식으로 random API 호출이 <a href="http://localhost:8080" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080</a>, http://localhost:8081으로 분산되어 호출됩니다.</p><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/msa-simple.png" alt=""></p><p>위과 같은 아키텍처 구성을 가지게 됩니다.</p><h1><span id="선언적-rest-클라이언트-feign">선언적 Rest 클라이언트 - Feign</span></h1><p>페인은 최소한의 구성과 코드로, REST 서비스를 위한 REST 클라이언트를 쉽게 작성할 수 있습니다. 간단한 인터페이스로, 적절한 어노테이션을 사용하는 것이 특징입니다.</p><p>페인은 립본 및 유레카와 통합하여 사용하면 더욱 효율성이 높아지게 됩니다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'org.springframework.cloud:spring-cloud-starter-openfeign'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>필요한 의존성을 추가합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"micoservice-a"</span>, url = <span class="string">"localhost:8080"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomServiceProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/random"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRandomNumbers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>서비스의 이름과 URL을 하드코딩 합니다. (유레카를 통해서 하드코딩된 부분을 제거할 수 있습니다.)</li><li>Controller 코드를 작성하듯이 작성합니다.</li><li>중요한 것은 이것은 인터페이스이며, 적절한 어노테이션 기반으로 동작한다는 것입니다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberAddController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RandomServiceProxy randomServiceProxy;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Integer&gt; numbers = randomServiceProxy.getRandomNumbers();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> sum = numbers.stream().mapToInt(number -&gt; number).asLongStream().sum();</span><br><span class="line">    log.warn(<span class="string">"returning "</span> + sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RandomServiceProxy 의존성을 받아 사용합니다.</li></ul><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/fegin-result.png" alt=""><br>Feign 응답값을 확인할 수 있습니다.</p><h1><span id="api-게이트웨이">API 게이트웨이</span></h1><h2><span id="마이크로-서비스의-문제점">마이크로 서비스의 문제점</span></h2><ul><li>인증, 권한 부여 및 보안 : 모놀리식 서버에서는 인증 인가를 한 서버에서 책임지면 되는데 여러 서비스가 존재하는 마이크로서비스에서는 올바른 엑세스 보장을 어떻게할 것인가?</li><li>동적 라우팅은 어떻게 할 것인가?</li><li>내결합성: 하나의 마이크로서비스에서 오류가 발생해도 전체 시스템이 중단되지 않도록하면 어떻게 해야하는가 ?</li></ul><p>이러한 문제는 마이크로서비스가 서로 직접 대화할 때 개별 마이크로서비스에 의해 해결돼야한다. <strong>하지만 이런 아키텍처들은 위 우려들을 각 마이크로서비스가 다르게 처리할 수 있기 때문에 유지 관리가 어려울 수 있다.</strong></p><p>이려한 문제를 해결하기 가장 쉬운 것이 API 게이트웨이이다. 다음은 API 게이트가 제공하는 기능이다.</p><ul><li>인증 및 보안</li><li>속도 제한</li><li>모니터링</li><li>동적 라우팅 및 정적 응답 처리</li><li>로드 차단</li><li>여러 가지 서비스의 응답 집계</li></ul><h2><span id="주울로-클라이언트-사이드-로드-밸런싱-구현">주울로 클라이언트 - 사이드 로드 밸런싱 구현</span></h2><p>주을은 스프링 클라우드 넷플릭스 프로젝트의 일부다. 동적 라우팅, 모니터링, 필터링, 보안 등의 기능을 제공하는 API 게이트웨이 서비스다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&apos;</span><br><span class="line">    implementation &apos;org.springframework.cloud:spring-cloud-starter-netflix-zuul&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ApiGatewayApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"zuul-api-gateway"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8765</span></span><br></pre></td></tr></table></figure><p>필요한 의존성, 유레카 클라이언트, API 게이트웨이 등록을 진행한다.</p><p><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/api-gateway-eureka.png" alt=""><br>서버를 실행하면 유레카에 등록된 것을 확인 할 수있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleLoggingFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"pre"</span>; <span class="comment">// pre 사전 필터, route 원본으로 라우팅하기, post필터를 포스트라우팅, error 에러 처리</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 필터 우선순위</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 조건에 따른 필터 동작 여부, 해당 코드에서는 동작하기 위해서 true 리턴</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 필터에 대한 로직을 구현하는 방식, 아래 예제는 단순하게 로깅용</span></span><br><span class="line">    <span class="keyword">final</span> RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">    <span class="keyword">final</span> HttpServletRequest request = context.getRequest();</span><br><span class="line"></span><br><span class="line">    log.info(MessageFormat</span><br><span class="line">        .format(<span class="string">"Request Method : &#123;0&#125; \n URL : &#123;1&#125; "</span>, request.getMethod(),</span><br><span class="line">            request.getRequestURI()));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET http://127.0.0.1:8765/microservice-a/random</span><br><span class="line">Accept: application/json</span><br><span class="line"></span><br><span class="line">GET http://127.0.0.1:8765/service-consumer/add</span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure><p>service-name/url 을 호출할 경우 유레카에 등록되있는 서비스 정보를 기반으로 호출하게된다.<br><img src="https://github.com/cheese10yun/msa-study-sample/raw/master/static/api-gateway-eureka-result.png" alt=""></p><p><code>SimpleLoggingFilter</code> 잘 동작하는지 확인할 수 있다.</p><h2><span id="필터">필터</span></h2><ul><li>사전 필터: 주울에서 목표 대상에 대한 실제 요청이 발생하기 전에 호출된다. 일반적으로 사전 필터는 서비스의 일관된 메세지형식(HTTP 헤더의 포함여부)을 확이하는 작업을 수행하거나 서비스를 이용하는 사용자가 인증 및 인가되었는지 확인하는 게이이트키퍼 역할을 한다.</li><li>사후 필터: 대상 서비스를 호추랗고 응답을 클라이언트로 전송한 후 호출된다. 일반적으로 사후 필터는 대상 서비스의 응답을 로깅하거나 에러 처리, 민감정보에 대한 응답을 감시하는 목적으로 구현된다.</li><li>경로 필터: 대상 서비스가 호출되기 전에 호출을 가로체는 데 사용된다. 일반적으로 경로 필터는 일정 수준의 동적 라우팅 필요 여부를 결정하는 데 사용된다. 예를 들어 이 장 뒷부분에서 동일 서비스의 다른 두 버전을 라우팅할 수 있는 경로 단위 핉를 사용해 작은 호출 비율만 새 버전의 서비스로 라우팅할 수 있다.</li></ul><h3><span id="필터-적용-패턴">필터 적용 패턴</span></h3><ul><li>TrackingFilter: 주울에서 보내는 모든 요청에 연관된 상관관계 ID 여부를 확인하는 사전 필터다, 상관관계 ID는 고객 요청을 수행할 때 실행할 때 실행되는 모든 마이크로서비스에 전달되는 고유 ID이다. 상관관계 ID를 사용하면 특정 호출이 일련의 마이크로서비스를 통과할 때 발생하는 모든 이벤트 체인을 추적할 수 있다.</li><li>SpecialRoutesFilter: 유입되는 경로를 확인하고 해당 경로에 A/B 테스팅 수행 여부를 결정하는 주울의 경로 필터다.</li><li>ResponseFilter: 서비스 호출과 연관된 상관관계 ID를 클라이언트 회신하는 HTTP 응답 헤더에 삽입하는 사후 필터다. 일반적으로 클라이언트는 호출한 요청과 연관된 상관관계 ID에 엑세스할 수 있다.</li></ul><h2><span id="참고">참고</span></h2><ul><li><a href="http://acornpub.co.kr/book/mastering-spring-5.0" rel="external nofollow noopener noreferrer" target="_blank">스프링 5.0 마스터</a></li><li><a href="http://www.yes24.com/Product/Goods/67473377" rel="external nofollow noopener noreferrer" target="_blank">스프링 마이크로 서비스 코딩 공작소</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;spring-cloud-config&quot;&gt;Spring Cloud Config&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;스프링 클라우드 컨피그는 중앙 집중식 마이크로서비스 구성을 지원한다. 여기서 두 가지 중요한 구성 요소의 조합이다.&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://cheese10yun.github.io/tags/Spring/"/>
    
      <category term="Cloud" scheme="https://cheese10yun.github.io/tags/Cloud/"/>
    
  </entry>
  
  <entry>
    <title>인텔리제이 Github Code Review</title>
    <link href="https://cheese10yun.github.io/intellij-code-review/"/>
    <id>https://cheese10yun.github.io/intellij-code-review/</id>
    <published>2020-07-17T15:00:00.000Z</published>
    <updated>2020-07-18T13:47:48.454Z</updated>
    
    <content type="html"><![CDATA[<p>인텔리제이기반으로 Github 기반 Pull Request &amp; Code Review를 진행할 수 있습니다. 바로 기능을 살펴보겠습니다. 인텔리제이 기반 Pull Request는 <a href="https://cheese10yun.github.io/github-proejct/#pull-requestcode-review-1">Github로 프로젝트 관리하기 Part1</a>을 참고해 주세요</p><p><img src="https://raw.githubusercontent.com/cheese10yun/github-project-management/master/images//intellij-pr-3.png" alt=""></p><p><code>Actions</code>에서 <code>View Pullrequests</code>을 통해서 현재 PR을 확인할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/github-project-management/master/images//intellij-pr-4.png" alt=""></p><p><code>state:open</code>을 통해서 현재 open 상태이 PR 리스트를 확인할 수 있고 우측에는 코드 리뷰 대상 파일이 있고 <code>User.java</code> 파일을 클릭해서 Diff를 확인할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/github-project-management/master/images//intellij-pr-5.png" alt=""><br>해당 코드에 대해서 코멘트를 추가하고 싶은 경우 <code>+</code> 버튼을 클릭해서 코멘트를 달 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/github-project-management/master/images//intellij-pr-6.png" alt=""></p><p><img src="https://raw.githubusercontent.com/cheese10yun/github-project-management/master/images//intellij-pr-7.png" alt=""></p><p>이렇게 추가한 코멘트는 Github, Intellij에서도 확인할 수 있으며 코멘트에 대한 코멘트도 추가할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/github-project-management/master/images//intellij-pr-8.png" alt=""><br>또 인텔리제이에서 머지도 가능합니다. <code>Merge</code> 버튼을 눌러서 머지를 진행합니다. <a href="https://github.com/cheese10yun/github-project-management/pull/24" rel="external nofollow noopener noreferrer" target="_blank">인텔리제이 PR &amp; Code Review #24</a>는 실제 PR이 머지 된 것을 확인할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/github-project-management/master/images//intellij-pr-9.png" alt=""><br>위처럼 질이를 통해서 PR에 <code>status</code>, <code>author</code>, <code>assignee</code>을 기반으로 검색을 할 수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;인텔리제이기반으로 Github 기반 Pull Request &amp;amp; Code Review를 진행할 수 있습니다. 바로 기능을 살펴보겠습니다. 인텔리제이 기반 Pull Request는 &lt;a href=&quot;https://cheese10yun.githu
      
    
    </summary>
    
    
      <category term="IntelliJ" scheme="https://cheese10yun.github.io/tags/IntelliJ/"/>
    
      <category term="Code Review" scheme="https://cheese10yun.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Junit5</title>
    <link href="https://cheese10yun.github.io/junit5/"/>
    <id>https://cheese10yun.github.io/junit5/</id>
    <published>2020-06-16T12:45:50.000Z</published>
    <updated>2020-06-16T12:49:43.163Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="instance-특징">Instance 특징</span></h2><p>Junit5는 <strong>테스트 메서드마다 인스턴스를 새로 생성</strong>하는 것이 기본 전략입니다. 이는 테스트 코드(메서드) 간의 디펜던시 줄이기 위해서입니다. 아래 코드를 통해서 살펴보겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">Junit5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `value add 1`<span class="params">()</span></span> &#123;</span><br><span class="line">        value++</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"value : <span class="variable">$value</span>"</span>)</span><br><span class="line">        println(<span class="string">"Junit5 : <span class="variable">$this</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `value add 2`<span class="params">()</span></span> &#123;</span><br><span class="line">        value++</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"value : <span class="variable">$value</span>"</span>)</span><br><span class="line">        println(<span class="string">"Junit5 : <span class="variable">$this</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각가의 테스트 코드마다 <code>value</code>을 증가시키고 있습니다. <code>value add 1</code>, <code>value add 2</code> 두 메서드 중 한 메서드에서는 <code>value : 2</code>가 출력되어야 합니다. 하지만 출력 결과를 확인해 보면 모두 <code>value : 1</code>의 값이 출력되는 것을 확인할 수 있습니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/junit5-instance-1.png" alt=""></p><p>그 이유는 위에서 언급했듯이 Junit5는 테스트 메서드마다 인스턴스를 새로 생성하는 것이 기본 전략이기 때문에 <code>value</code> 값이 초기화되는 것입니다. <code>Junit5 : $this</code> 출력을 확인해보면 인스턴스 주솟값이 다른 것을 확인할 수 있습니다. 이렇게 되면 <code>value add 1</code>, <code>value add 2</code> 테스트 메서드 간에 디펜더시가 줄어들게 됩니다.</p><p>만약 테스트 메서드마다 해당 값을 공유해서 사용하고 싶으면 <code>companion object (static)</code>으로 변수를 지정하는 것입니다. 아레 코드처럼 변경하고 테스트 코드를 실행해보면 다음과 같은 결과를 확인할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">Junit5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private var value = 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/junit5-instance-2.png" alt=""></p><p><code>value : $value</code>의 출력을 확인해보면 해당 값이 증가된 것을 확인할 수 있습니다. 또 Junit5 인스턴스가 계속 생성되는 것을 방지하고 싶은 경우에는 <code>@TestInstance(TestInstance.Lifecycle.PER_CLASS)</code> 에노테이션을 사용하면 됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">Junit5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `value add 1`<span class="params">()</span></span> &#123;</span><br><span class="line">        value++</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"value : <span class="variable">$value</span>"</span>)</span><br><span class="line">        println(<span class="string">"Junit5 : <span class="variable">$this</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `value add 2`<span class="params">()</span></span> &#123;</span><br><span class="line">        value++</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"value : <span class="variable">$value</span>"</span>)</span><br><span class="line">        println(<span class="string">"Junit5 : <span class="variable">$this</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/junit5-instance-3.png" alt=""></p><p><code>Junit5</code> 주솟값을 보면 동일한 주솟값을 출력하는 것을 확인할 수 있습니다. 그 결과 <code>private var value</code> 변숫값이 테스트 메서드에서 공유되는 것을 확인할 수 있습니다. 물론 테스트 코드 간의 디펜더시를 줄이는 것이 올바른 테스트 방식이라고 생각합니다. <strong>하지만 테스트 메서드마다 인스턴스를 계속 생성하는 것이 효율적이지 않다고 생각합니다.</strong> 테스트 코드는 디펜던시 없이 작성하고, <code>@TestInstance(TestInstance.Lifecycle.PER_CLASS)</code>을 통해서 인스턴스를 계속 생성을 막는 것도 좋은 방법이라고 생각합니다.</p><h3><span id="전처리-후처리">전처리 후처리</span></h3><table><thead><tr><th>Annotation</th><th>Description</th></tr></thead><tbody><tr><td>@BeforeAll</td><td>테스트 실행되기 전 한번 실행됨</td></tr><tr><td>@BeforeEach</td><td>모든 테스트 마다 실행되기 전에실행됨</td></tr><tr><td>@AfterEach</td><td>모든 테스트 마다 실행된후 전에실행됨</td></tr><tr><td>@AfterAll</td><td>테스트 실행된 후 한 번 실행됨</td></tr></tbody></table><p>Junit5에서는 테스트 메서드 실행 시 전처리, 후처리를 위해서 위와 같은 어노테이션을 지원합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@BeforeAll</span></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"BeforeAll : 테스트 실행되기 이전 단 한 번만 실행"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@AfterAll</span></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"AfterAll : 테스트 실행 이후 단 한 번 실행됨"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeEach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"BeforeEach : 모든 테스트 마다 실행되기 이전 실행"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterEach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"AfterEach : 모든 테스트 마다 실행 이후 실행"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `test code1`<span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"test code run 1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `test code2`<span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"test code run 2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/junit5-instance-5.png" alt=""></p><p>테스트 결과를 보면 <code>@BeforeXXX</code>는 테스트 실행 이전 이후 1번 실행되고, <code>@BeforeXXX</code>는 테스트 메서드 실행 이전 이후 실행되는 것을 확인할 수 있습니다.</p><p>위에서 설명했듯이 테스트 메서드마다 인스턴스를 새로 생성하기 때문에 <code>@BeforeXXX</code>는 <code>companion object(static)</code>으로 처리하고 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"BeforeAll : 테스트 실행되기 이전 단 한 번만 실행"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"AfterAll : 테스트 실행 이후 단 한 번 실행됨"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 위처럼 설정하면 위와 같은 에러 메시지를 확인할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.junit.platform.commons.JUnitException: @BeforeAll method &apos;public final void com.example.querydsl.SampleTest.beforeAll$query_dsl()&apos; must be static unless the test class is annotated with @TestInstance(Lifecycle.PER_CLASS).</span><br></pre></td></tr></table></figure><p>아래 코드처럼 <code>TestInstance.Lifecycle.PER_CLASS</code>을 추가하면 테스트 코드가 잘 실행되는 것을 확인할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"BeforeAll : 테스트 실행되기 이전 단 한 번만 실행"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"AfterAll : 테스트 실행 이후 단 한 번 실행됨"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예제가 길었지만 전하고 싶은 것은 <strong>테스트 메서드마다 인스턴스를 새로 생성하는 것입니다.</strong></p><h2><span id="테스트-순서">테스트 순서</span></h2><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/junit5-instance-5.png" alt=""></p><p>Junit5에는 테스트 코드 실행 순서는 명확하게 정해져있지 않습니다.(정확히는 순서가 있지만 그것이 명시적으로 정해져있지는 않은 거 같습니다.) 물론 테스트 간의 디펜더시를 줄이기 위해서는 테스트 간의 순서가 없는 것이 더 바람직합니다.</p><p>하지만 특정 테스트에서는 순서를 명시해야 할 필요성도 있습니다. <code>@TestMethodOrder(MethodOrderer.OrderAnnotation::class)</code>을 사용하면 테스트 순서를 명시적으로 지정할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</span></span><br><span class="line"><span class="meta">@TestMethodOrder(MethodOrderer.OrderAnnotation::class)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"BeforeAll : 테스트 실행되기 이전 단 한 번만 실행"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"AfterAll : 테스트 실행 이후 단 한 번 실행됨"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeEach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"BeforeEach : 모든 테스트 마다 실행되기 이전 실행"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterEach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"AfterEach : 모든 테스트 마다 실행 이후 실행"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `test code1`<span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"test code run 1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Order(2)</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `test code2`<span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"test code run 2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/junit5-instance-6.png" alt=""></p><p><code>@Order()</code>을 사용하면 위와 같이 테스트 순서를 보장 받을 수 있습니다. <strong><code>value</code> 값이 낮을수록 테스트 코드 우선순위가 높습니다.</strong></p><h2><span id="정리">정리</span></h2><p><code>Junit5</code>에서는 테스트마다 새로운 인스턴스 생성, 테스트 간의 순서를 보장하지 않습니다. 그러한 이유는 이런 방식으로 테스트 코드를 작성하는 것이 더 좋은 방법이라 생각하여 가이드를 하는 거 같습니다. 이러한 부분을 명확하게 이해하고 위와 같은 방법을 사용하는 것이 좋을 거 같습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;instance-특징&quot;&gt;Instance 특징&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Junit5는 &lt;strong&gt;테스트 메서드마다 인스턴스를 새로 생성&lt;/strong&gt;하는 것이 기본 전략입니다. 이는 테스트 코드(메서드) 간의 디펜던시 줄
      
    
    </summary>
    
    
      <category term="test" scheme="https://cheese10yun.github.io/tags/test/"/>
    
      <category term="junit5" scheme="https://cheese10yun.github.io/tags/junit5/"/>
    
  </entry>
  
  <entry>
    <title>JPA + Querydsl group_concat 사용법</title>
    <link href="https://cheese10yun.github.io/jpa-query-dsl-group-concat/"/>
    <id>https://cheese10yun.github.io/jpa-query-dsl-group-concat/</id>
    <published>2020-06-13T06:11:42.000Z</published>
    <updated>2020-06-13T06:19:17.696Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/query-dsl" rel="external nofollow noopener noreferrer" target="_blank">Github</a>에서 확인할 수 있습니다.</p></blockquote><h1><span id="jpa-querydsl-group_concat-사용법">JPA + Querydsl group_concat 사용법</span></h1><p>Querydsl 기반으로 작업하다 보면 sql 함수가 필요한 경우가 있습니다. 대표적으로 sum(), max() 등이 있고 해당 함수는 Querydsl 자체에서 지원해 주고 있습니다. 하지만 <code>group_concat</code>과 같은 함수를 사용하기 위해서는 별도의 설정이 필요합니다. 본 포스팅의 내용은 Mysql 환경에서 JPA + Querydsl 조합에서 <code>group_concat</code>을 사용하는 방법을 정리한 것입니다.</p><p>Mysql 환경에서 <code>group_concat</code>을 사용하기 위해서 별다른 설정 없이 <code>Expressions.stringTemplate()</code> 함수를 이용해서 <code>group_concat</code>사용하는 경우 아래와 같은 에러가 발생합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: No pattern found for GROUP_CONCAT</span><br></pre></td></tr></table></figure><p><code>SQLExpressions.groupConcat</code>을 사용해서 <code>group_concat</code>을 사용하는 방법도 있지만 해당 설정은 의존성과, 설정이 조금 복잡하기 때문에 <code>Expressions.stringTemplate</code> 기반으로 <code>group_concat</code>을 사용하겠습니다.</p><h2><span id="설정-방법">설정 방법</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.querydsl.config</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlCustomDialect</span> : <span class="type">MySQL57Dialect</span></span>() &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        registerFunction(</span><br><span class="line">            <span class="string">"GROUP_CONCAT"</span>,</span><br><span class="line">            StandardSQLFunction(<span class="string">"group_concat"</span>, StandardBasicTypes.STRING)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MySQL57Dialect</code>을 상속받는 커스텀한 <code>Dialect</code>클래스를 작성하고 <code>registerFunction()</code>메서드를 통해서 <code>group_concat</code> SQL Function을 등록합니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    database-platform:</span> <span class="string">com.example.querydsl.config.MysqlCustomDialect</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure><p><code>application.myl</code> or <code>application.properties</code> 설정에서 위에서 작성한 <code>MysqlCustomDialect</code> 패키지 경로를 입력합니다.</p><h2><span id="테스트">테스트</span></h2><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/group_concat_erd.png" alt=""></p><ul><li>위와 같은 관계에서 테스트를 진행하겠습니다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberGroupConcat</span> <span class="meta">@QueryProjection</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">val</span> usernameGroupConcat: String,</span><br><span class="line">    <span class="keyword">val</span> ageGroupConcat: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@ActiveProfiles(<span class="meta-string">"mysql"</span>)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupConcatTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> em: EntityManager</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `group concat test`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">val</span> teamA = Team(<span class="string">"teamA"</span>)</span><br><span class="line">        em.persist(teamA)</span><br><span class="line"></span><br><span class="line">        (<span class="number">1.</span><span class="number">.20</span>).map &#123;</span><br><span class="line">            em.persist(Member(username = <span class="string">"member-<span class="variable">$it</span>"</span>, age = it, team = teamA))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="keyword">val</span> members =</span><br><span class="line">            query</span><br><span class="line">                .select(QMemberGroupConcat(</span><br><span class="line">                    Expressions.stringTemplate(<span class="string">"group_concat(&#123;0&#125;)"</span>, qMember.username),</span><br><span class="line">                    Expressions.stringTemplate(<span class="string">"group_concat(&#123;0&#125;)"</span>, qMember.age)</span><br><span class="line">                ))</span><br><span class="line">                .from(qMember)</span><br><span class="line">                .groupBy(qMember.team)</span><br><span class="line">                .fetch()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">            println(member) <span class="comment">// MemberGroupConcat(usernameGroupConcat=member-1,member-2,member-3,member-4,member-5,member-6,member-7,member-8,member-9,member-10,member-11,member-12,member-13,member-14,member-15,member-16,member-17,member-18,member-19,member-20, ageGroupConcat=1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>teamA</code>를 하나 생성하고 <code>member-1</code> ~ <code>member-20</code>까지 <code>member</code>를 생성하고 <code>teamA</code>에 연결합니다. 리턴 받는 객체는 <code>MemberGroupConcat</code>으로 받게 설정합니다. <code>Projection</code>을 하는 여러 가지 방법이 있지만 <code>@QueryProjection</code>을 이용한 방법을 선호합니다. 해당 포스팅은 <a href="https://cheese10yun.github.io/querydsl-projections/">Querydsl Projection 방법 소개 및 선호하는 패턴 정리</a>에서 정리한 적 있습니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/group_concat_sql.png" alt=""></p><p>의도한 것처럼 <code>group_concat</code>이 잘 동작하는 것을 확인할 수 있습니다.</p><h2><span id="주의점">주의점</span></h2><p><code>group_concat</code>사용할 때 max length를 주의해서 사용해야 합니다. <code>group_concat</code> max length size가 있고 그것을 넘어가면 문자열을 더 가져오지 않습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `group concat max length size`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    <span class="keyword">val</span> teamA = Team(<span class="string">"teamA"</span>)</span><br><span class="line">    em.persist(teamA)</span><br><span class="line"></span><br><span class="line">    (<span class="number">1.</span><span class="number">.1000</span>).map &#123;</span><br><span class="line">        em.persist(Member(username = <span class="string">"member-<span class="variable">$it</span>"</span>, age = it, team = teamA))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    <span class="keyword">val</span> members =</span><br><span class="line">        query</span><br><span class="line">            .select(QMemberGroupConcat(</span><br><span class="line">                Expressions.stringTemplate(<span class="string">"group_concat(&#123;0&#125;)"</span>, qMember.username),</span><br><span class="line">                Expressions.stringTemplate(<span class="string">"group_concat(&#123;0&#125;)"</span>, qMember.age)</span><br><span class="line">            ))</span><br><span class="line">            .from(qMember)</span><br><span class="line">            .groupBy(qMember.team)</span><br><span class="line">            .fetch()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">        println(member) <span class="comment">// MemberGroupConcat(usernameGroupConcat=member-1,member-2,member-3,...member-101,member-102,member-103, ageGroupConcat=1,2,3,,281,282,283,)</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>member를 1000개 저장하고 <code>group_concat</code>을 사용해서 <code>print()</code>을 하면 전체 결과가 나오지 않고 일정 length에서 잘리는 것을 알 수 있습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'group_concat_max_len'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/group_concat_max_length.png" alt=""></p><p>위 명령어로 <code>group_concat</code> max length를 확인할 수 있습니다. 물론 해당 max length를 늘려서 사용할 수 있습니다.</p><h2><span id="정리">정리</span></h2><p><code>group_concat</code>을 사용하는 방법을 정리하긴 했지만 가능하면 사용하는 것을 권장하지 않습니다. JPA 연관관계를 통해서 가져오는 것이 더 선호하며 <code>group_concat</code> 정도는 괜찮지만 SQL에 함수에 너무 의존적인 코드를 작성하는 것은 지양하는 것이 좋다고 생각합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/query-dsl&quot; rel=&quot;external nofollow noopener noreferrer
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Querydsl" scheme="https://cheese10yun.github.io/tags/Querydsl/"/>
    
      <category term="group_concat" scheme="https://cheese10yun.github.io/tags/group-concat/"/>
    
  </entry>
  
  <entry>
    <title>Visual VM Launcher IntelliJ</title>
    <link href="https://cheese10yun.github.io/intellij-visual-vm/"/>
    <id>https://cheese10yun.github.io/intellij-visual-vm/</id>
    <published>2020-05-29T15:00:00.000Z</published>
    <updated>2020-05-29T16:40:00.301Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/VisualVM%20Launcher-6.png?raw=true" alt=""></p><p><code>VisualVM</code>을 사용하면 JVM의  Memory, CPU, Thread의 상태를 쉽게 확인할 수 있습니다. <code>IntelliJ</code> 플러그인을 설치하면 보다 쉽게 사용이가능 합니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/VisualVM%20Launcher-2.png?raw=true" alt=""></p><p><a href="https://visualvm.github.io/download.html" rel="external nofollow noopener noreferrer" target="_blank">https://visualvm.github.io/download.html</a> 다운로드 받고 압축을 해제 합니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/VisualVM%20Launcher-3.png?raw=true" alt=""></p><p>압축 해제이후, <code>visualvm</code> 파일은 이후 설정에 필요하기 때문에 별도의 <code>path</code>에 보관하시면 됩니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/VisualVM%20Launcher-1.png?raw=true" alt=""></p><p><code>IntelliJ -&gt; Plugin -&gt; VisualVM Launcher</code> 검색해서 설치를 진행합니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/VisualVM%20Launcher-4.png?raw=true" alt=""></p><p>설치가 완료되면 <code>Preferences -&gt; Other Settings -&gt; VisualVM Launcher</code> 설정으로 이동 이후 <code>VisualVM executable</code> -&gt; <code>visualvm</code> 위에서 다운받은 <code>path</code>를 지정합니다. <code>JDK home</code> -&gt; <code>JDK home path</code>를 지정합니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/VisualVM%20Launcher-5.png?raw=true" alt=""></p><p>위설정을 완료한 이후 <code>Run -&gt; RunWithVisualVM or DebugVisualVM</code>으로 실행합니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/VisualVM%20Launcher-6.png?raw=true" alt=""></p><p>위 설정이 모두 정상적으로 완료되었으면 <code>VisualVM</code> 실행이 되는 것을 확인할 수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://github.com/cheese10yun/TIL/blob/master/assets/VisualVM%20Launcher-6.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;VisualVM&lt;/code&gt;을
      
    
    </summary>
    
    
      <category term="VisualVM Launcher" scheme="https://cheese10yun.github.io/tags/VisualVM-Launcher/"/>
    
  </entry>
  
  <entry>
    <title>Github Action With Gradle</title>
    <link href="https://cheese10yun.github.io/github-action-1/"/>
    <id>https://cheese10yun.github.io/github-action-1/</id>
    <published>2020-05-12T15:00:00.000Z</published>
    <updated>2020-05-13T17:37:44.653Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 코드는 <a href="https://github.com/cheese10yun/github-action" rel="external nofollow noopener noreferrer" target="_blank">Github</a>에서 확인할 수 있습니다.</p></blockquote><h2><span id="github-action">Github Action</span></h2><p>Github Action을 통해서 깃허브 자체적으로 CI &amp; CD를 진행할 수 있습니다. Github에대한 자세한 설명은 <a href="https://github.com/features/actions" rel="external nofollow noopener noreferrer" target="_blank">공식홈페이지</a>를 참고 해주세요. 본 포스팅에서는 Spring Boot &amp; Gradle 환경에서 간단한 빌드를 다룰 예정입니다.</p><h2><span id="github-action-만들기">Github Action 만들기</span></h2><p>Github Repository 상단에 <code>Actions</code>을 클릭 합니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/github-action/master/images/github-action-1.png" alt=""></p><p>Java With Gradle Action의 <code>Set up this workflow</code> 버튼을 클릭합니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/github-action/master/images/github-action-2.png" alt=""></p><p><code>Java With Gradle Action</code>의 YML을 생성합니다.</p><h3><span id="gradleyml">gradle.yml</span></h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Java</span> <span class="string">CI</span> <span class="string">with</span> <span class="string">Gradle</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"><span class="attr">  push:</span></span><br><span class="line"><span class="attr">    branches:</span> <span class="string">[</span> <span class="string">master</span> <span class="string">]</span></span><br><span class="line"><span class="attr">  pull_request:</span></span><br><span class="line"><span class="attr">    branches:</span> <span class="string">[</span> <span class="string">master</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="attr">  build:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    steps:</span></span><br><span class="line"><span class="attr">    - uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">1.8</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">actions/setup-java@v1</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        java-version:</span> <span class="number">1.8</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Grant</span> <span class="string">execute</span> <span class="string">permission</span> <span class="string">for</span> <span class="string">gradlew</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">gradlew</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Gradle</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">./gradlew</span> <span class="string">build</span></span><br></pre></td></tr></table></figure><p><code>on.push</code>, <code>on.pull_request</code>을 보면 <code>master</code> branch에 <code>push</code>, <code>pull_request</code> 이벤트가 발생하는 경우 해당 <code>jobs</code>가 실행됩니다. <code>build</code>에서는 JDK 설정, Gradle 설정을 진행하고 최종적으로 <code>./gradlew build</code> 진행합니다.</p><h3><span id="action-workflows">Action Workflows</span></h3><p><img src="https://raw.githubusercontent.com/cheese10yun/github-action/master/images/github-action-3.png" alt=""></p><p><code>master</code>에 <code>push</code>, <code>pull_request</code> 이벤트가 발생할 경우 해당 Github Action이 동작하게 됩니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/github-action/master/images/github-action-4.png" alt=""></p><p>Event를 클릭하면 상세 Github Actuon에 대한 내용을 살펴볼 수 있습니다.</p><h3><span id="badge">Badge</span></h3><p><img src="https://raw.githubusercontent.com/cheese10yun/github-action/master/images/github-action-5.png" alt=""></p><p>오른쪽 상단에 <code>Create status badge</code> 버튼을 클릭해서 Badge를 Markdown Copy를 진행할 수 있습니다. <img src="https://github.com/cheese10yun/github-action/workflows/Java%20CI%20with%20Gradle/badge.svg?branch=master" alt="Java CI with Gradle"></p><h2><span id="schedule-with-spring-batch">Schedule With Spring Batch</span></h2><p>Github Action은 <code>schedule</code> 기능을 제공하고 있습니다. Spring Batch를 이용하여 간단한 schedule Job을 작성해보겠습니다.</p><h3><span id="schedule-github-action-생성">Schedule Github action 생성</span></h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># simple-job.yml</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Simple</span> <span class="string">Job</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"><span class="attr">  schedule:</span></span><br><span class="line"><span class="attr">    - cron:</span> <span class="string">'*/5 * * * *'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="attr">  build:</span></span><br><span class="line"><span class="attr">    runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"><span class="attr">    steps:</span></span><br><span class="line"><span class="attr">      - uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">1.8</span></span><br><span class="line"><span class="attr">        uses:</span> <span class="string">actions/setup-java@v1</span></span><br><span class="line"><span class="attr">        with:</span></span><br><span class="line"><span class="attr">          java-version:</span> <span class="number">1.8</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Grant</span> <span class="string">execute</span> <span class="string">permission</span> <span class="string">for</span> <span class="string">gradlew</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">gradlew</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Gradle</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">./gradlew</span> <span class="string">build</span> <span class="bullet">-x</span> <span class="string">test</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Commpany</span> <span class="string">Save</span> <span class="string">Job</span> <span class="string">Execute</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">java</span> <span class="bullet">-jar</span> <span class="bullet">-Dspring.batch.job.names=simpleJob</span> <span class="string">./build/libs/action-0.0.1-SNAPSHOT.jar</span></span><br></pre></td></tr></table></figure><p>위에서 생성한 <code>gradle.yml</code>을 기반으로 schedule Gtihub Action을 위한 <code>simple-job.yml</code>을 생성합니다. <code>cron: '*/5 * * * *'</code> 해당 설정으로 5분마다 스케줄을 지정합니다.</p><h3><span id="batch-code">Batch Code</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleJobConfig</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> jobBuilderFactory: JobBuilderFactory,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> stepBuilderFactory: StepBuilderFactory</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">simpleJob</span><span class="params">()</span></span>: Job &#123;</span><br><span class="line">        <span class="keyword">return</span> jobBuilderFactory.<span class="keyword">get</span>(<span class="string">"simpleJob"</span>)</span><br><span class="line">            .incrementer(RunIdIncrementer())</span><br><span class="line">            .start(simpleStep())</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">simpleStep</span><span class="params">()</span></span>: Step &#123;</span><br><span class="line">        <span class="keyword">return</span> stepBuilderFactory.<span class="keyword">get</span>(<span class="string">"simpleStep1"</span>)</span><br><span class="line">            .tasklet &#123; _, _ -&gt;</span><br><span class="line"></span><br><span class="line">                Unirest.post(<span class="string">"https://hooks.slack.com/services/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"</span>)</span><br><span class="line">                    .header(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">                    .body(<span class="string">"""</span></span><br><span class="line"><span class="string">                        &#123;</span></span><br><span class="line"><span class="string">                            "text": "<span class="subst">$&#123;LocalDateTime.now()&#125;</span>"</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    """</span>.trimIndent())</span><br><span class="line">                    .asString()</span><br><span class="line"></span><br><span class="line">                RepeatStatus.FINISHED</span><br><span class="line">            &#125;</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Slack 으로 현재 시간을 보내는 메시지를 전송하는 Job입니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/github-action/master/images/simple-github.png" alt=""></p><p>Simple Job Action에 대한 스케줄을 확인할 수 있습니다. 이처럼 schedule 기능을 이용하면 간단하게 Schedule Batch Job을 구성할 수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/github-action&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Gi
      
    
    </summary>
    
    
      <category term="Github" scheme="https://cheese10yun.github.io/tags/Github/"/>
    
      <category term="Action" scheme="https://cheese10yun.github.io/tags/Action/"/>
    
  </entry>
  
  <entry>
    <title>외부 인프라스트럭처 테스트</title>
    <link href="https://cheese10yun.github.io/spring-mock-test/"/>
    <id>https://cheese10yun.github.io/spring-mock-test/</id>
    <published>2020-03-28T15:00:00.000Z</published>
    <updated>2020-03-29T12:13:52.340Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/spring-mock-test" rel="external nofollow noopener noreferrer" target="_blank">Github</a>에서 확인할 수 있습니다.</p></blockquote><p>대부분의 애플리케이션은 외부 인프라스트럭처와 통신하면서 진행됩니다. 대표적인 외부 스트럭처는 외부 API들이 있습니다. 이런 외부 인프라스트럭처는 Mocking 해서 원하는 응답 값을 지정하고 검증하고 싶은 부분을 검증을 진행하는 것이 흔한 패턴입니다.</p><p>대표적으로 Mockito 프레임워크가 있으며 Mock 테스트는  <a href="https://github.com/cheese10yun/spring-guide/blob/master/docs/test-guide.md#mocktest" rel="external nofollow noopener noreferrer" target="_blank">Spring Guide - 테스트 전략 : Service 테스트</a>, <a href="https://cheese10yun.github.io/rest-template-mock-test/">RestTemplate Mock 기반 테스트 하기</a>에서 포스팅한 적 있습니다. 그런데 이런 식의 Mock 테스트 코드는 문제없지만, 실제 구동 환경(Local, Sandbox, Beta)에서는 문제가 있을 수 있습니다.</p><h2><span id="요구사항">요구사항</span></h2><ul><li>파트너 등록을 진행한다.</li><li>파트너 등록 시 계좌 주명, 계좌번호 일치 여부를 검증한다.<ul><li>계좌 주명 검증은 신한 API를 사용한다.<ul><li>API는 허가된 서버만 호출할 수 있다.</li><li>API Call 1건당 비용이 발생한다.</li></ul></li><li>계좌 주명, 계좌번호 일치하는 경우 저장한다.</li><li>계좌 주명, 계좌번호 일치하지 않은 경우 예외를 발생시킨다.</li></ul></li></ul><h2><span id="code">Code</span></h2><p>코드는 자세히 보실 필요 없습니다. 아래의 흐름만 읽어 보시면 됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/partners"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartnerApi</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> partnerRegistrationService: PartnerRegistrationService</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> dto: <span class="type">PartnerRegistrationRequest</span>)</span></span> &#123;</span><br><span class="line">        partnerRegistrationService.register(dto)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">PartnerRegistrationRequest</span></span>(</span><br><span class="line">    <span class="meta">@field:NotEmpty</span></span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="meta">@field:NotEmpty</span></span><br><span class="line">    <span class="keyword">val</span> accountHolder: String,</span><br><span class="line">    <span class="meta">@field:NotEmpty</span></span><br><span class="line">    <span class="keyword">val</span> accountNumber: String</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartnerRegistrationService</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> partnerRepository: PartnerRepository,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bankClient: ShinhanBankClient</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">(dto: <span class="type">PartnerRegistrationRequest</span>)</span></span>: Partner &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 은행 코드 검증일 진행한다</span></span><br><span class="line">        bankClient.verifyAccountHolder(</span><br><span class="line">            accountHolder = dto.accountHolder,</span><br><span class="line">            accountNumber = dto.accountHolder</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> partnerRepository.save(Partner(</span><br><span class="line">            accountNumber = dto.accountNumber,</span><br><span class="line">            accountHolder = dto.accountHolder,</span><br><span class="line">            name = dto.name</span><br><span class="line">        ))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShinhanBankClient</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> shinChanBankApi: ShinChanBankApi</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 계좌주명, 계좝번호가 일치하지 않으면 예외 발생</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">verifyAccountHolder</span><span class="params">(accountNumber: <span class="type">String</span>, accountHolder: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> response = shinChanBankApi.checkAccountHolder(accountHolder, accountNumber)</span><br><span class="line">        require(!response.matched.not()) &#123; <span class="string">"계좌주명이 일치하지 않습니다."</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShinChanBankApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 계좌주명, 계좌번호가 하드 코딩된 값과 일치여불르 확인한다.</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">checkAccountHolder</span><span class="params">(accountHolder: <span class="type">String</span>, accountNumber: <span class="type">String</span>)</span></span>: AccountHolderVerificationResponse &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">            accountHolder == <span class="string">"yun"</span> &amp;&amp; accountNumber == <span class="string">"110-2222-2222"</span> -&gt; AccountHolderVerificationResponse(<span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">else</span> -&gt; AccountHolderVerificationResponse(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountHolderVerificationResponse</span></span>(</span><br><span class="line">    <span class="keyword">val</span> matched: <span class="built_in">Boolean</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>예제 코드가 길지만 흐름은 간단합니다. 파트너 등록을 진행할 때 ShinhanBankClient를 통해서 계좌 주명 일치 여부를 검증하고, 일치하지 않은 경우 예외가 발생시켜 파트너 등록을 진행하지 않습니다.</p><p>본 포스팅과는 관련 없는 내용이지만 실제 API Call은 <code>ShinChanBankApi</code> 클래스에서 진행하고, 일치하지 않은 경우 예외가 발생하는 비즈니스 코드는 <code>ShinhanBankClient</code> 클래스에서 진행합니다.</p><p><strong>단순하게 API 통신만 담당하는 객체, API 통신을 담당하는 객체를 이용해서 비즈니스 코드를 만드는 객체</strong> 이렇게 객체의 책임과 역할을 명확하게 나누고 그 크기를 작게 유지하는 것이 좋은 설계 좋은 코드라고 생각합니다.</p><h3><span id="test-code">Test Code</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">PartnerApiTest</span> : <span class="type">SpringApiTestSupport</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> shinChanBankApi: ShinChanBankApi</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `파트너 등록`<span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        given(shinChanBankApi.checkAccountHolder(anyString(), anyString()))</span><br><span class="line">            .willReturn(AccountHolderVerificationResponse(<span class="literal">true</span>))</span><br><span class="line"></span><br><span class="line">        mockMvc.post(<span class="string">"/partners"</span>) &#123;</span><br><span class="line">            contentType = MediaType.APPLICATION_JSON</span><br><span class="line">            content = <span class="string">"""</span></span><br><span class="line"><span class="string">                &#123;</span></span><br><span class="line"><span class="string">                  "name" : "123",</span></span><br><span class="line"><span class="string">                  "accountHolder" : "123",</span></span><br><span class="line"><span class="string">                  "accountNumber" :  "123"</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            """</span>.trimIndent()</span><br><span class="line">        &#125;.andExpect &#123;</span><br><span class="line">            status &#123; isOk &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MockBean을 통해서 가짜 객체를 주입받고 <code>given()</code> 메서드를 통해서 일치한다는 가정을 하고 테스트를 진행하게 됩니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/spring-mock-test/image/partenr-test-code.png" alt=""></p><p>해당 테스트는 잘 진행되는 것을 볼 수 있습니다.</p><h2><span id="하지만-문제는">하지만 문제는 ?</span></h2><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/spring-mock-test/image/api-result.png" alt=""></p><p><strong>하지만 문제가 있습니다. 실제 구동 환경(Local, Sandbox, Beta…)에서는 해당 API Call을 진행하면 예외가 발생합니다.</strong></p><p>허가된 Production 서버 이외의 조건들은 호출은 가능하지만 API 비용 발생 문제 등이 있어 Production 이외의 환경에서는 막는 것이 적절할 수 있습니다. 그 밖에 다양한 이유들이 있습니다.</p><ul><li>실제 Email을 호출하는 경우</li><li>실제 SMS으로 문자가 나가는 경우</li><li>실제 송금을 진행하는 경우</li><li>상대 서버에 sandbox, beta 등 production 환경 이외의 테스트 서버가 없는 경우</li></ul><p>해당 이유들은 비용상의 문제, 서버 권한 문제 외 적으로 막아야 합니다. <strong>그리고 무엇보다 Production 환경 외에서 해당 API를 사용(테스트) 할 수 없게 되는 것이 가장 큰 문제입니다.</strong></p><h2><span id="해결-방법">해결 방법</span></h2><p><img src="https://raw.githubusercontent.com/cheese10yun/TIL/bc6ee987d4073d59ec884210215ba1fc9307c0de/assets/partner-ocp.png" alt=""></p><p>해결 방법은 간단합니다. ShinhanBankClient가 ShinhanBankApi 인터페이스를 의존하게 함으로써 <strong>의존관계를 인터페이스를 통해서 역전시키는 것입니다.</strong> 이것도 <a href="https://github.com/cheese10yun/spring-SOLID/blob/master/docs/OCP.md" rel="external nofollow noopener noreferrer" target="_blank">개방 폐쇄의 원칙: Open Close Principle</a>에서 포스팅한 적 이 있습니다.</p><h3><span id="code">Code</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ShinChanBankApi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">checkAccountHolder</span><span class="params">(accountHolder: <span class="type">String</span>, accountNumber: <span class="type">String</span>)</span></span>: AccountHolderVerificationResponse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(<span class="meta-string">"shinChanBankApi"</span>)</span></span><br><span class="line"><span class="meta">@Profile(<span class="meta-string">"production"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShinChanBankApiImpl</span> : <span class="type">ShinChanBankApi &#123;</span></span></span><br><span class="line">    <span class="comment">// 계좌주명, 계좌번호가 하드 코딩된 값과 일치여불르 확인한다.</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkAccountHolder</span><span class="params">(accountHolder: <span class="type">String</span>, accountNumber: <span class="type">String</span>)</span></span>: AccountHolderVerificationResponse &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">            accountHolder == <span class="string">"yun"</span> &amp;&amp; accountNumber == <span class="string">"110-2222-2222"</span> -&gt; AccountHolderVerificationResponse(<span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">else</span> -&gt; AccountHolderVerificationResponse(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(<span class="meta-string">"shinChanBankApi"</span>)</span></span><br><span class="line"><span class="meta">@Profile(<span class="meta-string">"sandbox"</span>, <span class="meta-string">"beta"</span>, <span class="meta-string">"local"</span>, <span class="meta-string">"test"</span>)</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ShinChanBankApMock</span> : <span class="type">ShinChanBankApi &#123;</span></span></span><br><span class="line">    <span class="comment">// 어떤 값이 들어 와도 일치 한다고 가정한다</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkAccountHolder</span><span class="params">(accountHolder: <span class="type">String</span>, accountNumber: <span class="type">String</span>)</span></span>: AccountHolderVerificationResponse &#123;</span><br><span class="line">        <span class="keyword">return</span> AccountHolderVerificationResponse(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartnerRegistrationService</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> partnerRepository: PartnerRepository,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bankClient: ShinhanBankClient</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">(dto: <span class="type">PartnerRegistrationRequest</span>)</span></span>: Partner &#123;</span><br><span class="line">        <span class="comment">// 은행 코드 검증일 진행한다</span></span><br><span class="line">        bankClient.verifyAccountHolder(</span><br><span class="line">            accountHolder = dto.accountHolder,</span><br><span class="line">            accountNumber = dto.accountHolder</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> partnerRepository.save(Partner(</span><br><span class="line">            accountNumber = dto.accountNumber,</span><br><span class="line">            accountHolder = dto.accountHolder,</span><br><span class="line">            name = dto.name</span><br><span class="line">        ))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Service(&quot;beanName&quot;)</code> beanName을 지정합니다.</li><li><code>@Profile</code> 어노테이션을 통해서 각 환경에 맞는 bean이 등록되게 진행합니다.</li><li><strong><code>PartnerRegistrationService</code>에서 <code>ShinChanBankApi</code> 인터페이스를 의존하게 합니다.</strong></li></ul><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/spring-mock-test/image/bean-error.png" alt=""><br><code>@Profile</code> 잘못 설정해서 Bean이 2개 등록되는 경우 스프링에서 예외를 발생시키며 Bean 하나도 등록 못하는 경우에도 마찬가지로 예외가 발생합니다.</p><p>스프링에서 Bean 관련 예외를 명확하게 표시해 주고 있지만 그래도 불안하다고 판단되면 Bean 등록하는 코드를 따로 작성해도 좋습니다.</p><h3><span id="test">Test</span></h3><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/spring-mock-test/image/result.png" alt=""></p><p><code>spring.profiles.active=local</code> 으로 지정하고 해당 API를 호출하면 <code>Status 200</code>을 응답받은 것을 확인할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/spring-mock-test/image/bean-.png" alt=""></p><p><code>spring.profiles.active=local</code>환경에서는 <code>shinhanBankApi</code>객체에 <code>ShinhanBankApiMock</code>이 등록된것을 확인할 수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/spring-mock-test&quot; rel=&quot;external nofollow noopener nor
      
    
    </summary>
    
    
      <category term="Test" scheme="https://cheese10yun.github.io/tags/Test/"/>
    
      <category term="Mock" scheme="https://cheese10yun.github.io/tags/Mock/"/>
    
  </entry>
  
  <entry>
    <title>JPA 기반 테스트 코드 작성 팁</title>
    <link href="https://cheese10yun.github.io/jpa-test-support/"/>
    <id>https://cheese10yun.github.io/jpa-test-support/</id>
    <published>2020-02-29T15:00:00.000Z</published>
    <updated>2020-03-04T13:45:40.135Z</updated>
    
    <content type="html"><![CDATA[<p>JPA 기반으로 테스트 코드를 작성하면서 불편했던 부분을 소개하고 해결 방법에 관한 포스팅입니다.</p><h2><span id="jpa-기반-테스트-불편한-점">JPA 기반 테스트 불편한 점</span></h2><h3><span id="과도한-dependency">과도한 Dependency</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paymentRepository: PaymentRepository,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> memberRepository: MemberRepository,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> orderRepository: OrderRepository</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `특정 테스트를 하기위해서는 외부 dependency가 필요하다`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 특정 테스트를 하기 위해서 많은 디펜던시가 필요하다.</span></span><br><span class="line">        paymentRepository.save(Payment(BigDecimal.TEN))</span><br><span class="line">        memberRepository.save(Member(<span class="string">"username"</span>, <span class="number">10</span>, Team(<span class="string">"team-name"</span>)))</span><br><span class="line">        orderRepository.save(Order(BigDecimal.TEN))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>많은 디펜던시가 필요한 부분의 테스트 코드를 작성할 때는 많은 Repository를 주입 받아서 테스트를 진헹 해야합니다. 위 코드처럼 특정 구간의 서비스를 테스트하기 위해서는 <code>Given</code>절을 작성할 때 흔하게 발생합니다.</p><p>물론 테스트 코드이기 때문에 DI 받아야하는 항목들이 많아지는것이 상대적으로 문제가 크게 발생하지는 않지만 코드 양이 많이 발생하는 문제가 있습니다.</p><h3><span id="검증이-필요한데">검증이 필요한데 ?..</span></h3><p>무엇보다 큰 문제가 해당 테스트의 <code>Then</code>절에 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `특정 테스트를 하기위해서는 외부 dependency가 필요하다`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 특정 테스트를 하기 위해서 많은 디펜던시가 필요하다.</span></span><br><span class="line">    paymentRepository.save(Payment(BigDecimal.TEN))</span><br><span class="line">    memberRepository.save(Member(<span class="string">"username"</span>, <span class="number">10</span>, Team(<span class="string">"team-name"</span>)))</span><br><span class="line">    orderRepository.save(Order(BigDecimal.TEN))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 특정 서비스가 여러 entity rows를 변경할때 아래와 같은 조회로 Then 이어가야 합니다.</span></span><br><span class="line">    <span class="comment">// paymentRepository.findBy... epository 메서드는 없는데??...</span></span><br><span class="line">    <span class="comment">// memberRepository.findBy...</span></span><br><span class="line">    <span class="comment">// orderRepository.findBy...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당 서비스의 코드가 여러 enttiy의 여러 row의 변경을 가할 때 <code>Then</code>절에서 검증을 진행할 때 문제가 발생합니다. 해당 조회 코드가 없는 경우 <strong>오직 테스트를 위해서만 조회용 코드를 일반 코드에 작성해야 합니다.</strong> 그렇지 않다면 <strong>Test Scope에서 사용할 Repository를 따로 작성해야 합니다.</strong></p><p>두 방식 모두 좋은 해결 방법이 아니라고 생각합니다.</p><h2><span id="해결-방법">해결 방법</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(<span class="meta-string">"test"</span>)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootTestSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> entityManagerFactory: EntityManagerFactory</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> query: JPAQueryFactory</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> entityManager: EntityManager <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        entityManagerFactory.createEntityManager()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> transaction: EntityTransaction <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        entityManager.transaction</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">save</span><span class="params">(entity: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">        transaction.begin()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            entityManager.persist(entity)</span><br><span class="line">            entityManager.flush() <span class="comment">// transaction commit시 자동으로 flush 발생시키나 명시적으로 선언</span></span><br><span class="line">            transaction.commit()</span><br><span class="line">            entityManager.clear()</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            transaction.rollback()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> entity</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">saveAll</span><span class="params">(entities: <span class="type">Iterable</span>&lt;<span class="type">T</span>&gt;)</span></span>: Iterable&lt;T&gt; &#123;</span><br><span class="line">        transaction.begin()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (entity <span class="keyword">in</span> entities) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                entityManager.persist(entity)</span><br><span class="line">                entityManager.flush() <span class="comment">// transaction commit시 자동으로 flush 발생시키나 명시적으로 선언</span></span><br><span class="line">                transaction.commit()</span><br><span class="line">                entityManager.clear()</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                transaction.rollback()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entities</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해결 방법은 테스트 코드를 위해서 필요한 기능을 제공해 주는 <code>SpringBootTestSupport</code>을 제공해 주는 것입니다. 자세한 코드는 아래에서 설명하겠습니다.</p><h3><span id="과도한-dependency-해결-방법">과도한 Dependency 해결 방법</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">save</span><span class="params">(entity: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    transaction.begin()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        entityManager.persist(entity)</span><br><span class="line">        entityManager.flush() <span class="comment">// transaction commit시 자동으로 flush 발생시키나 명시적으로 선언</span></span><br><span class="line">        transaction.commit()</span><br><span class="line">        entityManager.clear()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        transaction.rollback()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">saveAll</span><span class="params">(entities: <span class="type">Iterable</span>&lt;<span class="type">T</span>&gt;)</span></span>: Iterable&lt;T&gt; &#123;</span><br><span class="line">    transaction.begin()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (entity <span class="keyword">in</span> entities) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            entityManager.persist(entity)</span><br><span class="line">            entityManager.flush() <span class="comment">// transaction commit시 자동으로 flush 발생시키나 명시적으로 선언</span></span><br><span class="line">            transaction.commit()</span><br><span class="line">            entityManager.clear()</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            transaction.rollback()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entities</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Given</code>절에서 작성하는 데이터 Set up이기 때문에 <strong>트랜잭션을 완전히 분리하기 위해서 transactionn을 commit을 직접 수행 시킵니다.</strong> transaction commit 시에 flush가 동작하지만 명시적으로 코드를 작성했습니다.</p><p>주의해야할 점은</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entityManager.clear()</span><br></pre></td></tr></table></figure><p><strong>EntityManager를 이용해서 clear()을 강제로 발생시키는 있는 점입니다.</strong></p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/query-result-.png" alt=""></p><p>영속성 컨텍스트는 1차 캐시를 우선시 합니다. 즉 추가적인 JPQL 쿼리로 조회한 값이 영속성 컨텍스트에 존재하는 경우(식별자 값으로 동일성을 판단함) JPQL로 조회한 데이터를 버립니다. <strong>즉 1차 캐시된것을 우선시합니다.</strong></p><p>그러기 때문에 EntityManager를 이용해서 <strong>영속성 컨텍스트를 초기화하는 것입니다.</strong> 자세한 내용은 <a href="https://cheese10yun.github.io/jpa-bulk/#1">JPA 벌크 작업 주의점 - 영속성 컨텍스트는 1차 캐시된 것이 우선이다.</a> 포스팅을 참고해 주세요</p><p>그리고 <code>Give</code>절에 작성하는 데이터는 이미 데이터베이스에 영속화되어 있다는 개념으로 테스트하는 것이니 이런 문제가 없더라도 최대한 동일한 환경을 구성해주는 것이 좋다고 생각합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaTestSupport</span> : <span class="type">SpringBootTestSupport</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `entityManager를 이용해서 dependency가 최소화 `<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 특정 테스트를 하기 위해서 많은 디펜던시가 필요하다.</span></span><br><span class="line">        save(Payment(BigDecimal.TEN))</span><br><span class="line">        save(Member(<span class="string">"username"</span>, <span class="number">10</span>, save(Team(<span class="string">"team-ename"</span>))))</span><br><span class="line">        save(Coupon(BigDecimal.TEN))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entity의 영속성을 EnttiyManager를 통해서 진행하기 때문에 단순 save를 위해서 DI 받는 Repository가 없어졌습니다.</p><h3><span id="검증이-필요한데-해결방법">검증이 필요한데 ?.. 해결방법</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">query</span><span class="params">(entityManager: <span class="type">EntityManager</span>)</span></span>: JPAQueryFactory &#123;</span><br><span class="line">        <span class="keyword">return</span> JPAQueryFactory(entityManager)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootTestSupport</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> query: JPAQueryFactory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JPAQueryFactory</code>을 <code>query</code>으로 Bean 등록을 진행합니다. Test Scope에서만 사용하는 것을 원하는 경우에는 Test directory에 <code>@TestConfiguration</code>으로 지정해도 됩니다.</p><p><code>query</code>을 이용해서 테스트 코드 검증을 진행할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaTestSupport</span> : <span class="type">SpringBootTestSupport</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `entityManager를 이용해서 dependency가 최소화 `<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 특정 테스트를 하기 위해서 많은 디펜던시가 필요하다.</span></span><br><span class="line">        save(Payment(BigDecimal.TEN))</span><br><span class="line">        save(Member(<span class="string">"username"</span>, <span class="number">10</span>, save(Team(<span class="string">"team-ename"</span>))))</span><br><span class="line">        save(Coupon(BigDecimal.TEN))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 특정 서비스가 여러 entity rows를 변경할때 아래와 같은 조회로 Then 이어가야 합니다.</span></span><br><span class="line">        <span class="comment">// paymentRepository.findBy... epository 메서드는 없는데??...</span></span><br><span class="line">        <span class="comment">// memberRepository.findBy...</span></span><br><span class="line">        <span class="comment">// couponRepository.findBy...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> payments = query.selectFrom(QPayment.payment)</span><br><span class="line">            .where(QPayment.payment.amount.gt(BigDecimal.TEN))</span><br><span class="line">            .fetch()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> members = query.select(QMember.member.age)</span><br><span class="line">            .from(QMember.member)</span><br><span class="line">            .where(QMember.member.age.gt(<span class="number">20</span>))</span><br><span class="line">            .fetch()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> coupons = query.selectFrom(QCoupon.coupon)</span><br><span class="line">            .where(QCoupon.coupon.amount.eq(<span class="number">123.</span>toBigDecimal()))</span><br><span class="line">            .fetch()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여러 엔티티의 여러 row의 수정을 진행했을 경우 해당 엔티티의 변경을 확인하기 위한 검증이 필요합니다. 이때 조회용 메서드를 단순히 테스트 코드에서만 사용하기 위해서 작성하기 위해서 작성하거나 Test Scope에 별도의 Repository를 구성해야 했지만 이제는 위에서 등록한 <code>query</code>을 이용해서 해당 비즈니스에 맞는 쿼리를 작성할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentServiceTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paymentService: PaymentService</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `paymentZero test`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">val</span> targetAmount = <span class="number">105.</span>toBigDecimal()</span><br><span class="line">        saveAll((<span class="number">1.</span><span class="number">.100</span>).map &#123;</span><br><span class="line">            Payment(it.toBigDecimal().plus(BigDecimal.TEN).setScale(<span class="number">0</span>))</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        paymentService.paymentZero(targetAmount)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        <span class="keyword">val</span> count = query</span><br><span class="line">            .selectFrom(qPayment)</span><br><span class="line">            .where(qPayment.amount.gt(targetAmount))</span><br><span class="line">            .fetchCount()</span><br><span class="line"></span><br><span class="line">        then(count).isEqualTo(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>이런 식으로 심플하게 테스트 코드를 작성할 수 있습니다.</p><h2><span id="주의할-점">주의할 점</span></h2><p><code>SpringBootTestSupport</code> 클래스에서 정의한 <code>save()</code>, <code>saveAll()</code> 메서드를 사용하는 경우 테스트에서 사용하는 트랜잭션과 완전하게 분리가 됩니다.</p><p>스프링 테스트에서는 <code>@Transactional</code>이 있는 경우 해당 테스트 메서드가 종료되면 트랜잭션으로 같이 Rollback이 진행되게 됩니다. 하지만 <code>SpringBootTestSupport</code>에서 작성한 <code>save()</code>, <code>saveAll()</code>메서드 같은 경우에는 완전히 다른 트랜잭션이므로 <code>given</code>절에서 작성한 트랜잭션이 롤백 되지 않습니다.</p><h2><span id="마무리">마무리</span></h2><p>테스트 코드의 중요성의 강조는 의미 없을 정도로 현업에서 자리 잡았다고 생각합니다. 이렇게 중요성이 있는 부분이니 테스트 코드를 작성하기 편한 방법도 많이 연구되었으면 좋겠다는 생각이 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JPA 기반으로 테스트 코드를 작성하면서 불편했던 부분을 소개하고 해결 방법에 관한 포스팅입니다.&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;jpa-기반-테스트-불편한-점&quot;&gt;JPA 기반 테스트 불편한 점&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span id=&quot;과도한
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Test" scheme="https://cheese10yun.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>Querydsl Repository Support 활용</title>
    <link href="https://cheese10yun.github.io/querydsl-support/"/>
    <id>https://cheese10yun.github.io/querydsl-support/</id>
    <published>2020-02-28T15:00:00.000Z</published>
    <updated>2020-02-29T14:02:39.470Z</updated>
    
    <content type="html"><![CDATA[<p>개발을 진행할 하다 보면 다양한 조회 쿼리를 만들게 됩니다. JPA를 이용한다면 Querydsl Support를 사용하면 세부 구현체를 숨기고 Repository를 통해서 조회 쿼리를 제공해 줄 수 있어 장점이 있습니다.</p><p>관련 <a href="https://github.com/cheese10yun/spring-jpa-best-practices/blob/master/doc/step-15.md" rel="external nofollow noopener noreferrer" target="_blank">step-15: Querydsl를 이용해서 Repository 확장하기 (1)</a>, <a href="https://cheese10yun.github.io/jpa-preference/">JPA 선호하는 패턴</a>을 참고해 주세요</p><h2><span id="querydslrepositorysupport-사용시-문제점">QuerydslRepositorySupport 사용시 문제점</span></h2><p>QuerydslRepositorySupport은 <code>JPQLQuery</code>를 이용해서 JPQL 작업을 진행합니다. 그래서 약간 단점이 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.querydsl.domain.QPayment.payment <span class="keyword">as</span> qPayment</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentCustomRepositoryImpl</span> : <span class="type">QuerydslCustomRepositorySupport</span></span>(Payment::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>), <span class="type">PaymentCustomRepository &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findUseFrom</span><span class="params">(targetAmount: <span class="type">BigDecimal</span>)</span></span>: List&lt;Payment&gt;? &#123;</span><br><span class="line">        <span class="keyword">return</span> from(qPayment)</span><br><span class="line">            .where(qPayment.amount.gt(targetAmount))</span><br><span class="line">            .fetch()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당 코드를 보면 <code>from</code>으로 시작해야 합니다. <code>QuerydslRepositorySupport</code> 구현체의 from 메서드는 아래와 같습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; JPQLQuery&lt;T&gt; from(EntityPath&lt;T&gt; path) &#123;</span><br><span class="line">    <span class="keyword">return</span> getRequiredQuerydsl().createQuery(path).select(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>즉 <code>JPQLQuery</code>을 사용해서 쿼리 작업을 진행해야 되기 때문에 <code>from</code>으로 시작할 수밖에 없습니다.</p><p>사실 별거 아닌 거 같지만 우리는 일반적으로 query를 시작할 때는 <code>select</code>으로 시작합니다. <code>queryFactory</code>을 이용하면 select, selectFrom으로 쿼리를 시작할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findUseSelectFrom</span><span class="params">(targetAmount: <span class="type">BigDecimal</span>)</span></span>: List&lt;Payment&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> selectFrom(qPayment)</span><br><span class="line">        .where(qPayment.amount.gt(targetAmount))</span><br><span class="line">        .fetch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findUseSelect</span><span class="params">(targetAmount: <span class="type">BigDecimal</span>)</span></span>: List&lt;<span class="built_in">Long</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> select(qPayment.id)</span><br><span class="line">        .from(qPayment)</span><br><span class="line">        .where(qPayment.amount.gt(targetAmount))</span><br><span class="line">        .fetch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>selectFrom</code>은 조회하는 타입이 일치하는 경우 사용할 수 있고, <code>select</code>는 리턴 받을 타입을 지정할 수 있습니다. 우리가 일반적으로 사용하는 SQL 문과 아주 유사한 구조입니다.</p><h2><span id="querydslcustomrepositorysupport-작성하기">QuerydslCustomRepositorySupport 작성하기</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">QuerydslCustomRepositorySupport</span></span>(domainClass: Class&lt;*&gt;) : QuerydslRepositorySupport(domainClass) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> queryFactory: JPAQueryFactory <span class="keyword">by</span> Delegates.notNull()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setEntityManager</span><span class="params">(entityManager: <span class="type">EntityManager</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setEntityManager(entityManager)</span><br><span class="line">        <span class="keyword">this</span>.queryFactory = JPAQueryFactory(entityManager)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">select</span><span class="params">(expr: <span class="type">Expression</span>&lt;<span class="type">T</span>&gt;)</span></span>: JPAQuery&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> queryFactory.select(expr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">selectFrom</span><span class="params">(from: <span class="type">EntityPath</span>&lt;<span class="type">T</span>&gt;)</span></span>: JPAQuery&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> queryFactory.selectFrom(from)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용법은 간단합니다. <code>QuerydslRepositorySupport</code>을 상속하는 클래스를 <strong>직접 정의해서 제공하는 것입니다.</strong></p><p>코드는 간단합니다. <code>EntityManager</code>을 상위 클래스에서 전달해 주며 <code>JPAQuery</code>에서 제공해 주는 <code>select</code>, <code>selectFrom</code>을 구현(JPAQuery의 메서드를 복붙)하면 됩니다. <code>select</code>, <code>selectFrom</code> 외에도 다양한 기능들을 제공해 줄 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentRepositoryTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paymentRepository: PaymentRepository</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `findUseSelectFrom`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">val</span> targetAmount = <span class="number">200.</span>toBigDecimal()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="keyword">val</span> payments = paymentRepository.findUseSelectFrom(targetAmount)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        then(payments).anySatisfy &#123;</span><br><span class="line">            then(it.amount).isGreaterThan(targetAmount)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `findUseSelect`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">val</span> targetAmount = <span class="number">200.</span>toBigDecimal()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="keyword">val</span> ids = paymentRepository.findUseSelect(targetAmount)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        then(ids).hasSizeGreaterThan(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/queydsl-support-result.png" alt=""></p><p>테스트 코드를 통과로 정상 동작하는 것을 확인할 수 있습니다.<br><code>select</code>, <code>selectFrom</code> 시작해서 큰 이득을 얻을 수 없지만 최대한 SQL스럽게 코드를 작성할 수 있어서 개인적으로 선호하는 방식입니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;개발을 진행할 하다 보면 다양한 조회 쿼리를 만들게 됩니다. JPA를 이용한다면 Querydsl Support를 사용하면 세부 구현체를 숨기고 Repository를 통해서 조회 쿼리를 제공해 줄 수 있어 장점이 있습니다.&lt;/p&gt;
&lt;p&gt;관련 &lt;a 
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Querydsl" scheme="https://cheese10yun.github.io/tags/Querydsl/"/>
    
  </entry>
  
  <entry>
    <title>Querydsl Projection 방법 소개 및 선호하는 패턴 정리</title>
    <link href="https://cheese10yun.github.io/querydsl-projections/"/>
    <id>https://cheese10yun.github.io/querydsl-projections/</id>
    <published>2020-02-20T14:39:57.000Z</published>
    <updated>2020-02-21T15:15:13.808Z</updated>
    
    <content type="html"><![CDATA[<p>Querydsl를 이용하는 경우 엔티티와 다른 반환 타입인 경우 <code>Projections</code>를 사용합니다. <code>Projections</code>을 하는 방법과 선호하는 패턴을 정리해보았습니다.</p><p><code>Projections</code>을 이용해서 projection 하는 방법은 크게 3가지가 있습니다.</p><ol><li><code>Projections.bean</code>을 이용하는 방법</li><li><code>Projections.constructor</code>를 이용하는 방법</li><li><code>@QueryProjection</code>를 사용하는 방법</li></ol><p>결론부터 말씀드리면 <code>@QueryProjection</code>을 사용하는 방법이 가장 좋다고 생각합니다. 각 패턴의 장단점을 설명드리겠습니다.</p><h2><span id="projectionsbean">Projections.bean</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberDtoBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> username: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectionTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> em: EntityManager</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> query = JPAQueryFactory(em)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `projection bean`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> members = query</span><br><span class="line">            .select(Projections.bean(</span><br><span class="line">                MemberDtoBean::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>,<span class="type"></span></span></span><br><span class="line">                qMember.username,</span><br><span class="line">                qMember.age</span><br><span class="line">            ))</span><br><span class="line">            .from(qMember)</span><br><span class="line">            .fetch()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">            println(member)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Projections.bean</code> 방식은 setter 기반으로 동작하게 됩니다. 그러기 때문에 <code>MemberDtoBean</code>객체의 setter 메서드를 열어야 합니다. 일반적으로 Response, Request 객체는 불변 객체를 지향하는 것이 바람직하다고 생각하기 때문에 권장하는 패턴은 아닙니다.</p><h2><span id="projectionsconstructor">Projections.constructor</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberDtoConstructor</span></span>(</span><br><span class="line">    <span class="keyword">val</span> username: String,</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectionTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> em: EntityManager</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> query = JPAQueryFactory(em)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `projection <span class="keyword">constructor</span>`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> members = query</span><br><span class="line">            .select(Projections.<span class="keyword">constructor</span>(</span><br><span class="line">                MemberDtoConstructor::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>,<span class="type"></span></span></span><br><span class="line">                qMember.username,</span><br><span class="line">                qMember.age</span><br><span class="line">            ))</span><br><span class="line">            .from(qMember)</span><br><span class="line">            .fetch()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">            println(member)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Projections.constructor</code>를 사용하면 생성자 기반으로 바인딩 하기 때문에 <code>MemberDtoConstructor</code>객체를 불변으로 가져갈 수 있습니다. <strong>하지만 바인딩 시키는 작업에 문제가 있습니다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.select(Projections.<span class="keyword">constructor</span>(</span><br><span class="line">    MemberDtoConstructor::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>,<span class="type"></span></span></span><br><span class="line">    qMember.username,</span><br><span class="line">    qMember.age</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>위 코드를 보면 <code>MemberDtoConstructor</code>객체 생성자에 바인딩 하는 것이 아니라 <code>Expression&lt;?&gt;... exprs</code> 값을 넘기는 방식으로 진행합니다.</p><p><strong>즉 값을 넘길 때 생성자와 순서를 일치시켜야 합니다.</strong> 위처럼 개수가 몇 개 안될 때는 문제가 되지 않으나 값이 많아지는 경우 실수할 수 있는 문제가 발생할 수 있는 확률이 높습니다. 이러한 문제가 있어 권장하지 않은 패턴입니다.</p><h2><span id="queryprojection">@QueryProjection</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberDtoQueryProjection</span> <span class="meta">@QueryProjection</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">val</span> username: String,</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectionTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> em: EntityManager</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> query = JPAQueryFactory(em)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `projection <span class="keyword">annotation</span>`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> members = query</span><br><span class="line">            .select(QMemberDto(</span><br><span class="line">                qMember.username,</span><br><span class="line">                qMember.age</span><br><span class="line">            ))</span><br><span class="line">            .from(qMember)</span><br><span class="line">            .fetch()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">            println(member)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>@QueryProjection</code>를 이용하면 위에서 발생한 불변 객체 선언, 생성자 그대로 사용을 할 수 있어 권장하는 패턴입니다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.select(QMemberDto( <span class="comment">// QMemberDtoQueryProjection 의 생성자를 이용한다.</span></span><br><span class="line">    qMember.username,</span><br><span class="line">    qMember.age</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>정확히는 <code>MemberDtoQueryProjection</code>의 생성자를 사용하는 것이 아니라. <code>MemberDtoQueryProjection</code> 기반으로 생성된 <code>QMemberDtoQueryProjection</code> 객체의 생성자를 사용하는 것입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Generated</span>(<span class="string">"com.querydsl.codegen.ProjectionSerializer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QMemberDtoQueryProjection</span> <span class="keyword">extends</span> <span class="title">ConstructorExpression</span>&lt;<span class="title">MemberDtoQueryProjection</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">277743863L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QMemberDtoQueryProjection</span><span class="params">(com.querydsl.core.types.Expression&lt;String&gt; username, com.querydsl.core.types.Expression&lt;Integer&gt; age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(MemberDtoQueryProjection.class, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class&#125;, username, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>QMemberDtoQueryProjection</code>생성자는 <code>MemberDtoQueryProjection</code> 생성자의 변수명과 순서와 정확하게 일치합니다.</p><p>그래서 IDE의 자동완성 기능을 이용해서 보다 안전하고 편리하게 생성자에 필요한 값 바인딩을 진행할 수 있습니다. 그래서 가장 권장하는 패턴입니다.</p><p>물론 단점도 있습니다. <code>Dto</code>라는 특성상 해당 객체는 많은 계층에서 사용하게 됩니다. 그렇게 되면 Querydsl의 의존성이 필요 없는 레이어에서도 해당 의존성이 필요하게 됩니다.</p><p>저는 개인적으로 이 정도의 의존관계 때문에 발생하는 의존성 문제 보다 <code>Projections</code>를 안전하게 사용할 수 있는 방법이 더 효율적이라고 생각합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Querydsl를 이용하는 경우 엔티티와 다른 반환 타입인 경우 &lt;code&gt;Projections&lt;/code&gt;를 사용합니다. &lt;code&gt;Projections&lt;/code&gt;을 하는 방법과 선호하는 패턴을 정리해보았습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Pro
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JPA 선호하는 패턴</title>
    <link href="https://cheese10yun.github.io/jpa-preference/"/>
    <id>https://cheese10yun.github.io/jpa-preference/</id>
    <published>2020-02-11T15:00:00.000Z</published>
    <updated>2020-03-05T17:40:52.600Z</updated>
    
    <content type="html"><![CDATA[<p>최근 JPA를 3년 가까이 사용하면서 개인적인으로 선호하는 패턴들을 한 번 정리하려고 한다. 어디까지 개인적으로 선호하는 패턴으로 굳이 이런 가이드를 따르지 않아도 된다.</p><h2><span id="컬럼-에노테이션-사용">컬럼 에노테이션 사용</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"member"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>(</span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"username"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> username: String,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"age"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"email"</span>, nullable = false, unique = true, updatable = false)</span></span><br><span class="line">    <span class="keyword">var</span> email: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>칼럼 에노테이션과 멤버 필명이 동일한 경우 칼럼에노테이션을 생략하는 경우도 있다. 그래서 일치하지 않은 것들만 작성하는 방법도 있지만 <strong>나는 모든 멤버 필드에 칼럼 에노테이션을 작성하는 패턴을 선호한다.</strong></p><p><strong>칼럼 에노테이션을 통해 <code>nullable</code>, <code>unique</code>, <code>updatable</code> 등등 여러 메타 정보를 전달해 줄 수 있다.</strong> 물론 필요한 경우에만 추가하고 기본적으로 작성하지 않아도 되는 패턴을 선택해도 되지만 <strong>개인적으로 이런 예매한 예외를 두는 가이드 보다</strong> 조금 불편하더라도 다 작성하는 패턴이 좋다고 본다.</p><p>그리고 일단 컬럼 에노테이션을 작성하면 한 번더 이 필드에 대해서 생각을 해보고 unique, nullable 여부 등을 한 번 더 생각 보게 돼서 좋다고 생각한다.</p><p>또 멤버 필드 리네임 관련 리팩토링에 과감해질 수 있다. 멤버 필드는 카멜케이스, 데이터베이스는 스네이크 케이스를 사용하는 경우가 흔한데 칼럼명이 긴 경우 가끔 오타 때문에 실수할 수 도 있다. 그러기 때문에 애초에 칼럼 에노테이션으로 다 작성하는 게 리팩토링 할 때도 안전성이 있다. 칼럼 에노테이션을 작성하면 <strong>멤버 필드 rename 관련 리팩토링을 과감하게 할 수 있다.</strong></p><h2><span id="엔티티에-과도한-에노테이션은-작성하지-않는다">엔티티에 과도한 에노테이션은 작성하지 않는다</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(</span></span><br><span class="line"><span class="meta">    name = <span class="meta-string">"member"</span>,</span></span><br><span class="line"><span class="meta">    indexes = [</span></span><br><span class="line"><span class="meta">        Index(columnList = <span class="meta-string">"username"</span>)</span>,</span><br><span class="line">        Index(columnList = <span class="string">"age"</span>)</span><br><span class="line">    ],</span><br><span class="line">    uniqueConstraints = [</span><br><span class="line">        UniqueConstraint(columnNames = [<span class="string">"username"</span>, <span class="string">"age"</span>])</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>(</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br>사실 위 칼럼 에노테이션 사용과는 좀 반대되는 개념이긴 한데 너무 과도한 에노 테이션으로 엔티티 클래스의 비즈니스 코드의 집중도를 떨어트리기 때문에 선호하지 않는다.</p><p>물론 위 작업을 아주 간결하게 표현할 수 있다면 가능하면 작성하는 것도 좋지만, 해당 속성들은 비교적 변경사항이 잦기 때문에 작성하지 않는 것을 선호하는 이유이기도 하다.</p><h2><span id="조인-칼럼을-사용하자">조인 칼럼을 사용하자</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>(</span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY, optional = false)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = <span class="meta-string">"team_id"</span>, nullable = false)</span> <span class="comment">// 생략 가능</span></span><br><span class="line">    <span class="keyword">var</span> team: Team</span><br><span class="line">) : EntityAuditing()</span><br></pre></td></tr></table></figure><p>OneToOne, ManyToOne 정보 같은 경우 연관관계의 주인에서 FK를 갖게 되기 때문에  칼럼 에노테이션을 작성할 수 있다. 연관관계 에노테이션으로 작성하면 기본적으로 PK 기반으로 되기 때문에 생략 가능하다.</p><p>하지만 칼럼 에노테이션을 사용하는 이유와 마찬가지로 조인 칼럼 에노테이션을 작성하는 것을 선호한다. <code>nullable</code>, <code>unique</code>, <code>updatable</code> 등 정보를 많이 표현해 준다.</p><p><strong>무엇보다 nullabel 설정에 따른 조인 전략이 달라질 수 있어 성능상 이점을 얻을 수 있는 부분이 있다.</strong> 이 부분은<br><a href="https://github.com/cheese10yun/spring-jpa-best-practices/blob/master/doc/step-08.md#%EC%A0%9C%EC%95%BD-%EC%A1%B0%EA%B1%B4%EC%9C%BC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EC%95%88%EC%A0%95%EC%84%B1-%EB%B0%8F-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81" rel="external nofollow noopener noreferrer" target="_blank">step-08: OneToOne 관계 설정 팁 : 제약 조건으로 인한 안정성 및 성능 향상</a>에서도 포스팅 한적 있다.</p><p>그리고 익숙하지 않은 프로젝트에서 칼럼명으로 엔티티 클래스를 찾는 경우가 있는데 이런 경우 해당 칼럼명으로 쉽게 검색할 수 있어 약간의 장점이 있다.</p><h2><span id="양방향-보다는-단방향으로-설정하자">양방향 보다는 단방향으로 설정하자</span></h2><p><strong>기본적으로 JPA 연관관계 설정은 단방향으로 설정하는 것을 선호한다.</strong> 사실 이것은 선호하기보다는 가이드 쪽에 가깝다. 우선 양방향 연관관계를 작성하면 생각 보다 고려할 부분이 많다. 양방향 편의 메서드, 디펜던시 사이클 문제가 있기 때문이다.</p><p><strong>무엇보다 OnyToMany, ManyToOne 관계는 설정은 선호하지 않는다.</strong> OneToMany를 관계를 갖게 되면 N+1 문제(물론 OneToMany를 관계에서만 N+1 문제가 발생하지는 않는다.) OneToMany 2개 이상 갖는 경우 카테시안 곱 문제로 <code>MultipleBagFetchException</code> 발생한다. <strong>양방향 메서드를 반드시 지정해야 할 이유가 없다면 단방향 관계를 지향하는 것이 좋다고 생각한다.</strong></p><h2><span id="open-session-in-view-false로-두자">Open Session In View false로 두자</span></h2><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/jpa-osiv-2.png" alt=""></p><p>OSIV는 영속성 컨텍스트를 View 레이어까지 열어 둘 수 있다. 영속성 컨텍스트가 살아있으면 엔티티는 영속 상태로 유지된다. 따라서 <strong>뷰에서도 지연 로딩을 사용할 수 있다. 하지만 View에서 트랜잭션을 계속 가지고 있는 것이 좋다고 생각하지 않는다.</strong></p><p>기존 OSIV 문제를 해결하기 위해서 비즈니스 계층에서만 트랜잭션을 유지하는 방식의 OSIV를 스프링에서 지원해주고 있긴 하지만 ModelAndView를 사용하지 않고 <strong>단순하게 API로 JSON 같은 응답을 내려주는 서버로 사용한다면 View false를 false 두는 것이 좋다.(기본이 true이다)</strong></p><h2><span id="객체-그래프-탐색은-어디까지-할것인가-좀-끊자">객체 그래프 탐색은 어디까지 할것인가? 좀 끊자!</span></h2><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/eggregate.png?raw=true" alt=""></p><p>관계형 데이터베이스는 FK를 통해서 연관 탐색을 계속 진행할 수 있다. 마찬가지로 JPA도 객체 그래프 탐색을 통해서 연관 탐색을 계속 진행할 수 있다. <strong>이것은 그래프 탐색의 오용이라고 생각한다.</strong></p><p>DDD를 프로덕션 레벨에서 진행해본 적은 없지만 DDD에서 주장하는 에그리거트 단위, 그 단위가 다르면 객체 탐색을 끓는 것은 매우 동의한다.</p><p>위 처럼 주문, 회원이 있는 경우</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"orders"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>(</span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"amount"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> amount: BigDecimal,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="keyword">var</span> orderer: Orderer</span><br><span class="line"></span><br><span class="line">) : EntityAuditing()</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Orderer</span></span>(</span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"member_id"</span>, nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">var</span> memberId: <span class="built_in">Long</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"email"</span>, nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">var</span> email: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>연관관계를 명확하게 끊는 것이 옳다고 본다. 연관관계를 계속 탐색할 수 있는 것도 문제지만 연관관계를 갖게 되면 주문을 조회한 이후에 회원 정보를 변경할 수도 있다. <strong>Order 객체의 책임과 역할이 어디까지 인가를 봤을 때 이렇게 명확하게 끊는 것이 옳다고 본다.</strong>  만약 조회가 필요한 경우 <code>Orderer</code>객체에 <code>memberId</code>가 있으니 회원정보가 필요시에 조인해서 가져오면된다.</p><p>이것도 가이드 수준으로 생각하고 있지만 아직 DDD를 실무에서 진행해본 적이 없어 막연하게 드는 생각이라 가능하면 에그리거트 기준으로 연관관계를 끊는 것이 좋다고 생각만 하고 있다.</p><h2><span id="쿼리-메서드는-선호하지-않는다">쿼리 메서드는 선호하지 않는다.</span></h2><p><img src="https://github.com/cheese10yun/spring-jpa-best-practices/raw/master/images/AccountRepository.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Account</span>, <span class="title">Long</span>&gt;, <span class="title">AccountCustomRepository</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountCustomRepository</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findRecentlyRegistered</span><span class="params">(<span class="keyword">int</span> limit)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountCustomRepositoryImpl</span> <span class="keyword">extends</span> <span class="title">QuerydslRepositorySupport</span> <span class="keyword">implements</span> <span class="title">AccountCustomRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountCustomRepositoryImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Account.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 최근 가입한 limit 갯수 만큼 유저 리스트를 가져온다</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findRecentlyRegistered</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> QAccount account = QAccount.account;</span><br><span class="line">        <span class="keyword">return</span> from(account)</span><br><span class="line">                .limit(limit)</span><br><span class="line">                .orderBy(account.createdAt.desc())</span><br><span class="line">                .fetch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이건 정말 개인적인 선호도이다. 일단 조건이 까다로운 조회용 코드인 경우 <strong>쿼리 메서드로 표현하면 너무 장황해서 코드 가독성이 좋지 않다고 본다.</strong></p><p>쿼리 메서드를 사용하지 않고 QuerydslRepositorySupport를 이용한 Query DSL 기반으로 모두 작성하는 것을 선호한다. 물론 findByEmail 같은 것들은 쿼리 메서드가 더 편리하고 직관적이다고 생각하지만 위에서도 한 번 언급했지만 예외를 하나를 허용하면 추가적인 예외가 생기게 되기 때문에 <strong>아주 명확한 가이드가 없다면 모두 Query DSL 기반으로 작성하는 것을 선호한다.</strong></p><p>또 엔티티의 멤버 필드 변경 시에도 쿼리 메서드의 변경돼야 하는 것도 문제라고 생각한다. 물론 인텔리 제이에서 멤버 필드 rename 시에 적절하게 변경해주기도 하고, 스프링에서 쿼리 메서드가 문제가 있는 경우 스프링 구동시 예외가 발생하기 때문에 최소한의 안전장치가 있긴 하지만(이것도 없었다면 쿼리 메서드는 사용하지 않는 것을 가이드 했을 거 같다) 이러한 문제 때문에도 쿼리 메서드를 선호하지 않는다.</p><p>물론 Query DSL도 멤버 필드 변경 시에는 문제가 발생한다. 그 문제는 <code>Qxx.class</code>관련 Syntax이기 때문에 더 명확하다는 장점이 있다고 본다.</p><p><strong>그리고 무엇보다 비즈니스 로직의 컨텍스트를 메서드명으로 표현 못 한다.</strong> 활동하지 않은 휴면 회원의 정의를 마지막 로그인, 회원의 등급, 현재 회원의 상태 등등으로 정의하는 경우 이것을 쿼리 메서드로 작성하면 <code>findByLastLoginatAndStatusAndGrade</code> 와 유사하게 작성해야 한다.</p><p><strong>이것은 그냥 쿼리조건문을 뜻할 뿐 활동하지 않은 휴먼회원을 뜻하지 않는다.</strong> 물론 앞뒤 코드를 가지고 어느정도 유추는할 수 있지만 정확하게 전달하는 것은 아니다. 차리리 Querydsl으로 코드를 작성하고 <code>findDormancyMember</code> 으로 메서드를 지정하는 것이 훨씬 더 좋다고 생각한다.</p><p>또 다른 이유는, 지극히 주관적인 생각이지만 쿼리 메서드는 인터페이스 기반으로 작성하기 때문에 테스트 코드를 작성하지 않는 경우도 많다. 반면 Query DSL 세부 클래스를 작성하기 때문에 뭔가 테스트를 더 작성하게 하는 심리적인 이유도 있는 거 같다.</p><p>위 코드처럼 QuerydslRepositorySupport을 이용하면 Repository를 통해서 세부 구현체의 코드를 제공하기 때문에 이런 식의 패턴을 선호한다. 해당 패턴은 <a href="https://github.com/cheese10yun/spring-jpa-best-practices/blob/master/doc/step-15.md" rel="external nofollow noopener noreferrer" target="_blank">step-15: Querydsl를 이용해서 Repository 확장하기 (1)</a>에서 자세하게 다룬 적 이 있다.</p><h2><span id="auditing-상속-구조로-사용하자">Auditing 상속 구조로 사용하자</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EntityListeners(value = [AuditingEntityListener::class])</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityAuditing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreationTimestamp</span></span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"created_at"</span>, nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> createdAt: LocalDateTime</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@UpdateTimestamp</span></span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"updated_at"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> updatedAt: LocalDateTime</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"member"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>(</span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"username"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> username: String,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"age"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY, optional = false)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = <span class="meta-string">"team_id"</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> team: Team</span><br><span class="line">) : EntityAuditing()</span><br></pre></td></tr></table></figure><p><code>@MappedSuperclass</code>, <code>@EntityListeners</code>를 사용하면 반복적인 id, createdAt, updatedAt을 코드를 상속받아 해결할 수 있다. 예전에는 이런 식의 상속 구조는 올바르지 않다고 생각해서 이런 패턴에 거부감이 있었다.</p><p>하지만 요즘에는 잘 사용하고 있다. 순수한 객체지향 코드를 유지하는 것도 중요하지만 결국 실리성 있는 부분을 택하는 것도 중요하다고 본다. 특히 코틀린으로 넘어오면서 id, createdAt, updatedAt 등 우리가 직접적으로 핸들링하지 않는 값에 대한 바인딩 방법이 많기 때문에 각각 엔티티에서 처리하면 코드 통일성이 떨어진다. 그래서 이렇게 처리하는 것이 좋다고 생각한다.</p><h2><span id="참고">참고</span></h2><ul><li><a href="http://acornpub.co.kr/book/jpa-programmig" rel="external nofollow noopener noreferrer" target="_blank">자바 ORM 표준 JPA 프로그래밍</a></li><li><a href="http://www.yes24.com/Product/Goods/27750871" rel="external nofollow noopener noreferrer" target="_blank">DDD Start</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;최근 JPA를 3년 가까이 사용하면서 개인적인으로 선호하는 패턴들을 한 번 정리하려고 한다. 어디까지 개인적으로 선호하는 패턴으로 굳이 이런 가이드를 따르지 않아도 된다.&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;컬럼-에노테이션-사용&quot;&gt;컬럼 에노테이션 사
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Flush" scheme="https://cheese10yun.github.io/tags/Flush/"/>
    
  </entry>
  
  <entry>
    <title>JPA 벌크 작업 주의점</title>
    <link href="https://cheese10yun.github.io/jpa-bulk/"/>
    <id>https://cheese10yun.github.io/jpa-bulk/</id>
    <published>2020-01-31T15:00:00.000Z</published>
    <updated>2020-02-04T17:14:15.713Z</updated>
    
    <content type="html"><![CDATA[<p>JPA Bulk 작업을 진행할 때 영속성 컨텍스트의 메커니즘을 이해하지 못한 상태라면 예상하지 못한 문제를 만날 수도 있게 됩니다. 어떤 문제가 있고 이 문제가 왜 발생하는지 정리해 보았습니다.</p><h2><span id="코드">코드</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">BulkTest</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> em: EntityManager</span><br><span class="line">) : SpringBootTestSupport() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> query = JPAQueryFactory(em)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> teams = listOf(</span><br><span class="line">                Team(<span class="string">"team_1"</span>),</span><br><span class="line">                Team(<span class="string">"team_2"</span>),</span><br><span class="line">                Team(<span class="string">"team_3"</span>),</span><br><span class="line">                Team(<span class="string">"team_4"</span>),</span><br><span class="line">                Team(<span class="string">"team_5"</span>),</span><br><span class="line">                Team(<span class="string">"team_6"</span>),</span><br><span class="line">                Team(<span class="string">"team_7"</span>),</span><br><span class="line">                Team(<span class="string">"team_8"</span>),</span><br><span class="line">                Team(<span class="string">"team_9"</span>),</span><br><span class="line">                Team(<span class="string">"team_10"</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">            em.persist(team)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `bulk test`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// team 전체를 조회한다. team name은 team_x 이다.</span></span><br><span class="line">        <span class="keyword">val</span> teams = query.selectFrom(qTeam).fetch()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">            println(<span class="string">"before update team : <span class="variable">$team</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> ids = teams.map &#123; it.id!! &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// team  name 전체를 none name으로 변경한다. </span></span><br><span class="line">        <span class="keyword">val</span> updateCount = query.update(qTeam)</span><br><span class="line">                .<span class="keyword">set</span>(qTeam.name, <span class="string">"none name"</span>)</span><br><span class="line">                .where(qTeam.id.`<span class="keyword">in</span>`(ids))</span><br><span class="line">                .execute()</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"update count : <span class="variable">$updateCount</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">            println(<span class="string">"after update team : <span class="variable">$team</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> newSelectTeams = query.selectFrom(qTeam).fetch()</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (team <span class="keyword">in</span> newSelectTeams) &#123;</span><br><span class="line">            println(<span class="string">"new select team : <span class="variable">$team</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드는 간단합니다. <code>team_1</code>, <code>team_2</code>…<code>team_10</code>을 저장하고 query dsl update를 이용해서 <code>team name</code>을 <code>none name</code>으로 변경하는 것입니다. 그리고 변경 제대로 변경이 되었는지 확인하는 확인하는 반복문이 있습니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/before-update.png" alt=""></p><p>로그를 보면 <code>team name</code> 1 ~ 10까지 제대로 출력되는 것을 확인할 수 있습니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/update-query.png" alt=""></p><p>update query, update count가 정상적으로 출력됩니다. 이제 업데이트된 <code>team</code>을 확인하는 아래 코드의 로그를 확인해보겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">    println(<span class="string">"after update team : <span class="variable">$team</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/ater-update.png" alt=""><br>예상했던 <code>none name</code>이 아닌 이전 데이터가 출력 되는 것을 획인 할 수 있습니다. 그렇다면 새로 query dsl으로 조회 쿼리를 해보겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newSelectTeams = query.selectFrom(qTeam).fetch()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (team <span class="keyword">in</span> newSelectTeams) &#123;</span><br><span class="line">    println(<span class="string">"new select team : <span class="variable">$team</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/team-2.png" alt=""></p><p>신규로 조회한 데이터에서도 <code>team name</code>이 변경되지 않은 것을 확인할 수 있습니다. 왜 변경되지 않은 것일 까요?</p><h2><span id="team-엔티티가-변경되지-않은-이유">Team 엔티티가 변경되지 않은 이유</span></h2><h3><span id="jpa-벌크성-작업은-영속성-컨텍스트와-무관">JPA 벌크성 작업은 영속성 컨텍스트와 무관</span></h3><p>업데이트 이후 아래 코드가 <code>team name</code> 변경 전 데이터인 이유를 설명드리겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">    println(<span class="string">"after update team : <span class="variable">$team</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="엔티티-수정-메커니즘">엔티티 수정 메커니즘</span></h4><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/jpa-persistent-dirty-checking.png" alt=""></p><p><strong>엔티티의 변경사항을 을 데이터베이스에 반영하는 것을 변경 감지(dirty checking)이라고 합니다.</strong> JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두고. 플러시 시점에서 스냅샷과 엔티티를 비교해서 변경된 엔티티를 데이터베이스에 반영하게 됩니다. 즉 아래와 같은 절차를 진행하게 됩니다.</p><ol><li><strong>트랜잭션을 커밋 하면 엔티티 매니저 내부에서 먼저 플러시가 호출된다.</strong></li><li><strong>엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.</strong></li><li>변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.</li><li>쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다.</li><li><strong>데이터베이스 트랜잭션을 커밋 한다.</strong></li></ol><h4><span id="벌크-수정-메커니즘">벌크 수정 메커니즘</span></h4><p><strong>하지만 벌크성 작업은 영속성 컨텍스트와 무관합니다.</strong> 벌크 연산은 영속성 컨텍스트를 통하지 않고 아래 그림처럼 <strong>데이터베이스에 직접 쿼리를 진행합니다.</strong></p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/jpa-bulk.png?raw=true" alt=""></p><p><strong>즉 영속성 컨텍스트와 무관하니 기존 영속성 컨텍스트에 존재하는 Team의 name들은 변경이 없는 것입니다.</strong></p><h3><span id="영속성-컨텍스트는-1차-캐시된-것이-우선이다">영속성 컨텍스트는 1차 캐시된 것이 우선이다.</span></h3><p><code>after update team</code>를 조회했을 때는 영속성 컨텍스트와 무관했기 때문에 기존 데이터가 나왔지만 <strong>신규 조회를 한 아래 코드 왜 변경 전 name이 출력 되었을까요? 그 이유는 영속성 컨텍스트 저장 메커니즘에 있습니다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newSelectTeams = query.selectFrom(qTeam).fetch()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (team <span class="keyword">in</span> newSelectTeams) &#123;</span><br><span class="line">    println(<span class="string">"new select team : <span class="variable">$team</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="영속성-컨텍스트-저장-메커니즘">영속성 컨텍스트 저장 메커니즘</span></h4><p><a href="https://cheese10yun.github.io/jpa-persistent-context/">영속성 컨텍스트 1차 캐시 저장 메커니즘</a> 관련 포스팅에서 이미 포스팅한 적이 있습니다. 해당 글을</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/query-result-.png" alt=""></p><p>findById() 같은 경우는 영속성 컨텍스트를 먼저 찾고 영속성 컨텍스트에 해당 엔티티가 있으면 그 값을 바로 리턴합니다. 이를 1차 캐시라고 말합니다. <strong>반면 JPQL은 영속성성 컨텍스트를 먼저 조회하지 않고 데이터베이스에 query 하여 결과를 가져옵니다. 그리고 아래와 같은 흐름으로 영속성 컨텍스트를 저장을 시도합니다.</strong></p><ol><li>JPQL을 호출하면 데이터베이스에 우선적으로 조회한다.</li><li>조회한 값을 영속성 컨텍스트에 저장을 시도한다.</li><li>저장을 시도할 때 해당 데이터가 이미 영속성 컨텍스트에 존재하는 경우(영속성 컨텍스트에서는 식별자 값으로 식별) 데이터베이스에서 조회한 신규 데이터를 버린다.</li></ol><p><strong>즉 이미 영속성컨텍스트에 team들이 존재하기 때문에 신규 조회한 영속성 컨텍스트를 버리게 되는 것입니다.</strong> 영속성 컨텍스트에서는 ID를 기반으로 식별작을 합니다.</p><h2><span id="해결-방법">해결 방법</span></h2><p>해결 방법은 간단합니다. <strong>영속성 컨텍스트를 초기화(clear)을 하면 됩니다.</strong> 영속성 컨텍스트가 초기화됐기 때문에 신규 조회한 <code>team</code> 객체들이 모두 영속성 컨텍스트에 그대로 반영되게 됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">em.clear() <span class="comment">// 영속성 컨텍스트를 초기화 한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> newSelectTeams = query.selectFrom(qTeam).fetch()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (team <span class="keyword">in</span> newSelectTeams) &#123;</span><br><span class="line">    println(<span class="string">"new select team : <span class="variable">$team</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/team-name.png" alt=""></p><p>신규 조회한 <code>team name</code> 제대로 변경된 것을 확인할 수 있습니다.</p><h2><span id="참고">참고</span></h2><ul><li><a href="http://acornpub.co.kr/book/jpa-programmig" rel="external nofollow noopener noreferrer" target="_blank">자바 ORM 표준 JPA 프로그래밍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JPA Bulk 작업을 진행할 때 영속성 컨텍스트의 메커니즘을 이해하지 못한 상태라면 예상하지 못한 문제를 만날 수도 있게 됩니다. 어떤 문제가 있고 이 문제가 왜 발생하는지 정리해 보았습니다.&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;코드&quot;&gt;코드&lt;/sp
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Bulk" scheme="https://cheese10yun.github.io/tags/Bulk/"/>
    
  </entry>
  
  <entry>
    <title>RestTemplate Mock 기반 테스트 하기</title>
    <link href="https://cheese10yun.github.io/rest-template-mock-test/"/>
    <id>https://cheese10yun.github.io/rest-template-mock-test/</id>
    <published>2020-01-31T15:00:00.000Z</published>
    <updated>2020-02-01T14:30:30.408Z</updated>
    
    <content type="html"><![CDATA[<p>스프링 프로젝트에서는 외부 API 모듈을 RestTemplate를 이용해서 호출하는 경우가 많습니다, 이런 경우 RestTemplate을 기반으로 Mock 테스트를 보다 쉽게 진행할 수 있습니다.</p><h2><span id="왜-mock-기반-테스트를-진행-해야하나">왜 Mock 기반 테스트를 진행 해야하나 ?</span></h2><p>외부 인프라스트럭처를 테스트 코드를 작성할 때는 mock 기반으로 테스트를 진행해야 합니다. 외부 인프라스트럭처에는 대표적으로 외부 API가 있습니다.</p><p>그런데 왜 Mock 기반으로 테스트해야 할까요? 외부 환경이기 때문에 제어권이 우리 밖에 있습니다. 그래서 우리 코드의 테스트를 위해서 Request, Response가 우리가 주어진 값인 경우 정상 동작하는지 테스트하기 위함입니다. <strong>Mockito 기반으로 데이터베이스의 의존성을 Mock으로 처리하고 실제 비즈니스 코드를 검증하는 거와 같은 결이라고 생각하면 됩니다.</strong></p><p>물론 전체 플로우를 테스트하기 위해서는 통합 테스트를 진행할 수도 있겠지만 이번 포스팅에서는 Mock 기반 단위 테스트하는 방법을 다루겠습니다.</p><h2><span id="코드">코드</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">restTemplate</span><span class="params">(objectMapper: <span class="type">ObjectMapper</span>)</span></span>: RestTemplate &#123;</span><br><span class="line">        <span class="keyword">return</span> RestTemplateBuilder()</span><br><span class="line">            .rootUri(<span class="string">"http://localhost:8080"</span>)</span><br><span class="line">            .setConnectTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">            .additionalMessageConverters()</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/teams"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeamApi</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> query: JPAQueryFactory</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(<span class="meta">@RequestParam(required = false)</span> name: <span class="type">String</span>?)</span></span>: List&lt;Team&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> query.selectFrom(qTeam)</span><br><span class="line">            .from(qTeam)</span><br><span class="line">            .fetch()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiService</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> restTemplate: RestTemplate</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getTeam</span><span class="params">(name: <span class="type">String</span>)</span></span>: List&lt;Team&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"/teams?name=<span class="variable">$name</span>"</span>, Array&lt;Team&gt;::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)!!.<span class="title">toList</span></span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드는 간단합니다. RestTemplate 기반으로 local 서버를 호출하는 코드입니다. 테스트를 위해 Team 정보를 10개를 set up 했습니다.</p><h2><span id="테스트-코드">테스트 코드</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiServiceTest</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> restTemplate: RestTemplate, <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> apiService: ApiService <span class="comment">// (2)</span></span><br><span class="line"></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> server: MockRestServiceServer <span class="keyword">by</span> notNull()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        server = MockRestServiceServer.createServer(restTemplate) <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `api test`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">val</span> path = <span class="string">"/team-api-response.json"</span></span><br><span class="line">        <span class="keyword">val</span> name = <span class="string">"team"</span></span><br><span class="line">        server</span><br><span class="line">            .expect(</span><br><span class="line">                requestTo(<span class="string">"http://localhost:8080/teams?name=<span class="variable">$name</span>"</span>)</span><br><span class="line">            )<span class="comment">// (4)</span></span><br><span class="line">            .andExpect(method(HttpMethod.GET)) <span class="comment">// (5)</span></span><br><span class="line">            .andRespond(</span><br><span class="line">                withStatus(HttpStatus.OK)</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .body(ClassPathResource(path, javaClass))</span><br><span class="line">            )<span class="comment">// (6)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="comment">// (7)</span></span><br><span class="line">        <span class="keyword">val</span> teams = apiService.getTeam(<span class="string">"team"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        <span class="comment">// (8)</span></span><br><span class="line">        <span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">            println(team)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (9)</span></span><br><span class="line">        then(teams).hasSize(<span class="number">10</span>)</span><br><span class="line">        then(teams).anySatisfy &#123;</span><br><span class="line">            then(it.name).startsWith(<span class="string">"team"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(1) : 해당 서비스에서 사용하는 RestTemplate를 주입받습니다. 실제 실무에서는 RestTemplate를 vendor마다 등록하기 때문에 테스트하고자 하는 RestTeamplte를 주입받습니다.</li><li>(2) : 해당 API 통신하는 서비스를 주입받습니다.</li><li>(3) : 주입받은 RestTemplate 기반으로 MockRestServiceServer 생성합니다. MockRestServiceServer는 클라이언트와 서버 사이의 REST 테스트를 위한 객체입니다. 내부에서 RestTemplate를 바인딩 하여 실제로 통신이 이루어지게끔 구성할 수도 있습니다. 이 코드에서는 목 객체와 같이 실제로 통신이 이루어지지는 않지만 지정한 결로에 예상되는 반환값을 명시합니다.</li><li>(4) : 검증을 시도합니다. 실제 restTeamplte의 Request가 저 URL으로 해당하는지 검증합니다.</li><li>(5) : 실제 Request의 HTTP Method가 GET을 이용하는지 검증합니다.</li><li>(6) : Response에 대한 검증을 시작합니다. HTTP Status Code, Body, MediaType 등을 검증합니다. path 변수에는 해당 API의 예상되는 json 값을 작성해 놓습니다. Givne 절이라고 생각하면 됩니다.</li><li>(7) : 실제 서비스 코드에서 호출하는 코드를 호출합니다.</li><li>(8) : 테스트 동작 여부를 확인하기 위해서 print 하는 코드입니다.</li><li>(9) : 실제 when 절의 코드가 예상하는 것처럼 동작했는지 검증합니다.</li></ul><p>given 절에 있는 <code>/team-api-response.json</code>는 <code>/src/test/resources/</code> 디렉터리에 기본 path로 바라보며 해당 경로에 있는 파일을 찾게 됩니다. JSON 파일은 아래와 같습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"team 1"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"createdAt"</span>: <span class="string">"2020-02-01T16:58:34.377"</span>,</span><br><span class="line">    <span class="attr">"updatedAt"</span>: <span class="string">"2020-02-01T16:58:34.377"</span>,</span><br><span class="line">    <span class="attr">"members"</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"team 10"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">"createdAt"</span>: <span class="string">"2020-02-01T16:58:34.402"</span>,</span><br><span class="line">    <span class="attr">"updatedAt"</span>: <span class="string">"2020-02-01T16:58:34.402"</span>,</span><br><span class="line">    <span class="attr">"members"</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>물론 객체 기반으로 만들고 그것을 시리얼 라이즈 해서 json으로 만들어도 되지만 <a href="https://cheese10yun.github.io/spring-about-test/#json">테스트 코드 작성에 대한 나름의 고찰</a>에서 한 번 다뤘지만 해당 테스트에서 Team 객체가 Response body가 객체가 시리얼 라이즈 되는지까지 책임이 부여되기 때문에 json 파일로 response body를 관리하는 것이 더 효율적이라고 생각합니다.</p><h2><span id="무엇을-테스트할-것인가">무엇을 테스트할 것인가?</span></h2><p>일단 Mock 기반 테스트는 단위 테스트 성격이 높습니다. 그렇다면 무엇을 테스트할 것인지 명확하게 테스트해야 합니다. <strong>해당 테스트에서는 원하는 곳으로 Request가 가는지, 우리가 원하는 Reponse가 예상되었을 경우 우리 로직이 제대로 동작하는지 테스트를 진행하겠습니다.</strong></p><h3><span id="request-테스트">Request 테스트</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> name = <span class="string">"team"</span></span><br><span class="line">    server</span><br><span class="line">        .expect(</span><br><span class="line">            requestTo(<span class="string">"http://localhost:8080/teams?name=<span class="variable">$name</span>"</span>)</span><br><span class="line">        )<span class="comment">// (4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> teams = apiService.getTeam(<span class="string">"kotlin"</span>) <span class="comment">// team -&gt; kotlin 으로 이름 변경</span></span><br></pre></td></tr></table></figure><p>MockRestServiceServer에서는 요청을 <code>teams?=name=team</code>으로 했고 실제 apiService에서는 <code>kotlin</code> 을 넘겼기 때문에 두 요청은 일치하지 않습니다. 이 상태에서 테스트 코드를 실행하면 아래와 같은 오류를 발견합니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/moack-api-fail-1.png" alt=""></p><p>즉 실제 apiService 룰 통한 실제 요청과 mock 기반 요청이 일치하는지 확인을 검증하는 것입니다. 파라미터가 name 하나여서 간단하지 조회용 condition이 상당히 복잡합니다. 이런 것들을 케이스 별로 테스트하는 것이 바람직합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">        .expect(</span><br><span class="line">            requestTo(<span class="string">"http://localhost:8080/teams?name=<span class="variable">$name</span>"</span>)</span><br><span class="line">        )<span class="comment">// (4)</span></span><br><span class="line">        .andExpect(method(HttpMethod.POST)) <span class="comment">// (5) GET -&gt; POST 변경</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/moack-api-fail-2.png" alt=""></p><p>이 테스트도 마찬가지로 mock server의 HTTP Method 다르기 때문에 실패하게 됩니다.</p><h3><span id="response-테스트">Response 테스트</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">        ...    </span><br><span class="line">        .andRespond(</span><br><span class="line">            withStatus(HttpStatus.OK)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .body(ClassPathResource(path, javaClass))</span><br><span class="line">        )<span class="comment">// (6)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> teams = apiService.getTeam(<span class="string">"team"</span>)</span><br></pre></td></tr></table></figure><p>Response를 테스트 진행합니다. Response 테스트에서는 RestTemplate에서 전달받은 Response Body가 객체로 변환되는지 테스트합니다.</p><p>위에서 언급했듯이 <code>.body(ClassPathResource(path, javaClass))</code>는 <code>/src/test/resources/</code> path에 있는 해당 json 파일 기반으로 body를 mock 해서 돌려줍니다.</p><p>역 직렬화를 못하게 name을 null으로 변경해보겠습니다. (team name 객체는 notnull입니다.)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"createdAt"</span>: <span class="string">"2020-02-01T16:58:34.377"</span>,</span><br><span class="line">    <span class="attr">"updatedAt"</span>: <span class="string">"2020-02-01T16:58:34.377"</span>,</span><br><span class="line">    <span class="attr">"members"</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/moack-api-fail-3.png" alt=""></p><p>역 직렬화를 못하기 때문에 테스트가 실패하는 것을 확인할 수 있습니다.</p><h2><span id="결론">결론</span></h2><p>RestTemplate 기반으로 테스트하는 방법을 포스팅하긴 했지만 더 <strong>강조하고 싶은 부분은 외부 디펜던시 어떻게 끊고 어떤 부분을 어떤 관점에서 테스트할지 고민해보고 테스트를 작성하는 것이 좋다는 것입니다.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;스프링 프로젝트에서는 외부 API 모듈을 RestTemplate를 이용해서 호출하는 경우가 많습니다, 이런 경우 RestTemplate을 기반으로 Mock 테스트를 보다 쉽게 진행할 수 있습니다.&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;왜-mock-기반
      
    
    </summary>
    
    
      <category term="Test" scheme="https://cheese10yun.github.io/tags/Test/"/>
    
      <category term="RestTemplate" scheme="https://cheese10yun.github.io/tags/RestTemplate/"/>
    
  </entry>
  
  <entry>
    <title>JPA 플러시 정리</title>
    <link href="https://cheese10yun.github.io/jpa-flush/"/>
    <id>https://cheese10yun.github.io/jpa-flush/</id>
    <published>2020-01-28T15:00:00.000Z</published>
    <updated>2020-02-11T14:42:25.161Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://acornpub.co.kr/book/jpa-programmig" rel="external nofollow noopener noreferrer" target="_blank">자바 ORM 표준 JPA 프로그래밍</a>을 보고 플러시 관련 내요을 정리한 정리한 내용 입니다.</p></blockquote><h2><span id="플러시-란">플러시 란?</span></h2><p>JPA는 엔티티를 영속성 컨텍스트에서 관리합니다. 영속성 컨텍스트에 있는 내용을 데이터베이스에 반영하는 것을 플러시라고 합니다. 보통 트랜잭션을 커밋하면 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화(등록, 수정, 삭제) 작업을 진행하게 됩니다.</p><h2><span id="엔티티-등록">엔티티 등록</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EntityMaanger em  = emf.createEnttiyManager();</span><br><span class="line">ENtityTranscation transaction = em.getTransaction();</span><br><span class="line"><span class="comment">// 엔티티 매니저는 데이터 변경 시 트랜잭션을 시작해야한다.</span></span><br><span class="line"></span><br><span class="line">transaction.begin();</span><br><span class="line"></span><br><span class="line">em.persist(memberA);</span><br><span class="line">em.persist(memberB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 여기까지 Insert SQL을 데이터베이스에 보내지 않는다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit을 하는 순간 데이터베이스에 Insert SQL을 보낸다</span></span><br><span class="line">transaction.commit();</span><br></pre></td></tr></table></figure><p>엔티티 <strong>매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모아둔다.</strong> 그리고 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내느데 이것을 <strong>트랜잭션을 지원하는 쓰기 지연</strong> 이라 한다.</p><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/jpa-insert-persistent.png" alt=""><br>회원 A를 영속화 했다. 영속성 컨텍스트는 1차 캐시에 회원 엔티티를 저장하면서 동시에 회원 엔티티 정보로 등록 쿼리를 만든다. 그리고 만들어진 등록 쿼리를 쓰기 지연 SQL 저장소에 보관한다.</p><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/jpa-insert-persistent-2.png" alt=""><br>다음으로 회원 B를 영속화했다. 마찬가지로 회원 엔티티 정보로 등록 쿼리를 생성해서 쓰지 지연 SQL 저장소에 보관한다. 현재 쓰기 지연 SQL저장소 에는 등록 쿼리가 2건이 저장되어 있다.</p><p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/jpa-insert-persistent-3.png" alt=""></p><p>마지막으로 트랜잭션을 커밋했다. <strong>트랜잭션을 커밋하면 엔티티 매니저는 우선 영속성 컨텍스트를 플러시한다. 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업인데 이때 등록, 수정, 삭제한 엔티티를 데이터베이스에 반영한다.</strong></p><p>즉, 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보낸다. 이렇게 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화한 후에 실제 데이터베이스 트랜잭션을 커밋한다.<br>(flush가 먼저 동작하고 (데이터베이스에 동기화한 후에) 실제 데이터베이스 트랜잭션을 커밋한다.)</p><h3><span id="트랜잭션을-지원하는-쓰기-지연이-가능한-이유">트랜잭션을 지원하는 쓰기 지연이 가능한 이유</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin(); <span class="comment">// 트랜잭션 시작</span></span><br><span class="line"></span><br><span class="line">save(A);</span><br><span class="line">save(B);</span><br><span class="line">save(C);</span><br><span class="line"></span><br><span class="line">commit(); <span class="comment">// 트랜잭션 커밋</span></span><br></pre></td></tr></table></figure><ol><li>데이터를 저장하는 즉시 등록 쿼리를 데이터베이스에 보낸다. 예제에서 save() 메서드를 호출할 때 마다 즉시 데이터베이스에 등록 쿼리를 보낸다. 그리고 마지막에 트랜잭션을 커밋한다.</li><li>데이터를 저장하면 등록 쿼리를 <strong>데이터베이스에 보내지 않고 메모리에 모아 둔다.</strong> 그리고 <strong>트랜잭션을 커밋할 때 모아둔 등록 쿼리를 데이터베이스에 보낸다.</strong></li></ol><h3><span id="트랜잭션을-지원하는-쓰지-지연과-성능-최적화">트랜잭션을 지원하는 쓰지 지연과 성능 최적화</span></h3><h4><span id="트랜잭션을-지원하는-쓰지-이연과-jdbc-배치">트랜잭션을 지원하는 쓰지 이연과 JDBC 배치</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert(member1); <span class="comment">// INSERT INTO ...</span></span><br><span class="line">insert(member2); <span class="comment">// INSERT INTO ...</span></span><br><span class="line">insert(member3); <span class="comment">// INSERT INTO ...</span></span><br><span class="line">insert(member4); <span class="comment">// INSERT INTO ...</span></span><br><span class="line">insert(member5); <span class="comment">// INSERT INTO ...</span></span><br><span class="line"></span><br><span class="line">commit();</span><br></pre></td></tr></table></figure><p><strong>네트워크 호출 한번은 단순한 메소드를 수만 번 호출하는 것보다 더 큰 비용이 든다.</strong> 이 코드는 5번의 INSERT SQL과 1번의 커밋으로 총 6번 데이터 베이스와 통신한다. 이것을 최적화하라면 5번의 INSERT SQL을 모아서 한 번에 데이터베이스로 보내면 된다. <strong>JDBC가 제공하는 SQL 배치 기능을 사용하면 SQL을 모아서 데이터베이스에 한 번에 보낼 수 있다.</strong> 하지만 이 기능을 사용하라면 많은 코드를 수정해야한다. <strong>JPA는 플러시 기능이 있이므로 SQL 배치 기능을 효과적으로 사용할 수 있다.</strong></p><p><strong><code>hibernate.jdbc.batch_size</code> 속성의 값을 50으로 주면 최대 50건씩 모아서 SQL 배치를 실행한다. 하지만 SQL 배치는 같은 SQL일 때만 유효하다. 중간에 다른 처리가 들어가면 SQL 배치를 다시 시작한다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">em.persist(<span class="keyword">new</span> Member()); <span class="comment">// 1</span></span><br><span class="line">em.persist(<span class="keyword">new</span> Member()); <span class="comment">// 2</span></span><br><span class="line">em.persist(<span class="keyword">new</span> Member()); <span class="comment">// 3</span></span><br><span class="line">em.persist(<span class="keyword">new</span> Member()); <span class="comment">// 4</span></span><br><span class="line">em.persist(<span class="keyword">new</span> Orders()); <span class="comment">// 1-1, 다른 SQL이 추가 되었기 때문에  SQL 배치를 다시 시작 해야 한다</span></span><br><span class="line">em.persist(<span class="keyword">new</span> Member()); <span class="comment">// 1</span></span><br><span class="line">em.persist(<span class="keyword">new</span> Member()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>1,2,3,4를 모아서 하나의 SQL 배치를 실행하고 1-1를 한 번 실행하고 1,2을 모아서 실행한다. 따라서 총 3번의 SQL 배치를 실행한다.</p><p>모든 경우에 사용할 수 있는 것은 아니다. 엔티티가 영속 상태가 되려면 식별자가 꼭 필요하다. <strong>그런데 IDENTITY 식별자 생성 전략은 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있으므로 em.persist()를 호출하는 즉시 INSERT SQL이 데이터베이스에 전달된다. 따라서 쓰지 지연을 활용한 성능 최적화를 할 수가 없다.</strong></p><h4><span id="트랜잭션을-지원하는-쓰기-지연과-애플리케이션-확장성">트랜잭션을 지원하는 쓰기 지연과 애플리케이션 확장성</span></h4><p><strong>트랜잭션을 지원하는 쓰기 지연의 가장큰 장점은 데이터베이스 테이블 로우에 락이 걸리는 시간을 최소한다는 것이다. 이 기능은 트랜잭션을 커밋해서 영속성 컨텍스트를 플러시하기 전까지는 데이터베이스에 데이터를 등록, 수정, 삭제 하지 않는다. 따라서 커밋 전까지 데이터베이스 로우에 락을 걸지 않는다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update(memberA); <span class="comment">// UPDATE SQL Member A</span></span><br><span class="line">비즈니스로직A(); <span class="comment">// UPDATE SQL ...</span></span><br><span class="line">비즈니스로직B(); <span class="comment">// UPDATE SQL ...</span></span><br><span class="line">commit();</span><br></pre></td></tr></table></figure><p><strong>JPQL를 사용하지 않고 SQL 직접다루면 update(memberA)를 호출할 때 UPDATE SQL을 실행하면 데이터베이스 테이블 로우에 락을 건다. 이 락은 비즈니스 <code>로직A()</code>, <code>비즈니스 로직B()</code>를 모두 수행하고 <code>commit()</code>을 호출할 때까지 유지된다. 트랜잭션 격리 수준에 따라 다르지만 보통 많이 사용하는 커밋된 읽기 Read Committed 격리 수준이나 그 이상에는 데이터베이스에 현재 수정 중인 데이터(로우)를 수정하려는 다른 트랜잭션은 락이 풀릴 때까지 대기한다.</strong></p><p><strong>JPA는 커밋을 해야 플러시를 호출하고 데이터베이스에 수정 쿼리를 보낸다.</strong> 예제에서 <code>commit()</code>을 호출할 때 UPDATE SQL을 실행하고 바로 데이터베이스 트랜잭션을 커밋한다. 쿼리를 보내고 보내고 바로 트랜잭션을 커밋하므로 결과적으로 데이터베이스에 락이 걸리는 시간을 최소화 한다. <strong>이는 동시에 더 많은 트래잭션을 처리할 수 있다는 장점이 된다.</strong></p><h2><span id="엔티티-수정">엔티티 수정</span></h2><h3><span id="변경-감지">변경 감지</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EntityMaanger em  = emf.createEnttiyManager();</span><br><span class="line">ENtityTranscation transaction = em.getTransaction();</span><br><span class="line">transaction.begin(); // 트랜잭션 시작</span><br><span class="line"></span><br><span class="line">// 영성속 텐티티 조회</span><br><span class="line">Member memberA = em.find(Member.class, &quot;memberA&quot;);</span><br><span class="line"></span><br><span class="line">// 영속성 엔티티 데이터 수정</span><br><span class="line"></span><br><span class="line">memberA.setUsername(&quot;hi&quot;);</span><br><span class="line">memberA.setAge(10);</span><br><span class="line"></span><br><span class="line">//em.update(member) 이런 코드가 있어야하지 않을까?</span><br><span class="line"></span><br><span class="line">transaction.commit(); // 트랜잭션 커밋</span><br></pre></td></tr></table></figure><p><strong>엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지(dirty checking) 이라 한다.</strong><br><img src="https://github.com/cheese10yun/TIL/raw/master/assets/jpa-persistent-dirty-checking.png" alt=""><br>JPA는 엔티티를 영속성 컨텍스트에 보관할 때, <strong>최초 상태를 복사해서 저장해두는데 이것을 스냅샷이리고 한다.</strong> 그리고 플러시 시점에서 스냡샵과 엔티티를 비교해서 변경된 엔티티를 찾는다.</p><ol><li><strong>트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시가 호출된다.</strong></li><li>엔티티와 스냅샵을 비교해서 변경된 엔티티를 찾는다.</li><li><strong>변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.</strong></li><li>쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다.</li><li>데이터베이스 트랜잭션을 커밋한다.</li></ol><h3><span id="읽기-전용-트랜잭션">읽기 전용 트랜잭션</span></h3><p>스프링 프레임워크를 사용하면 트랜잭션을 읽기 전용 모드로 설정할 수 있다. <code>@Transactional(readOnly = true)</code> 옵션을 주면 스프링 프레임워크가 하이버네이트 세션의 플러시 모드를 MANUAL로 설정한다 <strong>그렇게되면 강제로 플러시를 호출하지 않은 한 플러시가 일어나지 않는다.</strong> 따라서 트랜잭션을 커밋해도 영속성 컨텍스트 플러시하지 않는다. 영속성 컨텍스트를 플러시하지 않으니 엔티티의 등록, 수정, 삭제는 당연히 동작하지 않는다. <strong>플러시 할 때 일어나는 스냅샷비교와 같은 무거운 로직을 수행하지 않으므로 성능에 향상된다.</strong></p><p><strong>변경 감지는 영속성 컨텍스타 관리하는 영속 상태의 엔티티에만 적용된다.</strong> 비영속, 준영속처럼 영속성 컨텍스트의 관리를받지 못하는 엔티티는 값을 변경해도 데이터베이스에 반영되지 않는다.</p><h2><span id="엔티티-삭제">엔티티 삭제</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Member meberA = em.find(Member.class, <span class="string">"memberA"</span>); <span class="comment">// 삭제할 대상 엔티티 조회</span></span><br><span class="line">em.remove(memberA); <span class="comment">// 엔티티 삭제</span></span><br></pre></td></tr></table></figure><p><strong>엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야한다.</strong> em.remove()에 삭제 대상 엔티티를 넘겨주면 엔티티를 삭제한다. 물론 엔티티를 즉시 삭제하는 것이 아니라 엔티티 등록과 비슷하게 삭제 쿼리를 쓰기 지연 데이터베이스에 삭제 쿼리를 전달한다.</p><h2><span id="영속성-컨텍스트를-플러시-하는-3-가지-방법">영속성 컨텍스트를 플러시 하는 3 가지 방법</span></h2><p><strong>플러시는 영속성 컨텍스의 변경 내용을 데이터베이스에 반영한다.</strong> 플러시를 실행하면 구체적으로 다음과 같은 일이 일어난다</p><ol><li>변경 감자기 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교 해서 수정된 엔티티를 찾는다. 수정 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 등록한다.</li><li>쓰기 지연 SQL 의 저장소의 쿼리를 데이터베이스에 전송한다. (등록, 수정, 삭제 쿼리)</li></ol><p>영속성 컨텍스트를 플러시 하는 방법은 3가지다.</p><ol><li>em.flush()를 직접 호출한다.</li><li>JPQL 쿼리 실행 시 플러시가 자동 호출된다.</li><li>트랜잭션 커밋 시 플러시가 자동 호출된다.</li></ol><h3><span id="플러시를-직접-호출하는-경우">플러시를 직접 호출하는 경우</span></h3><p>엔티티 매니저의 flush() 메서드를 직접 호출해서 영속성 컨텍스트를 강제로 플러시 한다. <strong>테스트나 다른 프레임워크와 JPA 함께 사용할 때는 제외하고 거의 사용하지 않는다.</strong></p><h3><span id="트랜잭션-커밋-시-플러시가-자동-호출">트랜잭션 커밋 시 플러시가 자동 호출</span></h3><p><strong>데이터베이스에 변경 내용을 SQL로 전달하지 않고 트랜잭션만 커밋하면 어떤 데이터도 데이터베이스에 반영되지 않는다. 따라서 트랜잭션을 커밋하기 전에 꼭 플러시를 호출해서 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영해야 한다.</strong> JPA는 이런 문제를 예방하기 위해서 트랜잭션 커밋할 때 플러시를 자동으로 호출한다.</p><h3><span id="jpql-쿼리-실행시-플러시-자동-호출">JPQL 쿼리 실행시 플러시 자동 호출</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `JPQL 쿼리 실행시 플러시 자동 호출`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> teamA = Team(<span class="string">"teamA"</span>)</span><br><span class="line">    <span class="keyword">val</span> teamB = Team(<span class="string">"teamB"</span>)</span><br><span class="line"></span><br><span class="line">    em.persist(teamA)</span><br><span class="line">    em.persist(teamB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> teams = query.select(qTeam)</span><br><span class="line">            .from(qTeam)</span><br><span class="line">            .fetch()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (team <span class="keyword">in</span> teams) &#123;</span><br><span class="line">        println(<span class="string">"team : <span class="variable">$team</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JPQL이나 QueryDSL 같은 객체지향 <strong>쿼리를 호출할 플러시가 실행된다.</strong></p><ol><li><code>teamA</code>, <code>teamB</code>를 영속성 컨텍스트에 저장한다.</li><li>QueryDSL으로 Team 전체를 조회 한다.</li><li>QueryDSL 쿼리 시점에 <code>teamA</code>, <code>teamB</code> 플러시를 이르켜 데이터베이스에 commit하지 않았다면 QueryDsl으로 조회한 값은 없을 것이다.</li></ol><p>이런 결과가 나오기 때문에 쿼리를 실행하기 직전에 영속성 컨텍스트를 플러시해서 변경 내용을 데이터베이스에 반영해야 한다. JPA는 이런 문제를 예방하기 위해서 JPQL을 실행할 때도 플러시르 자동 호출한다. <strong>참고로 식별자를 기준으로 조회하는 find() 메서드는 호출되지 않는다.</strong></p><h2><span id="참고">참고</span></h2><ul><li><a href="http://acornpub.co.kr/book/jpa-programmig" rel="external nofollow noopener noreferrer" target="_blank">자바 ORM 표준 JPA 프로그래밍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://acornpub.co.kr/book/jpa-programmig&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;자바 ORM 표준 JP
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
      <category term="Flush" scheme="https://cheese10yun.github.io/tags/Flush/"/>
    
  </entry>
  
  <entry>
    <title>JPA 영속성 컨텍스트 주의 점</title>
    <link href="https://cheese10yun.github.io/jpa-persistent-context/"/>
    <id>https://cheese10yun.github.io/jpa-persistent-context/</id>
    <published>2020-01-26T15:00:00.000Z</published>
    <updated>2020-01-28T13:43:23.224Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="엔티티-객체">엔티티 객체</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"member"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>(</span><br><span class="line">        <span class="meta">@Column(name = <span class="meta-string">"username"</span>, nullable = false)</span></span><br><span class="line">        <span class="keyword">var</span> username: String,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Column(name = <span class="meta-string">"age"</span>, nullable = false)</span></span><br><span class="line">        <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ManyToOne(fetch = FetchType.LAZY, optional = false)</span></span><br><span class="line">        <span class="meta">@JoinColumn(name = <span class="meta-string">"team_id"</span>, nullable = false)</span></span><br><span class="line">        <span class="keyword">var</span> team: Team</span><br><span class="line">) : EntityAuditing()</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"team"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span></span>(</span><br><span class="line">        <span class="meta">@Column(name = <span class="meta-string">"name"</span>, nullable = false)</span></span><br><span class="line">        <span class="keyword">var</span> name: String</span><br><span class="line">) : EntityAuditing() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="meta-string">"team"</span>)</span></span><br><span class="line">    <span class="keyword">var</span> members: MutableList&lt;Member&gt; = mutableListOf()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엔티티 관계는 위와 같습니다.</p><h2><span id="테스트-코드">테스트 코드</span></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.querydsl.domain.QMember.member <span class="keyword">as</span> qMember</span><br><span class="line"><span class="keyword">import</span> com.example.querydsl.domain.QTeam.team <span class="keyword">as</span> qTeam</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersistenceContextTest</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> em: EntityManager</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> query = JPAQueryFactory(em)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `persistence context test`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">val</span> teamA = Team(<span class="string">"teamA"</span>)</span><br><span class="line">        em.persist(teamA)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> member1 = Member(username = <span class="string">"member1"</span>, age = <span class="number">10</span>, team = teamA)</span><br><span class="line">        <span class="keyword">val</span> member2 = Member(username = <span class="string">"member2"</span>, age = <span class="number">20</span>, team = teamA)</span><br><span class="line">        em.persist(member1)</span><br><span class="line">        em.persist(member2)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="keyword">val</span> team = query</span><br><span class="line">                .selectFrom(qTeam)</span><br><span class="line">                .join(qTeam.members, qMember).fetchJoin()</span><br><span class="line">                .where(qTeam.name.eq(<span class="string">"teamA"</span>))</span><br><span class="line">                .fetchOne()!!</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        <span class="keyword">val</span> members = team.members</span><br><span class="line">        then(members).anySatisfy &#123;</span><br><span class="line">            then(it.username).isIn(<span class="string">"member1"</span>, <span class="string">"member2"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>teamA</code>를 영속화 이후, <code>member1</code>, <code>member2</code>를 영속화를 진행합니다. <code>member1</code>, <code>member2</code>는 <code>teamA</code> 소속이 됩니다.</p><p>그리고 <code>fetch join</code>통해서 <code>teamA</code>와 <code>teamA</code>에 속한 <code>member</code>를 조회하고 있습니다. 그리고 <code>then</code>절에서 <code>member1</code>, <code>member2</code>가 <code>teamA</code>에 있는지 검증을 진행합니다.</p><p><strong>이 테스트 코드는 실패합니다.</strong></p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/team-members-result.png" alt=""></p><p>디버깅 모드로 보면 <code>memebers</code> szie가 0인 것을 확인할 수 있습니다. 그렇다면 실제 데이터베이에 <code>member1</code>, <code>member2</code>가 영속화가 안 된 것일 까요?</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/insert-result.png" alt=""></p><p><code>teamA</code> insert, <code>member1</code>, <code>memeber2</code> insert 쿼리를 확인할 수 있습니다. 물론 insert query log를 출력했더라도 실제 데이터베이스에 insert 됐다고는 볼 수 없습니다. <strong>정확하게 테스트하기 위해서는 실제 데이터베이스에 저장됐는지 확인하는 것이 바람직합니다.</strong> 해당 경우는 실제 데이터베이스에 commit까지 되는 경우입니다.</p><p>그렇다면 왜 해당 테스트 코드가 실패할까요? 그 이유를 알기 위해서는 영속성 컨텍스트의 1차 케시의 저장 메커니즘을 이해해야 합니다.</p><h2><span id="영속성-컨텍스트-1차-캐시-저장-메커니즘">영속성 컨텍스트 1차 캐시 저장 메커니즘</span></h2><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/query-result-.png" alt=""></p><p><code>findById()</code> 같은 경우는 영속성 컨텍스트를 먼저 찾고 영속성 컨텍스트에 해당 엔티티가 있으면 그 값을 바로 리턴합니다. 이를 1차 캐시라고 말합니다. <strong>반면 JPQL은 영속성성 컨텍스트를 먼저 조회하지 않고 데이터베이스에 query하여 결과를 가져옵니다.</strong> 그리고 아래와 같은 흐름으로 영속성 컨텍스트를 저장을 시도합니다.</p><ol><li><strong>JPQL을 호출하면 데이터베이스에 우선적으로 조회한다.</strong></li><li>조회한 값을 영속성 컨텍스트에 저장을 시도한다.</li><li><strong>저장을 시도할 때 해당 데이터가 이미 영속성 컨텍스트에 존재하는 경우((영속성 컨텍스트에서는 식별자 값으로 식별)) 데이터베이스에서 조회한 신규 데이터를 버린다.</strong></li></ol><h2><span id="테스트가-실패하는-이유">테스트가 실패하는 이유</span></h2><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/query-dsl/docs/images/query-result-.png" alt=""></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `persistence context test`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    <span class="keyword">val</span> teamA = Team(<span class="string">"teamA"</span>)</span><br><span class="line">    em.persist(teamA)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> member1 = Member(username = <span class="string">"member1"</span>, age = <span class="number">10</span>, team = teamA)</span><br><span class="line">    <span class="keyword">val</span> member2 = Member(username = <span class="string">"member2"</span>, age = <span class="number">20</span>, team = teamA)</span><br><span class="line">    em.persist(member1)</span><br><span class="line">    em.persist(member2)</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>teamA</code>, <code>member1</code>, <code>member2</code> 영속화를 진행합니다. 이때 위 그림처럼 영속성 컨텍스트에 저장됩니다.</p><p>그리고 아래 코드의 <code>when</code> 절을 보겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//when</span></span><br><span class="line"><span class="keyword">val</span> team = query</span><br><span class="line">        .selectFrom(qTeam)</span><br><span class="line">        .join(qTeam.members, qMember).fetchJoin()</span><br><span class="line">        .where(qTeam.name.eq(<span class="string">"teamA"</span>))</span><br><span class="line">        .fetchOne()!!</span><br></pre></td></tr></table></figure><p>위에서 언급했던 것처럼 JPQL은 영속성 컨텍스트의 데이터를 조회하지 않고 <strong>데이터베이스에 아래의 query를 진행합니다.</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    team0_.id <span class="keyword">as</span> id1_2_0_,</span><br><span class="line">    members1_.id <span class="keyword">as</span> id1_1_1_,</span><br><span class="line">    team0_.created_at <span class="keyword">as</span> created_2_2_0_,</span><br><span class="line">    team0_.updated_at <span class="keyword">as</span> updated_3_2_0_,</span><br><span class="line">    team0_.name <span class="keyword">as</span> name4_2_0_,</span><br><span class="line">    members1_.created_at <span class="keyword">as</span> created_2_1_1_,</span><br><span class="line">    members1_.updated_at <span class="keyword">as</span> updated_3_1_1_,</span><br><span class="line">    members1_.age <span class="keyword">as</span> age4_1_1_,</span><br><span class="line">    members1_.team_id <span class="keyword">as</span> team_id6_1_1_,</span><br><span class="line">    members1_.username <span class="keyword">as</span> username5_1_1_,</span><br><span class="line">    members1_.team_id <span class="keyword">as</span> team_id6_1_0__,</span><br><span class="line">    members1_.id <span class="keyword">as</span> id1_1_0__ </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    team team0_ </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">member</span> members1_ </span><br><span class="line">        <span class="keyword">on</span> team0_.id=members1_.team_id </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    team0_.name=?</span><br></pre></td></tr></table></figure><p><code>fetch join</code>를 사용했기 때문에 <code>team</code>, <code>member</code> 객체를 한번에 가져오게 됩니다. <strong>하지만 <code>teamA</code>가 이미 존재 하므로 해당 쿼리를 통해서 가져온 데이터를 버리게 됩니다.</strong></p><h2><span id="해결-하는-방법">해결 하는 방법</span></h2><h3><span id="team-객체에-member-추가하기">Team 객체에 Member 추가하기</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `persistence context test`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    <span class="keyword">val</span> teamA = Team(<span class="string">"teamA"</span>)</span><br><span class="line">    em.persist(teamA)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> member1 = Member(username = <span class="string">"member1"</span>, age = <span class="number">10</span>, team = teamA)</span><br><span class="line">    <span class="keyword">val</span> member2 = Member(username = <span class="string">"member2"</span>, age = <span class="number">20</span>, team = teamA)</span><br><span class="line">    em.persist(member1)</span><br><span class="line">    em.persist(member2)</span><br><span class="line"></span><br><span class="line">    teamA.members.add(member1) <span class="comment">// teamA에 member1 추가</span></span><br><span class="line">    teamA.members.add(member2) <span class="comment">// teamA에 member2 추가</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>member1</code>, <code>member2</code>영속화 이후 <code>teamA</code> 객체에 영속화된 member 객체를 추가하는 코드를 작성하면 됩니다.</p><p>그렇게 되면 <code>fetch join</code>을 통해서 데이터베이스에 query를 진행하고 해당 데이터가 영속성 컨텍스트에 이미 있으므로 <strong>데이터를 버리게 되더라도 이미 <code>member1</code>, <code>memeber2</code>가 존재하는 상태이기 때문에 문제가 되지 않습니다.</strong></p><p>양방향 연관 관계의 경우 편의 메서드를 작성해서 이런 문제를 미연에 방지하는 것이 좋습니다. 물론 필요에 따라서 양방향 양방향 연관 관계를 작성하는 것은 상관없지만 <strong>가능하면 단방향 연관 관계를 유지하는 것이 좋다고 생각합니다.</strong></p><p>양방향 관계가 되면 생각보다 신경 쓸 것이 많아지게 되어 복잡도가 증가하게 됩니다. 또 <code>OneToMany</code>, <code>ManyToOne</code> 같은 양방향 연관 관계의 경우 N+1 문제도 신경 쓸 것들이 많아지게 됩니다.</p><h3><span id="영속성-컨텍스트-초기화">영속성 컨텍스트 초기화</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `persistence context test`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    <span class="keyword">val</span> teamA = Team(<span class="string">"teamA"</span>)</span><br><span class="line">    em.persist(teamA)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> member1 = Member(username = <span class="string">"member1"</span>, age = <span class="number">10</span>, team = teamA)</span><br><span class="line">    <span class="keyword">val</span> member2 = Member(username = <span class="string">"member2"</span>, age = <span class="number">20</span>, team = teamA)</span><br><span class="line">    em.persist(member1)</span><br><span class="line">    em.persist(member2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//        teamA.members.add(member1)</span></span><br><span class="line"><span class="comment">//        teamA.members.add(member2)</span></span><br><span class="line">    </span><br><span class="line">    em.flush()</span><br><span class="line">    em.clear()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>em.flush()</code>을 통해서 영속성 컨텍스트의 내용을 데이터베이스에 반영하고 <strong><code>em.clear()</code>을 통해서 영속성 컨텍스트를 모두 초기화 합니다.(영속성 컨텍스트의 데이터를 모두 제거)</strong> 영속성 컨텍스츠가 초기화 되었기 때문에 <code>fetch join</code>의 결과가 모두 영속성 컨텍스트의 반영됩니다.</p><h2><span id="결론">결론</span></h2><p>테스트 코드를 작성할 때 이런 점을 조심하자는 것이 중점은 아닙니다. 중점으로 다루고 싶었던 내용은 영속성 컨텍스트의 저장에 대한 메커니즘입니다. 이 부분은 명확하게 알고 있더라도 영속성 컨텍스트는 실제 보이는 영역이 아니기 때문에 실수하기 좋고  이런 실수를 하더라도 이것을 바로 캐치하기가 어렵습니다. 그래서 정리차 포스팅을 진행하게 되었습니다.</p><h2><span id="참고">참고</span></h2><ul><li><a href="http://acornpub.co.kr/book/jpa-programmig" rel="external nofollow noopener noreferrer" target="_blank">자바 ORM 표준 JPA 프로그래밍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;엔티티-객체&quot;&gt;엔티티 객체&lt;/span&gt;&lt;/h2&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://cheese10yun.github.io/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>스프링 Application Event</title>
    <link href="https://cheese10yun.github.io/application-event/"/>
    <id>https://cheese10yun.github.io/application-event/</id>
    <published>2019-11-29T15:00:00.000Z</published>
    <updated>2020-02-29T12:57:10.568Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/application-event" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인할 수 있습니다.</p></blockquote><p>스프링에서는 Application Event를 제공해주고 있습니다. <code>Application Event Publisher</code>, <code>Application Event Subscriber</code> 방식으로 결합도를 낮춰 느슨한 결합 관계를 갖을 수 있습니다.</p><h2><span id="시나리오">시나리오</span></h2><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/event-part-1.png?raw=true" alt=""></p><p>주문 단계에 (주문, 결제)가 완료되면 주문 완료 이후 로직들이 동작해야 합니다. 대표적으로</p><ul><li>장바구니 제거 (장바구니에 등록된 상품 주문시)</li><li>제품 재고 변경</li><li>주문 완료 알람 (시스템, 유저 등등)</li></ul><p>주문 완료 이후 매우 다양한 작업들이 있고 해당 로직들이 <code>OrderService</code>에 모두 구현하는 경우 <strong>강한 결합 관계</strong>를 갖게 되고 변경 및 유지보수에 악영향이 발생하게 됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderService</span></span>(</span><br><span class="line">        ... <span class="comment">// 필요한 의존성 주입, 강한 관계를 갖는 경우 필요한 의존성 들이 많아진다.</span></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">order</span><span class="params">()</span></span>: Order &#123;</span><br><span class="line">        orderRepository.save(order) <span class="comment">// 주문 저장</span></span><br><span class="line">        stockService.adjust(order) <span class="comment">// 재고 조정</span></span><br><span class="line">        cartService.remove(order) <span class="comment">// 장바구니 제거 (장바구니 상품중 주문 완료된 상품 제거)</span></span><br><span class="line">        <span class="keyword">return</span> order</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>OrderService</code> 객체에 의존성 주입받아야 하는 항목들이 많아지는 것이 대표적인 외부와 결합관계를 갖게 되는 대표적인 신호입니다. 주문, 주문 완료 이후 로직이 추가될 때마다 <code>OrderService</code>의 변경이 야기됩니다. 이런 문제를 <code>Application Event</code>으로 쉽게 해결 할 수 있습니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/event-part-2.png?raw=true" alt=""></p><p><code>주문-결제</code> 이후 결제 완료 이벤트를 발생시키고 주문 완료 이후 로직들은 <code>Application Event Subscriber</code>에서 구현하게 작성하는 구조를 갖을 수 있습니다. 그렇게 되면 <code>OrderService</code>에 필요 의존성이 줄게 되고 자연스럽게 해당 서비스의 책임이 작아지게 되며 이벤트에 의해 느슨한 결합관계를 갖게 됩니다.</p><h2><span id="구현">구현</span></h2><p>주문 완료 이후 구매한 제품중 장바구니에 있는 제품을 제거 하는 로직을 구현 했습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderService</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> orderRepository: OrderRepository,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> itemRepository: ItemRepository,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> eventPublisher: ApplicationEventPublisher</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">order</span><span class="params">(itemCode: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: Order &#123;</span><br><span class="line">        <span class="keyword">val</span> items = itemRepository.findByCodeIn(itemCode) <span class="comment">// 상품(Item) 조회</span></span><br><span class="line">        <span class="keyword">val</span> orderItems: MutableList&lt;OrderItem&gt; = mutableListOf()</span><br><span class="line">        items.mapTo(orderItems) &#123; OrderItem(it.code, it.price, it.name) &#125;</span><br><span class="line">        <span class="keyword">val</span> order = orderRepository.save(Order(orderItems))</span><br><span class="line">        eventPublisher.publishEvent(OrderCompletedEvent(itemCode)) <span class="comment">// 주문 완료 이벤트 발생, 주문한 아이템 code 전송</span></span><br><span class="line">        <span class="keyword">return</span> order</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>요청 받은 상품(Item)를 주문 하고, 주문 완료 event를 발생시키게 됩니다. 장바구니 제거 관련 코드는 존재하지 않고 주문 완료 이벤트만 발생시킵니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderEventHandler</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> cartRepository: CartRepository</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">orderEventHandler</span><span class="params">(event: <span class="type">OrderCompletedEvent</span>)</span></span> &#123;</span><br><span class="line">        cartRepository.deleteAllByCodes(codes = event.itemCodes)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이벤트 리스너를 담당합니다. 주문 완료 이벤트가 발생하면 해당 리스너가 동작하게 되고 장바구니에서 주문 상품들을 제거하는 코드입니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/application-event&quot; rel=&quot;external nofollow noopener no
      
    
    </summary>
    
    
      <category term="트랜잭션" scheme="https://cheese10yun.github.io/tags/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"/>
    
  </entry>
  
  <entry>
    <title>스프링 트랜잭션 단위</title>
    <link href="https://cheese10yun.github.io/transacion-group/"/>
    <id>https://cheese10yun.github.io/transacion-group/</id>
    <published>2019-11-22T15:00:00.000Z</published>
    <updated>2019-11-30T15:03:24.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/kotlin-junit5" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인할 수 있습니다.</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/sample"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleController</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> aRepository: ARepository,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> bRepository: BRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transaction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        aRepository.save(A(<span class="string">"A"</span>))</span><br><span class="line">        bRepository.save(B(<span class="string">"B"</span>)) <span class="comment">// 여기에서 exception 발생시 위 save는 Rollback 되지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bRepository.save(B(&quot;B&quot;))</code> 에서 예외가 발생했을 경우 트랜잭션 단위는 클라스 단위로 지정되기 때문에 <code>aRepository.save(A(&quot;A&quot;))</code> Rollback 되지 않습니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/transacion-proxy.png?raw=true" alt=""></p><p>스프링 부트에서는 기본적으로 CGLIB Proxy 방식으로 트랜잭션을 처리합니다. (이전에는  Dynamic Proxy 패턴) Proxy 패턴을 사용하기 때문에 클래스 단위로 트랜잭션이 시작되고 묶이게 됩니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/transacion-group.png?raw=true" alt=""></p><p>트랜잭션 단위를 보면 위와 같습니다. Proxy 방식이기 때문에 클래스 단위로 묶이게 됩니다. 그렇가면 JPA Repository는 interface인데 어떻게 트랜잭션이 발생하게 되는지 의문을 갖는 분들도 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ARepository</span> : <span class="type">JpaRepository</span>&lt;<span class="type">A, Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/jpa-simple-repository.png?raw=true" alt=""></p><p><code>JpaRepository</code> 인터페이스의 세부 구현체가 <code>SimpleJpaRepository</code>가 있습니다. 세부 코드를 보면 아래와 같습니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/jpa-simple-repository-save.png?raw=true" alt=""></p><p><code>save()</code> 메서드에 <code>@Transactional</code>이 있고 여기에서 트랜잭션이 동작하게 됩니다. 다시 본론으로 돌아와서 아래 그림처럼 트랜잭션 그룹이 다르기 때문에 commit, rollback 기준도 클래스를 기반으로 나뉘게 됩니다.</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/transacion-group.png?raw=true" alt=""></p><p>그렇다면 위 두 개의 트랜잭션을 묶을려면 어떻게 해야할까요? 답은 간단합니다 이 두개를 묶는 트랜잭션을 설정하면 됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/sample"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleController</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> aRepository: ARepository,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> bRepository: BRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// aRepository, bRepository 트랜잭션을 묶는다.</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">transaction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        aRepository.save(A(<span class="string">"A"</span>))</span><br><span class="line">        bRepository.save(B(<span class="string">"B"</span>)) <span class="comment">// 여기에서 exception 발생시 위 save는 Rollback 된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Transactional</code>을 추가하게 되면 <code>aRepository, bRepository</code> 트랜잭션이 같이 묶이게 됩니다.(물론 컨트롤러에 추가하는 것보다 별도의 트랜잭션를 담당하는 Service 영역을 추가하는 것이 바람직합니다.)</p><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/transacion-group-2.png?raw=true" alt=""></p><p>이렇게 되면 두 트랜잭션이 같이 묶이게 되고 <code>bRepository.save(B(&quot;B&quot;))</code> 에서 exception이 발생하게 되면 <code>bRepository.save(B(&quot;B&quot;))</code>, <code>aRepository.save(A(&quot;A&quot;))</code>이 모두 rollback이 진행됩니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/kotlin-junit5&quot; rel=&quot;external nofollow noopener norefe
      
    
    </summary>
    
    
      <category term="트랜잭션" scheme="https://cheese10yun.github.io/tags/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"/>
    
  </entry>
  
  <entry>
    <title>스프링 Immutable으로 Properties 설정하기</title>
    <link href="https://cheese10yun.github.io/immutable-properties/"/>
    <id>https://cheese10yun.github.io/immutable-properties/</id>
    <published>2019-11-19T15:00:00.000Z</published>
    <updated>2019-11-23T12:58:15.029Z</updated>
    
    <content type="html"><![CDATA[<p><strong>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/kotlin-junit5" rel="external nofollow noopener noreferrer" target="_blank">Github</a>에 공개되어 있습니다.</strong></p><p>Spring Boot 2.2 버전에서부터는 Immutable으로 Properties 설정을 할 수 있습니다. 커스텀 하게 설정한 값들은 Properties 객체로 관리하는 것이 좋습니다. 해당 내용은 <a href="https://github.com/cheese10yun/spring-jpa-best-practices/blob/master/doc/step-10.md" rel="external nofollow noopener noreferrer" target="_blank">Properties 설정값 가져오기</a>를 참조하시면 됩니다. 기존 Properties의 단점은 Mutable이라는 점입니다. 아래 예제 코드에서 설명드리겠습니다.</p><h2><span id="기존-mutable-properties-방법">기존 Mutable Properties 방법</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleProperties</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> auth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter, setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>기존 방식은 위처럼 setter 기반으로 바인딩 되기 때문에 해당 Properties 설정은 언제든지 변경될 가능성이 있습니다.</strong> 이런 단점을 스프링 부트 2.2에서는 생성자 바인딩을 지원해서 해결했습니다.</p><h2><span id="immutable-properties-방법">Immutable Properties 방법</span></h2><p>해당 예제는 Kotlin <code>data class</code> 기준으로 작성했습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = <span class="meta-string">"user"</span>)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProperties</span></span>(</span><br><span class="line">        <span class="meta">@field:Email</span></span><br><span class="line">        <span class="keyword">val</span> email: String,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@field:NotEmpty</span></span><br><span class="line">        <span class="keyword">val</span> nickname: String,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@field:Min</span>(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">val</span> age: <span class="built_in">Int</span>,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@field:NotNull</span></span><br><span class="line">        <span class="keyword">val</span> auth: <span class="built_in">Boolean</span>,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@field:Min</span>(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">val</span> amount: <span class="built_in">Double</span>,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@DateTimeFormat(pattern = <span class="meta-string">"yyyy-MM-dd"</span>)</span></span><br><span class="line">        <span class="meta">@field:NotNull</span></span><br><span class="line">        <span class="keyword">val</span> date: LocalDate</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>사용법은 간단합니다. <code>@ConstructorBinding</code>을 추가하고 <code>data class</code>으로 넘겨받을 값을 생성자로 지정합니다. 위처럼 작성하면 객체는 Immutable 상태가 됩니다. <strong>스프링 부트 2.2.1 버전부터는 <code>@ConfigurationProperties</code> scanning 방식이 disabled 되면서 <code>@EnableConfigurationProperties</code>을 따로 지정해야 합니다. 자세한 내용은 <a href="https://github.com/spring-projects/spring-boot/issues/18674" rel="external nofollow noopener noreferrer" target="_blank">여기</a>를 참고하세요.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(UserProperties::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinJunit5Application</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;KotlinJunit5Application&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2.1 버전 부터는 <code>@EnableConfigurationProperties</code>으로 클래스를 지정해야합니다. <code>@Validated</code> 어노테이션으로 properteis에 대한 검증도 가능합니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">  email:</span> <span class="string">"yuntest.com"</span></span><br><span class="line"><span class="attr">  nickname:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">  auth:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  amount:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  date:</span> <span class="string">"2019-10-10"</span></span><br></pre></td></tr></table></figure><p>위 처럼 유효하지 않은 값들에 대해서 아래 화면처럼 검증할 수 있습니다.</p><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/kotlin-junit5//img/error-img.png" alt=""></p><p>스프링 부트가 구동될 때 해당 값에 대한 유효성 검사를 어노테이션 기반으로 쉽게 검증할 수 있습니다. <strong>해당 값이 유효하지 않은 경우 스프링이 구동되지 않기 때문에 장점이 있습니다.</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">  email:</span> <span class="string">"yun@test.com"</span></span><br><span class="line"><span class="attr">  nickname:</span> <span class="string">"yun"</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">28</span></span><br><span class="line"><span class="attr">  auth:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  amount:</span> <span class="number">101</span></span><br><span class="line"><span class="attr">  date:</span> <span class="string">"2019-10-10"</span></span><br></pre></td></tr></table></figure><p>위 <code>yml</code> 처럼 유효한 값을 입력하면 정상적으로 동작하는 것을 확인할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppRunner</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> userProperties: UserProperties) :ApplicationRunner&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">(args: <span class="type">ApplicationArguments</span>?)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"====================="</span>)</span><br><span class="line">        println(userProperties.toString())</span><br><span class="line">        println(<span class="string">"====================="</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/kotlin-junit5//img/properteis-result.png" alt=""><br>값들이 유요한 경우 객체에 바인딩 되는 것을 학인할 수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/kotlin-junit5&quot; rel=&quot;external nofollow noopener noreferrer&quot;
      
    
    </summary>
    
    
      <category term="properties" scheme="https://cheese10yun.github.io/tags/properties/"/>
    
  </entry>
  
  <entry>
    <title>Junit5 with Spring boot</title>
    <link href="https://cheese10yun.github.io/junit5-in-spring/"/>
    <id>https://cheese10yun.github.io/junit5-in-spring/</id>
    <published>2019-11-03T09:11:20.000Z</published>
    <updated>2019-11-04T12:56:30.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>해당 코드는 <a href="https://github.com/cheese10yun/blog-sample/tree/master/kotlin-junit5" rel="external nofollow noopener noreferrer" target="_blank">Github</a>를 확인해주세요.</p></blockquote><p>Spring boot 2.2 버전부터는 Junit5 디펜던시를 기본으로 포함하고 있습니다. Junit5 주요 테스트 어노테이션과 Spring boot에서 활용법을 정리해보았습니다.</p><h2><span id="valuesource">@ValueSource</span></h2><p><code>@ValueSource</code>어노테이션을 사용하면 배열을 값을 테스트 메서드로 손쉽게 전달할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(strings = [<span class="meta-string">""</span>, <span class="meta-string">" "</span>])</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `isBlank `<span class="params">(value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    print(<span class="string">"value: <span class="variable">$value</span> "</span>) <span class="comment">// value:  value:</span></span><br><span class="line">    assertThat(value.isBlank()).isTrue()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = [1, 2, 3, 4])</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `ints values`<span class="params">(value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    print(<span class="string">"value: <span class="variable">$value</span> "</span>) <span class="comment">// value: 1 value: 2 value: 3 value: 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Int, String 이 이외에도 기본형 데이터 타입을 지원하고 있습니다.</p><h2><span id="enumsource">EnumSource</span></h2><p><code>@EnumSource</code> 어노테이션을 통해서 Enum을 효율적으로 테스트 할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Quarter</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>, <span class="keyword">val</span> description: String) &#123;</span><br><span class="line">    Q1(<span class="number">1</span>, <span class="string">"1분기"</span>),</span><br><span class="line">    Q2(<span class="number">2</span>, <span class="string">"2분기"</span>),</span><br><span class="line">    Q3(<span class="number">3</span>, <span class="string">"3분기"</span>),</span><br><span class="line">    Q4(<span class="number">4</span>, <span class="string">"4분기"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 분기를 뜻하는 Enum을 위와 같이 정리했습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@EnumSource(Quarter::class)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `분기의  value 값은 1 ~ 4 값이다`<span class="params">(quarter: <span class="type">Quarter</span>)</span></span> &#123;</span><br><span class="line">    println(quarter.name) <span class="comment">// quarter: Q1 quarter: Q2 quarter: Q3 quarter: Q4</span></span><br><span class="line">    assertThat(quarter.value <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span>).isTrue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enum에 정의된 모든 값들을 출력하는 것을 확인할 수 있습니다. <code>@EnumSource</code>을 사용하면 모든 enum을 iterator 하기 편리합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@EnumSource(value = Quarter::class, names = [<span class="meta-string">"Q1"</span>, <span class="meta-string">"Q2"</span>])</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `names을 통해서 특정 <span class="keyword">enum</span> 값만 가져올 수 있다`<span class="params">(quarter: <span class="type">Quarter</span>)</span></span> &#123;</span><br><span class="line">    print(<span class="string">"<span class="subst">$&#123;quarter.name&#125;</span> "</span>) <span class="comment">// quarter: Q1 quarter: Q2</span></span><br><span class="line">    assertThat(quarter.value <span class="keyword">in</span> <span class="number">1.</span><span class="number">.2</span>).isTrue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>특정 enum을 지정해서 가져오고 싶은 경우 <code>names = [&quot;Q1&quot;, &quot;Q2&quot;]</code>을 사용하면 됩니다.</p><h2><span id="csvsource">@CsvSource</span></h2><p><code>@CsvSource</code> 어노테이션을 통해서 CSV 포멧으로 테스팅을 편리하게 진행 할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"010-1234-1234,01012341234"</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"010-2333-2333,01023332333"</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">"02-223-1232,022231232"</span></span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `전화번호는 '-'를 제거한다`<span class="params">(value: <span class="type">String</span>, expected: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> valueReplace = value.replace(<span class="string">"-"</span>, <span class="string">""</span>)</span><br><span class="line">    assertThat(valueReplace).isEqualTo(expected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>,</code> 단위로 테스트 메서드의 매개변수로 값을 넘길 수 있습니다.</p><h2><span id="methodsource">@MethodSource</span></h2><p><code>@MethodSource</code> 어노테이션을 통해서 복잡한 객체를 보다 쉽게 생성하고 테스트할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Amount</span></span>(</span><br><span class="line">        <span class="keyword">val</span> price: <span class="built_in">Int</span>,</span><br><span class="line">        <span class="keyword">val</span> ea: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> totalPrice: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = price * ea</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>가격과 수량을 입력하면 totalPrice 계산하는 단순한 객체 입니다. 해당 객체를 <code>@MethodSource</code>를 통해서 테스트를 진행해 보겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource(<span class="meta-string">"providerAmount"</span>)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `amount total price 테스트 `<span class="params">(amount: <span class="type">Amount</span>, expectedTotalPrice: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    assertThat(amount.totalPrice).isEqualTo(expectedTotalPrice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerAmount</span><span class="params">()</span></span> = listOf(</span><br><span class="line">            Arguments.of(Amount(<span class="number">1000</span>, <span class="number">2</span>), <span class="number">2000</span>),</span><br><span class="line">            Arguments.of(Amount(<span class="number">2000</span>, <span class="number">5</span>), <span class="number">10000</span>),</span><br><span class="line">            Arguments.of(Amount(<span class="number">4000</span>, <span class="number">5</span>), <span class="number">20000</span>),</span><br><span class="line">            Arguments.of(Amount(<span class="number">5000</span>, <span class="number">3</span>), <span class="number">15000</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@MethodSource()</code>에 입력하는 문자열과,  값을 지정하는 static 메서드명과 일치해야 합니다. 테스트 하고자 하는 객체와, 예상되는 값을 넘겨받아 다양한 객체의 경우를 쉽게 테스트할 수 있습니다.</p><h2><span id="spring-boot">Spring Boot</span></h2><p>Junit5 관련된 내용은 아니지만 Junit5와 Spring Boot 관련 테스트할때 좋은 패턴을 정리했습니다.</p><h3><span id="생성자-주입">생성자 주입</span></h3><p><code>@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</code> 어노테이션을 통해서 테스트 코드에서도 생성자 주입이 가능해 졌습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(<span class="meta-string">"test"</span>)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberRepositoryTest</span></span>(<span class="keyword">val</span> memberRepository: MemberRepository) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `members 조회 테스트`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//given</span></span><br><span class="line">        <span class="keyword">val</span> email = <span class="string">"asd@asd.com"</span></span><br><span class="line">        <span class="keyword">val</span> name = <span class="string">"name"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//when</span></span><br><span class="line">        <span class="keyword">val</span> member = memberRepository.save(Member(email, name))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//then</span></span><br><span class="line">        assertThat(member.email).isEqualTo(email)</span><br><span class="line">        assertThat(member.name).isEqualTo(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="dsl-지원">DSL 지원</span></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(<span class="meta-string">"test"</span>)</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberApiTest</span></span>(</span><br><span class="line">        <span class="keyword">val</span> memberRepository: MemberRepository,</span><br><span class="line">        <span class="keyword">val</span> mockMvc: MockMvc</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `test`<span class="params">()</span></span> &#123;</span><br><span class="line">        memberRepository.saveAll(listOf(</span><br><span class="line">                Member(<span class="string">"email1@asd.com"</span>, <span class="string">"jin"</span>),</span><br><span class="line">                Member(<span class="string">"email2@asd.com"</span>, <span class="string">"yun"</span>),</span><br><span class="line">                Member(<span class="string">"email3@asd.com"</span>, <span class="string">"wan"</span>),</span><br><span class="line">                Member(<span class="string">"email4@asd.com"</span>, <span class="string">"kong"</span>),</span><br><span class="line">                Member(<span class="string">"email5@asd.com"</span>, <span class="string">"joo"</span>)</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        mockMvc.<span class="keyword">get</span>(<span class="string">"/members"</span>) &#123;</span><br><span class="line">            accept = MediaType.APPLICATION_JSON</span><br><span class="line">        &#125;.andExpect &#123;</span><br><span class="line">            content &#123; contentType(MediaType.APPLICATION_JSON) &#125;</span><br><span class="line">            jsonPath(<span class="string">"$[0].name"</span>) &#123; value(<span class="string">"jin"</span>) &#125;</span><br><span class="line">            jsonPath(<span class="string">"$[1].name"</span>) &#123; value(<span class="string">"yun"</span>) &#125;</span><br><span class="line">            jsonPath(<span class="string">"$[2].name"</span>) &#123; value(<span class="string">"wan"</span>) &#125;</span><br><span class="line">            jsonPath(<span class="string">"$[3].name"</span>) &#123; value(<span class="string">"kong"</span>) &#125;</span><br><span class="line">            jsonPath(<span class="string">"$[4].name"</span>) &#123; value(<span class="string">"joo"</span>) &#125;</span><br><span class="line">        &#125;.andDo &#123;</span><br><span class="line">            print()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebMvc에서도 DSL 사용을 할 수 있습니다. Web 관련 테스트 코드를 작성하기 더욱 편리해졌습니다.</p><h3><span id="sql-손쉽게-data-set-up">@Sql 손쉽게 Data Set up</span></h3><p><code>*.sql</code> 파일로 손쉽게 데이터를 Set up할 수 있습니다. JPA를 사용중이라면 Given절로 JPA를 만들기가 어렵고 불편한 경우 사용하면 좋을거 같습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># member-data-setup.sql</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">member</span> (<span class="string">`email`</span>, <span class="string">`name`</span>, <span class="string">`created_at`</span>, <span class="string">`updated_at`</span>)</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">(<span class="string">'sample1@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>()),</span><br><span class="line">(<span class="string">'sample2@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>()),</span><br><span class="line">(<span class="string">'sample3@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>()),</span><br><span class="line">(<span class="string">'sample4@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>()),</span><br><span class="line">(<span class="string">'sample5@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>()),</span><br><span class="line">(<span class="string">'sample6@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>()),</span><br><span class="line">(<span class="string">'sample15@asd.com'</span>, <span class="string">'name'</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── test</span><br><span class="line">    ├── kotlin</span><br><span class="line">    │   └── com</span><br><span class="line">    └── resources</span><br><span class="line">        └── member-data-setup.sql</span><br></pre></td></tr></table></figure><p>위에서 작성한  <code>*.sql</code> 파일을 <code>test/resources</code> 디렉토리에 위치시킵니다</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Sql(<span class="meta-string">"/member-data-setup.sql"</span>)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">name</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAll()</span><br><span class="line"></span><br><span class="line">    then(members).anySatisfy &#123;</span><br><span class="line">        then(it.name).isEqualTo(<span class="string">"name"</span>)</span><br><span class="line">        then(it.email).contains(<span class="string">"@"</span>)</span><br><span class="line">                .startsWith(<span class="string">"sample"</span>)</span><br><span class="line">                .endsWith(<span class="string">"com"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Sql</code> 어노테이션을 통헤서 해당 디렉터리의 위치와 파일 이름을 작성합니다. 기본적인 디렉터리를 <code>test/resources</code>을 바라보기 때문에 위와 같은 경우 파일명만 작성합니다.</p><h2><span id="assertj">AssertJ</span></h2><p>Junit5의 관련된 내용은 아니지만 이번 Spring Boot 2.2 Release에서 AssertJ 관련된 내용이 있어 AssertJ의 사용과 간략한 팁을 정리했습니다.</p><p><code>AssertJ</code>는 개인적으로 선호하는 Test Matcher입니다. static 메서드로 동작하기 때문에 자동 완성으로 Matcher 기능들을 손쉽게 사용할 수 있고, Matcher에서 지원해주는 기능도 막강합니다. AssertJ에서는 BDD 스타일의 BDDAssertion을 제공해주고 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `member save test`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    <span class="keyword">val</span> email = <span class="string">"asd@asd.com"</span></span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"name"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    <span class="keyword">val</span> member = memberRepository.save(Member(email, name))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//then</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 기존 사용법 assertThat </span></span><br><span class="line">    assertThat(member.email).isEqualTo(email)</span><br><span class="line">    assertThat(member.name).isEqualTo(name)</span><br><span class="line">    assertThat(member.createdAt).isBeforeOrEqualTo(LocalDateTime.now())</span><br><span class="line">    assertThat(member.updatedAt).isBeforeOrEqualTo(LocalDateTime.now())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BDD 사용법</span></span><br><span class="line">    then(member.email).isEqualTo(email)</span><br><span class="line">    then(member.name).isEqualTo(name)</span><br><span class="line">    then(member.createdAt).isBeforeOrEqualTo(LocalDateTime.now())</span><br><span class="line">    then(member.updatedAt).isBeforeOrEqualTo(LocalDateTime.now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>assertThat</code> -&gt; <code>then</code> 으로 대체되었습니다. 코드도 적어지고 더 직관적으로 되어서 좋아졌습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `문장 검사`<span class="params">()</span></span> &#123;</span><br><span class="line">    then(<span class="string">"AssertJ is best matcher"</span>).isNotNull()</span><br><span class="line">            .startsWith(<span class="string">"AssertJ"</span>)</span><br><span class="line">            .contains(<span class="string">" "</span>)</span><br><span class="line">            .endsWith(<span class="string">"matcher"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 형식으로 코드를 연결해서 테스트할 수도 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `findByName test`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    memberRepository.saveAll(listOf(</span><br><span class="line">            Member(<span class="string">"email1@asd.com"</span>, <span class="string">"kim"</span>),</span><br><span class="line">            Member(<span class="string">"email2@asd.com"</span>, <span class="string">"kim"</span>),</span><br><span class="line">            Member(<span class="string">"email3@asd.com"</span>, <span class="string">"kim"</span>),</span><br><span class="line">            Member(<span class="string">"email4@asd.com"</span>, <span class="string">"name"</span>),</span><br><span class="line">            Member(<span class="string">"email5@asd.com"</span>, <span class="string">"name"</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findByName(<span class="string">"kim"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//then</span></span><br><span class="line">    then(members).anySatisfy &#123;</span><br><span class="line">        then(it.name).isEqualTo(<span class="string">"kim"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>anySatisfy</code> 람다 표현식으로 members를 iterator 돌리면서 해당 <code>kim</code>과 일치하는지 편리하게 확인할 수 있습니다. 이 밖에도 다양한 것들을 제공하고 있고 계속 발전하고 있는 AssertJ를 추천드립니다.</p><h3><span id="thenthrownby">thenThrownBy</span></h3><p>thenThrownBy을 통해서 Exception 테스트를 쉽게 진행할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validateBeforeSave</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fieldName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"<span class="variable">$id</span> empty <span class="variable">$fieldName</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        validate(email, <span class="string">"email"</span>)</span><br><span class="line">        validate(name, <span class="string">"name"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>빈 문자열인 경우 <code>IllegalArgumentException</code> 예외를 발생시키는 로직을 아래 처럼 테스트할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `member 실패`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> member = Member(<span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">    thenThrownBy &#123; member.validateBeforeSave() &#125;</span><br><span class="line">            .isExactlyInstanceOf(IllegalArgumentException::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">            .hasMessageContaining(<span class="string">"empty"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>특정 예외가 발생하는지, 예외 메시지의 특정한 값이 존재하는지 간단하게 확인할 수 있습니다.</p><h2><span id="참고">참고</span></h2><ul><li><a href="https://www.baeldung.com/parameterized-tests-junit-5" rel="external nofollow noopener noreferrer" target="_blank">Guide to JUnit 5 Parameterized Tests</a></li><li><a href="http://wonwoo.ml/index.php/post/category/kotlin" rel="external nofollow noopener noreferrer" target="_blank">머루의개발블로그 : Spring 5.2 와 Spring boot 2.2 추가된 Test 기능들</a></li><li><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.2-Release-Notes" rel="external nofollow noopener noreferrer" target="_blank">Spring Boot 2.2 Release Notes</a></li><li><a href="https://www.baeldung.com/parameterized-tests-junit-5" rel="external nofollow noopener noreferrer" target="_blank">Baeldung : Guide to JUnit 5 Parameterized Tests</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;해당 코드는 &lt;a href=&quot;https://github.com/cheese10yun/blog-sample/tree/master/kotlin-junit5&quot; rel=&quot;external nofollow noopener norefe
      
    
    </summary>
    
    
      <category term="Test" scheme="https://cheese10yun.github.io/tags/Test/"/>
    
      <category term="Junit5" scheme="https://cheese10yun.github.io/tags/Junit5/"/>
    
  </entry>
  
</feed>
